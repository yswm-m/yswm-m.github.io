{"meta":{"title":"一生雾梦","subtitle":"一生雾梦の博客","description":"欢迎光临我的个人博客!","author":"一生雾梦","url":"https://yswm-m.github.io","root":"/"},"pages":[{"title":"留言板","date":"2022-09-15T02:11:28.000Z","updated":"2022-09-15T05:30:57.081Z","comments":false,"path":"comments/index.html","permalink":"https://yswm-m.github.io/comments/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-09-15T14:17:49.000Z","updated":"2022-09-15T06:16:32.025Z","comments":true,"path":"link/index.html","permalink":"https://yswm-m.github.io/link/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-09-15T07:12:19.000Z","updated":"2022-09-15T05:31:15.817Z","comments":false,"path":"categories/index.html","permalink":"https://yswm-m.github.io/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2022-09-14T16:00:00.000Z","updated":"2022-09-26T10:08:04.006Z","comments":true,"path":"archives/index.html","permalink":"https://yswm-m.github.io/archives/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2022-09-16T08:14:00.000Z","updated":"2022-09-16T03:34:18.230Z","comments":true,"path":"music/index.html","permalink":"https://yswm-m.github.io/music/index.html","excerpt":"","text":""},{"title":"关于博主","date":"2022-09-14T01:07:56.000Z","updated":"2023-05-12T11:40:44.819Z","comments":false,"path":"about/index.html","permalink":"https://yswm-m.github.io/about/index.html","excerpt":"","text":"关于博主 博主是一名中专升大专并专升本的学生，我接触编程纯属偶然，本以为自己上了中专后一生都不会再学习了，但造化弄人，无意间在17岁点开了《郝斌C语言自学教程》，再加上当时学校有开C语言的课，从此便喜欢上了C语言，花费各种时间去学习C语言的相关知识，和同学讨论C语言的相关问题，还考得了《全国计算机二级C语言证书》，曾经有一段时间我甚至觉得C语言就是为我而准备的语言，包括后面去学习C++时我也认为那不过是C语言的强化版而已，是C语言为我准备的另一个礼物，我也毫无保留的将我的喜欢给了C++，相比较其他语言我觉得C/C++写的代码简洁，逻辑清晰，运行速度快，比java和C#那种单词长代码量多和python那种速度慢的语言要友好的多。直到参加比赛遇到那些天才高中生我才发现我不过就是一个基础薄弱的普通人罢了。 喜欢自己所喜欢的，做自己想做的，追求自由与潇洒，多酷啊！ 想法是美好的，可现实... ... 给大家推荐一首诗吧： 《自由与爱情》---作者:裴多菲 ​ 生命诚可贵 ​ 爱情价更高 ​ 若为自由故 ​ 二者皆可抛 虽然我被打击到了，但是承认自己的平庸也没啥不好嘛，毕竟人外有人天外有天，无论被打击成什么样，我始终还是忘不了C语言在我入门时带给我的冲劲，忘不了用C++第一次参加比赛拿奖时给予我的感动和自豪，谢谢你们拯救了一个曾经迷茫无助的少年，就算以后所有人都告诉我不要学C++，就算所有人都认为我学C++没有前途，我也永远不会放弃C/C++的。 联系我 B站：零级盛开的定理（萌新up） QQ：3269661045 （欢迎和我一起交流问题！） 座右铭：若一心追逐北极星，所经路线便能成为地图。"},{"title":"标签","date":"2022-09-15T07:14:39.000Z","updated":"2022-09-15T06:16:00.312Z","comments":false,"path":"tags/index.html","permalink":"https://yswm-m.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-03-24T03:16:36.872Z","updated":"2022-09-15T03:10:31.294Z","comments":true,"path":"self/Kimbiedark.css","permalink":"https://yswm-m.github.io/self/Kimbiedark.css","excerpt":"","text":"/* Name: Kimbie (dark) Author: Jan T. Sott License: Creative Commons Attribution-ShareAlike 4.0 Unported License URL: https://github.com/idleberg/Kimbie-highlight.js */ /* 新添加的內容 ------------------------------------- --hl-color 代碼框字體顔色 【必須】 (把下面.hljs的 color複製到這裏來) --hl-bg 代碼框背景色 【必須】 (把下面.hljs的 background複製到這裏來) --hltools-bg: #321a0f 代碼框頂部工具欄背景色 【可選】(如果你關掉了 copy、lang 和 shrink,可不用配置這個） --hltools-color: #fff 代碼框頂部工具欄字體顔色 【可選】(如果你關掉了 copy、lang 和 shrink,可不用配置這個） --hlnumber-bg: #221a0f 代碼框行數背景色 【可選】(如果已經關掉 line_number,可以不用配置這個) --hlnumber-color: #fff 代碼框行數字體顔色 【可選】 (如果已經關掉 line_number,可以不用配置這個) --hlscrollbar-bg: #d3af86 代碼框滾動條顔色 【可選】（默認為主題主顔色） --hlexpand-bg: #d3af86 代碼框底部展開背景色 【可選】(如果已經關掉 highlight_height_limit,可以不用配置這個) */ :root { --hl-color: #d3af86; --hl-bg: #221a0f; --hltools-bg: #321a0f; --hltools-color: #fff; --hlnumber-bg: #221a0f; --hlnumber-color: #fff; --hlscrollbar-bg: #d3af86; --hlexpand-bg: #d3af86; } /* Kimbie Comment */ .hljs-comment, .hljs-quote { color: #d6baad; } /* Kimbie Red */ .hljs-variable, .hljs-template-variable, .hljs-tag, .hljs-name, .hljs-selector-id, .hljs-selector-class, .hljs-regexp, .hljs-meta { color: #dc3958; } /* Kimbie Orange */ .hljs-number, .hljs-built_in, .hljs-builtin-name, .hljs-literal, .hljs-type, .hljs-params, .hljs-deletion, .hljs-link { color: #f79a32; } /* Kimbie Yellow */ .hljs-title, .hljs-section, .hljs-attribute { color: #f06431; } /* Kimbie Green */ .hljs-string, .hljs-symbol, .hljs-bullet, .hljs-addition { color: #889b4a; } /* Kimbie Purple */ .hljs-keyword, .hljs-selector-tag, .hljs-function { color: #98676a; } /* 更改的內容 把.hljs改為 #article-container figure.highlight .hljs *、 /* ------------------------------------- */ #article-container figure.highlight .hljs { display: block; overflow-x: auto; background: #221a0f; color: #d3af86; padding: 0.5em; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: bold; }"},{"title":"","date":"2023-03-24T03:16:36.871Z","updated":"2022-09-15T03:22:23.513Z","comments":true,"path":"self/duotone.css","permalink":"https://yswm-m.github.io/self/duotone.css","excerpt":"","text":"/* 新添加的內容 ------------------------------------- --hl-color 代碼框字體顔色 【必須】 (把下面 pre[class*=\"language-\"]的 color 複製到這裏來) --hl-bg 代碼框背景色 【必須】 (把下面 pre[class*=\"language-\"]的 background複製到這裏來) --hltools-bg: #321a0f 代碼框頂部工具欄背景色 【可選】(如果你關掉了 copy、lang 和 shrink,可不用配置這個） --hltools-color: #fff 代碼框頂部工具欄字體顔色 【可選】(如果你關掉了 copy、lang 和 shrink,可不用配置這個） --hlnumber-bg: #221a0f 代碼框行數背景色 【可選】(如果已經關掉 line_number,可以不用配置這個) --hlnumber-color: #fff 代碼框行數字體顔色 【可選】 (如果已經關掉 line_number,可以不用配置這個) --hlscrollbar-bg: #d3af86 代碼框滾動條顔色 【可選】（默認為主題主顔色） --hlexpand-bg: #d3af86 代碼框底部展開背景色 【可選】(如果已經關掉 highlight_height_limit,可以不用配置這個) */ :root { --hl-color: #728fcb; --hl-bg: #faf8f5; --hltools-bg: xxxxxxx; --hltools-color: xxxxxxx; --hlnumber-bg: xxxxxxx; --hlnumber-color: xxxxxxxx; --hlscrollbar-bg: xxxxx; --hlexpand-bg: xxxxxxx } /* ------------------------------------- */ /* 這些可以刪除（可留着，如果有衝突，請刪除） */ /* ------------------------------------- */ code[class*=\"language-\"], pre[class*=\"language-\"] { font-family: Consolas, Menlo, Monaco, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace; font-size: 14px; line-height: 1.375; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; -moz-tab-size: 4; -o-tab-size: 4; tab-size: 4; -webkit-hyphens: none; -moz-hyphens: none; -ms-hyphens: none; hyphens: none; background: #faf8f5; color: #728fcb; } pre&gt;code[class*=\"language-\"] { font-size: 1em; } pre[class*=\"language-\"]::-moz-selection, pre[class*=\"language-\"] ::-moz-selection, code[class*=\"language-\"]::-moz-selection, code[class*=\"language-\"] ::-moz-selection { text-shadow: none; background: #faf8f5; } pre[class*=\"language-\"]::selection, pre[class*=\"language-\"] ::selection, code[class*=\"language-\"]::selection, code[class*=\"language-\"] ::selection { text-shadow: none; background: #faf8f5; } /* Code blocks */ pre[class*=\"language-\"] { padding: 1em; margin: .5em 0; overflow: auto; } /* Inline code */ :not(pre)&gt;code[class*=\"language-\"] { padding: .1em; border-radius: .3em; } /* ------------------------------------- */ /* 到這裏為止，可以刪除 */ .token.comment, .token.prolog, .token.doctype, .token.cdata { color: #b6ad9a; } .token.punctuation { color: #b6ad9a; } .token.namespace { opacity: .7; } .token.tag, .token.operator, .token.number { color: #063289; } .token.property, .token.function { color: #b29762; } .token.tag-id, .token.selector, .token.atrule-id { color: #2d2006; } code.language-javascript, .token.attr-name { color: #896724; } code.language-css, code.language-scss, .token.boolean, .token.string, .token.entity, .token.url, .language-css .token.string, .language-scss .token.string, .style .token.string, .token.attr-value, .token.keyword, .token.control, .token.directive, .token.unit, .token.statement, .token.regex, .token.atrule { color: #728fcb; } .token.placeholder, .token.variable { color: #93abdc; } .token.deleted { text-decoration: line-through; } .token.inserted { border-bottom: 1px dotted #2d2006; text-decoration: none; } .token.italic { font-style: italic; } .token.important, .token.bold { font-weight: bold; } .token.important { color: #896724; } .token.entity { cursor: help; } pre&gt;code.highlight { outline: .4em solid #896724; outline-offset: .4em; } /* overrides color-values for the Line Numbers plugin * http://prismjs.com/plugins/line-numbers/ */ .line-numbers .line-numbers-rows { border-right-color: #ece8de; } .line-numbers-rows&gt;span:before { color: #cdc4b1; } /* overrides color-values for the Line Highlight plugin * http://prismjs.com/plugins/line-highlight/ */ .line-highlight { background: rgba(45, 32, 6, 0.2); background: -webkit-linear-gradient(left, rgba(45, 32, 6, 0.2) 70%, rgba(45, 32, 6, 0)); background: linear-gradient(to right, rgba(45, 32, 6, 0.2) 70%, rgba(45, 32, 6, 0)); }"},{"title":"相册","date":"2023-03-24T03:16:36.787Z","updated":"2022-09-24T05:43:15.541Z","comments":false,"path":"List/gallery/index.html","permalink":"https://yswm-m.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片 OH MY GIRL 關於OH MY GIRL的圖片"},{"title":"Music-BBOX","date":"2022-09-23T09:58:56.000Z","updated":"2022-09-26T10:07:07.103Z","comments":false,"path":"List/music/index.html","permalink":"https://yswm-m.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-15T08:41:10.000Z","updated":"2022-09-15T06:18:34.542Z","comments":false,"path":"List/movies/index.html","permalink":"https://yswm-m.github.io/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"","date":"2022-09-22T14:56:14.000Z","updated":"2022-09-24T06:14:05.411Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"https://yswm-m.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-14T01:56:14.000Z","updated":"2022-09-21T06:03:49.109Z","comments":false,"path":"List/gallery/yswm/index.html","permalink":"https://yswm-m.github.io/List/gallery/yswm/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-23T14:56:13.000Z","updated":"2022-09-24T06:09:38.653Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://yswm-m.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"C++设计模式（单例模式）","slug":"35-C++设计模式（单例模式）","date":"2022-09-30T02:40:00.000Z","updated":"2022-09-28T09:50:09.491Z","comments":true,"path":"posts/35.html","link":"","permalink":"https://yswm-m.github.io/posts/35.html","excerpt":"","text":"更多教程笔记请查看我的上一篇文章：点击跳转 C++设计模式自学之旅开始！ 本次将介绍C++设计模式里比较基础的模式：单例模式 C++的设计模式很早就有了，不过我后面去学Qt了，一直没有时间好好把设计模式过一遍，下次有时间我再更新关于Qt的教程…… 据说所有的大公司，软件设计的开发人员，都恨不得给自己写的所有代码都套上设计模式，是否真的有那么玄呢? 今天我们来一探其中的奥秘 单例模式代码: //设计模式-单例模式 #include &lt;iostream&gt; using namespace std; //所谓单例模式就是程序只有一个实例 class Singleton { public: ~Singleton() { cout &lt;&lt; \"~Singleton() construct\" &lt;&lt; endl; } //提供一个接口来让用户创建对象,让用户只能通过这种方式创建 //加上static是因为如果用户没有对象那么就无法创建对象,于是可以把这个接口定义到全局变为静态 // static Singleton *CreateObject() // { // //如果一开始对象的指针是空那么就创建对象 // if (m_pObject == nullptr) // { // m_pObject = new Singleton(); // } // return m_pObject; // } //最安全的写法,不会造成内存泄漏 static Singleton &amp;CreateObject() { //创建一个静态成员 static Singleton obj; //返回这个成员变量,永远只返回这一个 return obj; } //如果用户调用拷贝构造函数就直接释放 Singleton(Singleton &amp;obj) = delete; //利用运算符重载禁用拷贝构造函数 Singleton *operator=(Singleton &amp;obj) = delete; private: //将构造函数私有化来限制构造函数只允许创建一个对象 Singleton() { cout &lt;&lt; \"Singleton() construct\" &lt;&lt; endl; } //限制拷贝构造函数 让用户只能用引用来接收 不能用拷贝的方式接收 // Singleton(Singleton &amp;obj) // { // cout &lt;&lt; \"Singleton(Singleton&amp; obj) construct\" &lt;&lt; endl; // } //定义一个静态对象指针用来判断接口是否只创建了一次对象 //静态对象指针只能访问静态的成员函数 // static Singleton *m_pObject; }; //将静态对象指针声明 // Singleton *Singleton::m_pObject = nullptr; int main() { //当构造函数不公有化了就无法再通过直接创建对象的方式调用构造函数 // Singleton s1; // Singleton s2; // Singleton *pObj1 = Singleton::CreateObject(); //需要手动释放指针才不会造成内存泄漏 // // delete pObj1; // Singleton *pObj2 = Singleton::CreateObject(); //安全的写法,返回一个静态成员变量的引用,用引用来接收 Singleton &amp;pObj1 = Singleton::CreateObject(); //错误 无法通过拷贝构造接收 // Singleton pObj2 = Singleton::CreateObject(); return 0; }","categories":[{"name":"C++","slug":"C","permalink":"https://yswm-m.github.io/categories/C/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"学习","slug":"学习","permalink":"https://yswm-m.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"笔记","slug":"笔记","permalink":"https://yswm-m.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"C++11（lambad表达式）","slug":"34-C++11（lambda表达式）","date":"2022-09-29T02:30:00.000Z","updated":"2022-09-28T09:50:03.387Z","comments":true,"path":"posts/34.html","link":"","permalink":"https://yswm-m.github.io/posts/34.html","excerpt":"","text":"更多教程笔记请查看我的上一篇文章：点击跳转 C++11（lambad表达式）自学之旅开始！ 本次将介绍C++11里新的函数写法：labmda表达式 lambda表达式很早就有了，后来被C++11引入，原本我对lambda的语法一点兴趣都没有，可是之前还在公司的一个学长跟我说lambda表达式很有用，所以我就去学了。 这东西确实挺厉害的，据说发明他的作者认为一切程序的本质都是函数，后面还用了数学公式证明，不得不说数学厉害的人写程序真的强，随便就弄出一个定理和语法规范，让我们都得跟着学。 语法嵌套按值捕获按引用捕获实战函数对象包装器bind机制lambda表达式语法 // lambda表达式 #include &lt;iostream&gt; using namespace std; //正常函数的写法 有名字,有返回值,有参数列表 int fun(int a, int b) { return a + b; } int main() { /* lambda表达式的本质就是一个仿函数(匿名函数) 也就是一个类里面有一个operator()() 重载小括号 它没有名字 */ //这是lambda表达式的写法,匿名的,前面的[]符号代表正常函数中的fun也就是名字,后面的()符号 //代表函数的参数列表,再后面的-&gt;int代表函数的返回值类型,也就是正常函数前面的int,void之类的 //紧接着后面的{}里写函数的主体,也就是函数的具体实现,最后一个()里写调用函数时的传参 // 1.[]函数名字 2.()参数列表 3.-&gt;int函数返回值类型 4.{}函数主体 //最后返回的值在最前面用一个变量来接收 int c = [](int a, int b) -&gt; int { //函数主体 return a + b; }(1, 2); // 5.()调用函数传参 在定义时就可以立即匿名调用 但是在其他地方就用不了了 //上面等价于下面 int c2 = fun(1, 2); cout &lt;&lt; c &lt;&lt; endl; //第二种写法 使用自动类型推导 auto将会把它推成一个匿名函数的类型 //也就是把f当作这个匿名函数的名字,那么在其他地方就可以通过f调用到这个匿名函数 auto f = [](int a, int b) -&gt; int { //函数主体 return a + b; }; // f被当作了上面这个匿名函数的名字,通过f调用到了这个匿名函数 int c3 = f(1, 2); cout &lt;&lt; c3 &lt;&lt; endl; return 0; }lambda表达式实战-嵌套 // lambda表达式实战-嵌套 #include &lt;iostream&gt; using namespace std; int main() { // lambda嵌套lambda // lambda 跟普通类型一样可以作为参数也可以作为返回值 这里就是作为返回值 也叫Currying //函数编程 用于多线程 并发 //外面的函数体返回的是内部的函数体的内容 int c = [](int n) { //内部的函数体可以使用外部的函数体的形参,只要在内部的函数体的[]里加上外部的变量名即可 return [n](int x) { //只有一条return语句可以不写返回类型，编译器会推断 其他情况不写就是void return n + x; }(1); // 匿名调用内部的函数 1传给x }(2); // 匿名调用外部的函数 2传给n cout &lt;&lt; c &lt;&lt; endl; //通过自动类型推导为匿名函数加上名字,可以让它在其他地方调用 auto f = [](int n) { cout &lt;&lt; \"n= \" &lt;&lt; n &lt;&lt; endl; return [n](int x) { cout &lt;&lt; \"x= \" &lt;&lt; x &lt;&lt; endl; return n + x; }; }; //调用函数传参 1传给n 2传给x 先传参调用外层,再传参调用里层 int c2 = f(1)(2); cout &lt;&lt; c2 &lt;&lt; endl; return 0; }lambda按值捕获-mutable // mutable-lambda按值捕获 #include &lt;iostream&gt; using namespace std; int main() { // lambda第三种写法 int t = 10; //如果想要获取外部(上面)的t的值,那么就不能写在参数列表()里,参数列表是在调用时传的 //要写在[]里,[]是捕获列表,也就是匿名函数的捕获区,在捕获区里写变量名即可捕获外部的变量 //在[]里捕获的变量默认是const类型,无法被修改,只有在()后面加了mutable关键字后[]捕获的值才能被修改 auto f = [t]() mutable { return ++t; }; //在用mutable进行捕获时会单独拷贝出一份地址,这样在里面修改的值会一直保存在函数体里,下一次调用时会依旧使用上一次拷贝的值 //这个值只在当前的匿名函数内部是有效的,就算外部有一个一模一样的匿名函数调用也只拷贝原来变量的值,无法拷贝之前匿名函数的值 // 11 cout &lt;&lt; f() &lt;&lt; endl; // 12 cout &lt;&lt; f() &lt;&lt; endl; //按值捕获,在函数体内部的修改影响不了外部的值,也就是形参无法修改实参 cout &lt;&lt; t &lt;&lt; endl; return 0; }lambda按引用捕获 // lambda按引用捕获 #include &lt;iostream&gt; using namespace std; int main() { //按值捕获 int t = 10; [t]() { cout &lt;&lt; t &lt;&lt; endl; }(); auto f = [t]() { cout &lt;&lt; t &lt;&lt; endl; }; t = 11; // 10 按值捕获的时候,在捕获时变量的值是多少,捕获的值就是多少,无法捕获到在捕获后面才声明的值 f(); //按引用捕获,传的是指针,可以改变实参 auto f2 = [&amp;t]() { t = 13; }; t = 11; f2(); // 13 按引用捕获可以捕获到在函数后面才声明的值,并可以改变它,在函数调用前变量的值是多少,引用捕获的值就是多少 //在函数内部修改按引用捕获的值后就可以修改外部变量的值,也就是通过指针改变实参 cout &lt;&lt; \"&amp;t = \" &lt;&lt; t &lt;&lt; endl; //捕获列表,可以同时捕获多个变量 int a = 1; int b = 2; int c = 3; int d = 4; [a, b]() { cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \" b= \" &lt;&lt; b &lt;&lt; endl; }(); //捕获外部所有的变量,按值捕获 [=]() { cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \" b= \" &lt;&lt; b &lt;&lt; \" c = \" &lt;&lt; c &lt;&lt; \" d= \" &lt;&lt; d &lt;&lt; \" t= \" &lt;&lt; t &lt;&lt; endl; }(); //捕获外部所有的变量,按引用捕获 [&amp;]() { cout &lt;&lt; \"&amp;a = \" &lt;&lt; a++ &lt;&lt; \" &amp;b= \" &lt;&lt; ++b &lt;&lt; \" &amp;c = \" &lt;&lt; c++ &lt;&lt; \" &amp;d= \" &lt;&lt; d++ &lt;&lt; \" &amp;t= \" &lt;&lt; ++t &lt;&lt; endl; }(); //既按值捕获,又按引用捕获 [a, b, &amp;c, d, &amp;t]() { cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \" b= \" &lt;&lt; b &lt;&lt; \" &amp;c = \" &lt;&lt; c++ &lt;&lt; \" d= \" &lt;&lt; d &lt;&lt; \" &amp;t= \" &lt;&lt; ++t &lt;&lt; endl; }(); return 0; }lambda实战 // lambda实战 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; void test01() { //使用动态数组遍历判断奇偶数的普通写法 vector&lt;int&gt; v = {1, 2, 3, 4, 5}; for (int i = 0; i &lt; v.size(); i++) { if (v[i] % 2 == 0) { cout &lt;&lt; v[i] &lt;&lt; \"是偶数\" &lt;&lt; endl; } else { cout &lt;&lt; v[i] &lt;&lt; \"是奇数\" &lt;&lt; endl; } } cout&lt;&lt;\"-------------------------------\"&lt;&lt;endl; //使用lambda的写法,在for_each的最后面使用匿名函数遍历 //在每一次遍历完后将元素传递给参数列表的n for_each(v.begin(), v.end(), [](int n) { if (n % 2 == 0) { cout &lt;&lt; n &lt;&lt; \"是偶数\" &lt;&lt; endl; } else { cout &lt;&lt; n &lt;&lt; \"是奇数\" &lt;&lt; endl; } }); } int main() { test01(); return 0; }lambda-function函数对象包装器 // lambda-function函数对象包装器 #include &lt;iostream&gt; using namespace std; //需要包含这个头文件 #include &lt;functional&gt; int test01(int n) { cout &lt;&lt; n &lt;&lt; endl; return n; } class CTest { public: //构造函数 CTest() {} //普通成员函数 int Mytest(int n) { cout &lt;&lt; n &lt;&lt; endl; return n; } //仿函数的写法 int operator()(int n) { cout &lt;&lt; n &lt;&lt; endl; return n; } }; int main() { //普通函数 test01(1); //函数对象包装器,第一个int是返回值的类型,第二个()里的int是参数列表 function&lt;int(int)&gt; f = test01; //将普通函数包装成一个叫做f的对象,可以直接使用f进行调用 f(123); //支持4种函数的包装:1.普通函数 2.匿名函数 3.类的成员函数 4.仿函数(重载了()运算符的函数) //匿名函数包装 function&lt;int(int)&gt; f2 = [](int n) -&gt; int { cout &lt;&lt; n &lt;&lt; endl; return n; }; f2(456); //类的成员函数包装 因为类的成员函数传递的是类的对象的引用,所以在参数列表里要写上类的指针 function&lt;int(CTest *, int)&gt; f3 = &amp;CTest::Mytest; CTest t; //调用包装的函数 f3(&amp;t, 789); //仿函数的包装 function&lt;int(CTest *, int)&gt; f4 = &amp;CTest::operator(); //调用仿函数 f4(&amp;t, 123); return 0; }lambda-bind机制 // bind机制 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; void test01(int a, int b, int c, int d) { cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; \" \" &lt;&lt; c &lt;&lt; \" \" &lt;&lt; d &lt;&lt; endl; } int main() { //假设有一个函数有很多的参数,而每次调用的时候都想传递1 2 3 4 给参数 a b c d //那么就可以利用bind把调用的过程用参数和函数名绑定变成一个对象 auto a = bind(test01, 1, 2, 3, 4); //那么在下次调用时就可以直接通过调用对象的方式调用绑定的函数,函数默认传参 a(); //假设在绑定时第2个函数的参数暂时不知道,可以用placeholders使参数待定,等待调用的时候再根据传递的值进行绑定 //_1代表第一个参数,也就是调用的时候先传的第一个参数 auto foo2 = bind(test01, 1, placeholders::_1, 3, 4); //这里的2是传给了placeholders::_1 foo2(2); //使多个参数待定 auto foo3 = bind(test01, 1, placeholders::_2, placeholders::_1, 4); //这里的1是传给了placeholders::_1, 2是传给了placeholders::_2 //这样的话就可以使函数调用的顺序不同 foo3(1, 2); return 0; }","categories":[{"name":"C++","slug":"C","permalink":"https://yswm-m.github.io/categories/C/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"学习","slug":"学习","permalink":"https://yswm-m.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"笔记","slug":"笔记","permalink":"https://yswm-m.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"C++11（RAll智能指针）","slug":"33-C++11（RAll智能指针）","date":"2022-09-28T02:28:00.000Z","updated":"2022-09-28T09:49:52.144Z","comments":true,"path":"posts/33.html","link":"","permalink":"https://yswm-m.github.io/posts/33.html","excerpt":"","text":"更多教程笔记请查看我的上一篇文章：点击跳转 C++11（RAll智能指针）自学之旅开始！ 本次将介绍C++11最有用的更新：智能指针 长久以来C++的内存管理机制就一直被人诟病，没有GC回收，需要手动释放分配的内存，很容易被忘记释放内存的程序员造成内存泄漏，甚至被linux之父Linus炮轰C++是一门很烂的语言 详情请点击这里 但是C++也在不断的改进自身，不断的吸取教训，我相信C++未来会越来越好！ 说回话题本身，智能指针是一个可以帮助C++程序员自动释放所分配内存的强大利器，不过用得好和用不好是两回事，下面我们来看一下智能指针的诞生原因： 概念实战概念代码： //智能指针 #include &lt;iostream&gt; #include \"stdfix.h\" using namespace std; // c语言当中对文件的操作 FILE *open_file(char *name) { FILE *fp = NULL; fp = fopen(name, \"rb++\"); return fp; } class CTest { public: CTest() { cout &lt;&lt; \"构造函数\" &lt;&lt; endl; //申请堆区资源 m_pInt = new int; } ~CTest() { cout &lt;&lt; \"析构函数\" &lt;&lt; endl; if (m_pInt != nullptr) { //释放资源 delete m_pInt; m_pInt = nullptr; } } private: int *m_pInt; }; //创建一个全局对象,全局对象有构造有析构,在对象创建和销毁前编译器都会主动调用构造和析构函数 //利用这个机制即可解决手动释放资源所带来的问题 CTest test; int main() { // c++需要自己管理堆内存的申请和释放 int *p = new int; delete p; //有的时候会忘记资源的释放导致资源泄漏 return 0; }看明白了吧，在对象创建和销毁前编译器都会主动调用构造和析构函数，这便是智能指针诞生的原因 智能指针便是简化了上述操作，在对象创建后由智能指针来接管，就算不手动释放内存，智能指针也会自动调用析构帮你释放，不得不说C++真是太强大了! 话不多说，我们一起来看看智能指针的实际操作： 实战代码： //智能指针-unique_ptr独占指针 #include &lt;iostream&gt; #include &lt;string&gt; //想用智能指针必须包含这个头文件 #include &lt;memory&gt; using namespace std; class Cat { public: //默认构造 Cat() = default; //有参构造函数 Cat(string name) { this-&gt;m_Name = name; } //析构函数 ~Cat() { cout &lt;&lt; \"Destructor of Cat: \" &lt;&lt; m_Name &lt;&lt; endl; } //成员函数 默认不可修改 void cat_info() const { cout &lt;&lt; \"cat info name: \" &lt;&lt; m_Name &lt;&lt; endl; } string get_name() const { return m_Name; } //将内部的m_Name修改 void set_cat_name(const string &amp;name) { this-&gt;m_Name = name; } private: //创建一个变量给予默认值 string m_Name{\"Mimi\"}; }; int main() { //调用有参构造和成员函数 Cat c1(\"ok\"); c1.cat_info(); //下面是局部作用域,在结束前会自动调用析构 { Cat c1(\"ok\"); c1.cat_info(); } //在堆区开辟内存并调用有参构造 Cat *c_p1 = new Cat(\"yy\"); c_p1-&gt;cat_info(); { Cat *c_p1 = new Cat(\"yy_scope\"); c_p1-&gt;cat_info(); //手动释放 delete c_p1; } //手动释放 delete c_p1; //手动释放非常的不安全,所以需要智能指针 //智能指针会自动的释放内存,不需要手动释放 // unique_ptr的第一种用法: //向堆区申请内存 Cat *c_p2 = new Cat(\"yz\"); //创建一个智能指针指向那个指向堆区内存的指针 unique_ptr&lt;Cat&gt; u_c_p2{c_p2}; c_p2-&gt;cat_info(); u_c_p2-&gt;cat_info(); //当指针内部的变量修改后 c_p2-&gt;set_cat_name(\"ok\"); //智能指针也会修改 u_c_p2-&gt;cat_info(); delete c_p2; c_p2 = nullptr; //当堆区的内存释放后就无法再通过智能指针调用了 // u_c_p2-&gt;cat_info(); //第二种用法: //在堆区创建时就用智能指针指向那个指向堆区内存的指针 unique_ptr&lt;Cat&gt; u_c_p3{new Cat(\"dd\")}; u_c_p3-&gt;cat_info(); u_c_p3-&gt;set_cat_name(\"oo\"); u_c_p3-&gt;cat_info(); //第三种用法 利用make_unique默认创建,调用默认构造函数 unique_ptr&lt;Cat&gt; u_c_p4 = make_unique&lt;Cat&gt;(); u_c_p4-&gt;cat_info(); u_c_p4-&gt;set_cat_name(\"oo\"); u_c_p4-&gt;cat_info(); // get和常量类型 unique_ptr&lt;int&gt; u_i_1{new int(100)}; //通过get就可以打印int的地址 cout &lt;&lt; \"int address: \" &lt;&lt; u_i_1.get() &lt;&lt; endl; cout &lt;&lt; \"cat address: \" &lt;&lt; u_c_p3.get() &lt;&lt; endl; //解引用 cout &lt;&lt; *u_i_1 &lt;&lt; endl; unique_ptr&lt;int&gt; u_i_p2 = make_unique&lt;int&gt;(200); cout &lt;&lt; *u_i_p2 &lt;&lt; endl; cout &lt;&lt; u_i_p2.get() &lt;&lt; endl; return 0; }","categories":[{"name":"C++","slug":"C","permalink":"https://yswm-m.github.io/categories/C/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"学习","slug":"学习","permalink":"https://yswm-m.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"笔记","slug":"笔记","permalink":"https://yswm-m.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"C++11(auto自动识别变量类型)","slug":"36-C++11(auto自动识别变量类型)","date":"2022-09-28T02:26:00.000Z","updated":"2022-09-28T09:50:17.311Z","comments":true,"path":"posts/36.html","link":"","permalink":"https://yswm-m.github.io/posts/36.html","excerpt":"","text":"更多教程笔记请查看我的上一篇文章：点击跳转 C++11自学之旅开始！ 本次将介绍C++11里对比赛比较有用的：auto关键字 auto关键字可以自动的识别一个变量的类型并赋给另一个变量，类似于js中的var，auto的出现让代码中一些单词比较长的容器迭代器变成较短的变量，极大的提升了比赛中选手敲代码的速度，毕竟有些时候手速也能决定比赛的关键胜负。 auto的基本使用代码: // auto的用法,自动识别变量类型,创建一个识别后的变量 #include &lt;bits/stdc++.h&gt; using namespace std; int main() { vector&lt;int&gt; arr{1, 2, 3, 4, 5, 6, 0}; for (vector&lt;int&gt;::iterator i = arr.begin(); i != arr.end(); ++i) { cout &lt;&lt; *i &lt;&lt; \" \"; } cout &lt;&lt; endl; //上面等价于 for (auto j = arr.begin(); j != arr.end(); ++j) { cout &lt;&lt; *j &lt;&lt; \" \"; } cout &lt;&lt; endl; // auto在for循环中的用法 string s = \"ABCD ,Work \"; string s2; //创建一个自动变量c,遍历s里面每一个字符 for (auto c : s) { //如果c不等于标点符号与空格则插入另一个字符串 if (!ispunct(c) &amp;&amp; c != ' ') { s2.push_back(c); } } cout &lt;&lt; s2 &lt;&lt; endl; // int类型 auto a = 1; //自动判断括号内的数据类型并赋值给b decltype(a) b = a; return 0; }","categories":[{"name":"C++","slug":"C","permalink":"https://yswm-m.github.io/categories/C/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"学习","slug":"学习","permalink":"https://yswm-m.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"笔记","slug":"笔记","permalink":"https://yswm-m.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"ACM 2022级招新线上预选赛","slug":"28-ACM 2022级招新线上预选赛","date":"2022-09-28T02:11:00.000Z","updated":"2022-09-28T00:36:44.955Z","comments":true,"path":"posts/28.html","link":"","permalink":"https://yswm-m.github.io/posts/28.html","excerpt":"","text":"赛后总结 我感觉这次比赛比较难的就第D题和第E题，一个是简化版背包，一个是贪心，其他的都比较简单，用来招新生的话感觉正好，我估计真的去他们学校比的话也就能全对个四题左右吧，其他全是暴力骗分。 我9点半才看到题目，他们应该都比完了，我花了半个小时就全部做出来了，可惜我不是这学校的 55555 题目描述: 解题思路 没啥好说的,基本上全是暴力，遇到字符'A'就加1，遇到字符'B'就减1，然后用一个变量记录最大的值。 代码 //问题A #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int main() { int x = 0; int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; int num = 0; int maxnum = 0; for (int i = 0; i &lt; n; ++i) { if (s[i] == 'A') { x++; } if (s[i] == 'B') { x--; } num = x; if (num &gt; maxnum) { maxnum = num; } } cout &lt;&lt; maxnum &lt;&lt; endl; return 0; } 题目描述: 解题思路 这题我感觉数据范围过大了，我用的动态规划应该只能过一半的样例，可能需要用到滚动数组或者矩阵快速幂优化，不过能暴力骗分就行，毕竟半小时做的。 代码 //问题B #include &lt;iostream&gt; using namespace std; const long N = 1e8 + 7; typedef long long LL; LL q[N]; int main() { LL n; scanf(\"%lld\", &amp;n); q[0] = 2; q[1] = 1; for (int i = 2; i &lt;= n; ++i) { q[i] = q[i - 1] + q[i - 2]; } printf(\"%lld\", q[n]); return 0; } 题目描述: 解题思路 这道题我听说他们后面把数据范围加强了，我一开始看题面还以为是那种求总方案的个数或者求花最少的钱的方案之类的dfs的题，后面我又想毕竟是新生赛不可能那么难，于是试着暴力居然过了，看来真是暴力出奇迹。 代码 //问题C #include &lt;iostream&gt; using namespace std; int main() { long n; cin &gt;&gt; n; int x = 4, y = 7; long a = 0, b = 0; while (1) { if (a == n || b == n || a + b == n) { cout &lt;&lt; \"Yes\" &lt;&lt; endl; break; } else { a = a + x; b = b + y; if (a &gt; n &amp;&amp; b &gt; n &amp;&amp; a + b &gt; n) { cout &lt;&lt; \"No\" &lt;&lt; endl; break; } } } return 0; } 题目描述: 解题思路 这道题的输入输出样例我真的是不能再熟悉了，就是01背包的样例改过来的，我看了下题目果然是背包问题简化版，想不到新生赛居然出这种题，要是那种没看过背包问题的岂不是直接没了，不过还是被我用哈希表给暴力出来了。 代码 //问题D #include &lt;iostream&gt; using namespace std; const int N = 31; int v[N], w[N]; int n, m, t, count; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; t; for (int j = 0; j &lt; t; ++j) { cin &gt;&gt; v[j]; w[v[j]]++; } } for (int i = 0; i &lt; m; ++i) { if (w[i] == n) { count++; } } cout &lt;&lt; count &lt;&lt; endl; return 0; } 题目描述: 解题思路 这道题是很明显的贪心问题，难点就在于如何模拟他的选择，如果只选最大的分数就有可能变成10的倍数，如果只选不可能变成10的倍数的分数就可能无法使最后的总得分最大，所以既要最后的总得分不能是10的倍数，又要分数尽可能的大。 我的思路是先把全部的分数加起来，再利用排序从最小的分数开始减，减一次判断一次减之后是不是10的倍数，如果减之后不是那么就减，如果减之后依然是那么就不减，继续判断下一个数，将损失降到最小。 代码 //问题E #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 101; int q[N], sum, maxnum; int n; int main() { int t; cin &gt;&gt; t; while (t--) { cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; q[i]; sum += q[i]; } if (sum % 10 == 0) { sort(q, q + n); for (int i = 0; i &lt; n; ++i) { if (sum - q[i] % 10 != 0) { sum -= q[i]; break; } } } if (sum % 10 == 0) { sum = 0; } cout &lt;&lt; sum &lt;&lt; endl; sum = 0; } return 0; } 题目描述: 解题思路 这道题没啥好说的，看图都能看出来，四条从下往上的线可以构成3个空格，三条从右往左的线可以构成2个空格，把它们两个的空格数乘起来就可以得到答案。 代码 //问题F #include &lt;iostream&gt; using namespace std; int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; (n - 1) * (m - 1) &lt;&lt; endl; return 0; } 题目描述: 解题思路 这道题主要考的就是字符转数字的技巧，看过我以前的高精度博客就知道，减去字符'0'就可以将一个数字字符转成可以参与运算的整形数字，然后乘10来进位，绝对值用abs()函数来求，最后用一个变量将所得的差值最小的数存储起来。 代码 //问题G #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; using namespace std; int main() { string s; cin &gt;&gt; s; int x = 0; int sum = 0; int minnum = INT_MAX, k; for (int i = 0; i &lt; s.size() - 2; ++i) { k = i; for (int j = 0; j &lt; 3; ++j) { x += (s[k] - '0'); if (j != 2) { x *= 10; } k++; } sum = abs(x - 753); if (sum &lt; minnum) { minnum = sum; } x = 0; } cout &lt;&lt; minnum &lt;&lt; endl; return 0; }","categories":[{"name":"刷题","slug":"刷题","permalink":"https://yswm-m.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"练习","slug":"练习","permalink":"https://yswm-m.github.io/tags/%E7%BB%83%E4%B9%A0/"},{"name":"比赛","slug":"比赛","permalink":"https://yswm-m.github.io/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"十大排序算法总结","slug":"27-十大排序算法总结","date":"2022-09-27T07:11:00.000Z","updated":"2022-09-28T07:18:41.634Z","comments":true,"path":"posts/27.html","link":"","permalink":"https://yswm-m.github.io/posts/27.html","excerpt":"","text":"学习思路 排序是算法里面经常会考的题目，也是面试题里面会出的经典问题，虽然各种语言本身就内置了sort()排序函数，但是掌握其它的排序算法可以让我们在处理数据上显得游刃有余，同时一些排序算法里面的思想也与数据结构里面的算法思想不谋而合，所以排序算法是每个合格的程序员都必须掌握的。 排序算法练习题目 排序算法的分类： 冒泡选择插入希尔归并快速堆堆2.0计数桶基数1、冒泡排序: #include &lt;iostream&gt; using namespace std; const int N = 1e8 + 10; int a[N], n; void bubble_sort() { for (int i = n - 1; i &gt;= 1; i--) { bool flag = true; for (int j = 1; j &lt;= i; j++) { if (a[j - 1] &gt; a[j]) { swap(a[j - 1], a[j]); //交换两个数 flag = false; } } if (flag) { return; } } } int main() { scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) { scanf(\"%d\", &amp;a[i]); //接收输入的数据 } bubble_sort(); //调用函数排序 for (int i = 0; i &lt; n; ++i) { printf(\"%d \", a[i]); //输出 } return 0; }2、选择排序: #include &lt;iostream&gt; using namespace std; const int N = 1e8 + 10; int a[N], n; void select_sort() { for (int i = 0; i &lt; n; i++) { int k = i; for (int j = i + 1; j &lt; n; j++) { if (a[j] &lt; a[k]) { k = j; } } swap(a[i], a[k]); //交换两个数 } } int main() { scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) { scanf(\"%d\", &amp;a[i]); //接收输入的数据 } select_sort(); //调用函数排序 for (int i = 0; i &lt; n; ++i) { printf(\"%d \", a[i]); //输出 } return 0; }3、插入排序: #include &lt;iostream&gt; using namespace std; const int N = 1e8 + 10; int a[N], n; void insert_sort() { for (int i = 1; i &lt; n; i++) { int x = a[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; x &lt; a[j]) { a[j + 1] = a[j]; j--; } a[j + 1] = x; } } int main() { scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) { scanf(\"%d\", &amp;a[i]); //接收输入的数据 } insert_sort(); //调用函数排序 for (int i = 0; i &lt; n; ++i) { printf(\"%d \", a[i]); //输出 } return 0; }4、希尔排序: #include &lt;iostream&gt; using namespace std; const int N = 1e8 + 10; int a[N], n; void shell_sort() { for (int gap = n &gt;&gt; 1; gap; gap &gt;&gt;= 1) { for (int i = gap; i &lt; n; i++) { int x = a[i]; int j; for (j = i; j &gt;= gap &amp;&amp; a[j - gap] &gt; x; j -= gap) { a[j] = a[j - gap]; } a[j] = x; } } } int main() { scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) { scanf(\"%d\", &amp;a[i]); //接收输入的数据 } shell_sort(); //调用函数排序 for (int i = 0; i &lt; n; ++i) { printf(\"%d \", a[i]); //输出 } return 0; }5、归并排序: #include &lt;iostream&gt; using namespace std; const int N = 1e8 + 10; int a[N], n; int temp[N]; //开辟一个临时数组将原数组比较完的数储存 void merge_sort(int l, int r) { if (l &gt;= r) { return; //区间内只有一个数，返回 } int mid = l + r &gt;&gt; 1; //相当于(l + r) / 2 merge_sort(l, mid); //递归左半部分 merge_sort(mid + 1, r); //递归右半部分 int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) //合并 { if (a[i] &lt; a[j]) { temp[k++] = a[i++]; } else { temp[k++] = a[j++]; } } while (i &lt;= mid) { temp[k++] = a[i++]; } while (j &lt;= r) { temp[k++] = a[j++]; } for (int i = l, j = 0; i &lt;= r; i++, j++) { a[i] = temp[j]; //将排序好的数转移回原数组 } } int main() { scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) { scanf(\"%d\", &amp;a[i]); //接收输入的数据 } merge_sort(0, n - 1); //调用函数排序 for (int i = 0; i &lt; n; ++i) { printf(\"%d \", a[i]); //输出 } return 0; }6、快速排序（最快）: #include &lt;iostream&gt; using namespace std; const int N = 1e8 + 10; int a[N], n; void quick_sort(int l, int r) { if (l &gt;= r) { return; } int x = a[l + r &gt;&gt; 1], i = l - 1, j = r + 1; while (i &lt; j) { do { ++i; } while (a[i] &lt; x); do { --j; } while (a[j] &gt; x); if (i &lt; j) { swap(a[i], a[j]); //交换两个数 } } quick_sort(l, j); //递归左半部分 quick_sort(j + 1, r); //递归右半部分 } int main() { scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) { scanf(\"%d\", &amp;a[i]); //接收输入的数据 } quick_sort(0, n - 1); //调用函数排序 for (int i = 0; i &lt; n; ++i) { printf(\"%d \", a[i]); //输出 } return 0; }7、堆排序（须知此排序使用了模拟堆，为了使最后一个非叶子节点的编号为n/2，数组编号从1开始）: #include &lt;iostream&gt; using namespace std; const int N = 1e8 + 10; int h[N], n; void down(int u) { int t = u; // t记录最小值 if (u &lt;&lt; 1 &lt;= n &amp;&amp; h[u &lt;&lt; 1] &lt; h[t]) { t = u &lt;&lt; 1; // 左儿子 } if ((u &lt;&lt; 1 | 1) &lt;= n &amp;&amp; h[u &lt;&lt; 1 | 1] &lt; h[t]) { t = u &lt;&lt; 1 | 1; // 右儿子 } if (u != t) //需要调整 { swap(h[u], h[t]); //交换两个数 down(t); //递归 } } int main() { scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;h[i]); //接收输入的数据 } for (int i = n / 2; i; i--) { down(i); //初始化堆 } while (true) { if (!n) { break; } printf(\"%d \", h[1]); //输出 h[1] = h[n]; n--; down(1); } return 0; }堆排序2.0（利用C++内置STL函数优先队列实现）: //感慨万千：STL太好用了！ #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; const int MAXN = 1e8 + 10; int n; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; //小根堆 int main() { scanf(\"%d\", &amp;n); int x; for (int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;x); //接收输入的数据 q.push(x); //入队 } while (!q.empty()) //判断队列是否为空 { printf(\"%d \", q.top()); //输出队顶的最小值 q.pop(); //出队 } return 0; }8、计数排序: #include &lt;iostream&gt; using namespace std; const int N = 1e8 + 10; long long n, cnt[N]; int main() { scanf(\"%lld\", &amp;n); int x = 0, Max = -0x3f3f3f, Min = 0x3f3f3f; //初始化最大值和最小值 for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;x); cnt[x]++; //统计 Max = max(Max, x); Min = min(Min, x); //更新最大值和最小值 } for (int i = Min; i &lt;= Max; i++) { while (cnt[i]) { cnt[i]--; printf(\"%d \", i); //输出 } } return 0; }9、桶排序: #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; const int N = 1e8 + 10; int n, Min = N, Max = 0, sum[N]; bool f[45]; vector&lt;int&gt; bucket[45]; //定义桶，这里定义40个桶 void insertsort(int s) { for (int i = 0; i &lt; bucket[s].size(); i++) { for (int j = i; j &gt;= 1; j--) { if (bucket[s][j - 1] &gt; bucket[s][j]) { swap(bucket[s][j], bucket[s][j - 1]); //这里是从小到大排序 } } } for (int i = 0; i &lt; bucket[s].size(); i++) { printf(\"%d \", bucket[s][i]); //由于每个桶都是有序的，所以可以输出这个桶，节省了一次遍历的时间 } } void bucketsort() { for (int i = 1; i &lt;= n; i++) { bucket[int((sum[i] - Min) / ((Max - Min + 1) / 40.0))].push_back(sum[i]); f[int((sum[i] - Min) / ((Max - Min + 1) / 40.0))] = 1; //运用最大最小值来合理分配桶 } for (int i = 0; i &lt;= 40; i++) { if (f[i]) { insertsort(i); //如果当前桶有数值，则对桶内的数进行排序（这里用选择排序） } } } int main() { scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;sum[i]); Min = min(Min, sum[i]); Max = max(Max, sum[i]); //为了能够合理利用空间，确保第一个桶和最后一个桶都有数，所以存储最大最小值 } bucketsort(); return 0; }10、基数排序（基数排序是桶排序的特例，优势是可以处理浮点数和负数，劣势是还要配合别的排序函数）: #include &lt;iostream&gt; using namespace std; const int N = 1e8 + 10; int a[N], count[N], temp[N], n; int maxbit() { int maxv = a[0]; // maxv保存最大的位数 for (int i = 1; i &lt; n; i++) { if (maxv &lt; a[i]) { maxv = a[i]; } } int cnt = 1; while (maxv &gt;= 10) { maxv /= 10; cnt++; } return cnt; } void radixsort() //基数排序 { int t = maxbit(); int radix = 1; for (int i = 1; i &lt;= t; i++) //进行t次排序 { for (int j = 0; j &lt; 10; j++) { count[j] = 0; //清空计数器 } for (int j = 0; j &lt; n; j++) { int k = (a[j] / radix) % 10; count[k]++; } for (int j = 1; j &lt; 10; j++) { count[j] += count[j - 1]; } for (int j = n - 1; j &gt;= 0; j--) { int k = (a[j] / radix) % 10; temp[count[k] - 1] = a[j]; count[k]--; } for (int j = 0; j &lt; n; j++) { a[j] = temp[j]; } radix *= 10; } } int main() { scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) { scanf(\"%d\", &amp;a[i]); //接收输入的数据 } radixsort(); //调用函数排序 for (int i = 0; i &lt; n; ++i) { printf(\"%d \", a[i]); //输出 } return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://yswm-m.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"练习","slug":"练习","permalink":"https://yswm-m.github.io/tags/%E7%BB%83%E4%B9%A0/"},{"name":"排序","slug":"排序","permalink":"https://yswm-m.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"高精度模板(加减乘除)","slug":"26-高精度模板(加减乘除)","date":"2022-09-26T07:11:00.000Z","updated":"2022-09-28T07:41:47.189Z","comments":true,"path":"posts/26.html","link":"","permalink":"https://yswm-m.github.io/posts/26.html","excerpt":"","text":"学习思路 高精度是算法里面不常考的题目，但是掌握高精度也更有利于我们学习算法和解决实际开发中所遇到的问题，我们知道int的数据范围是-2^31~2^31-1，而long long 的数据范围是-2^63~2^63-1，那么当一个数超过了long long 的范围，想要计算它的结果就变得十分困难，为此我们转变思路，可以利用字符串数组存储那个数，再通过字符串数组个位转整型数字的方式进行人类熟悉的四则运算，最后再将得到的结果用另一个字符串数组存储起来，字符串数组的范围是无限的，根据计算机的内存进行扩充，计算机的内存有多大就可以存储多大的字符串，这便是高精度算法的思想。 加法减法乘法除法高精度加法模板：（高精+高精） 原题链接 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;algorithm&gt; using namespace std; string addfun(string a, string b) { string c; int t = 0; for (int i = a.size() - 1, j = b.size() - 1; i &gt;= 0 || j &gt;= 0 || t &gt; 0; --i, --j) { if (i &gt;= 0) { t += (a[i] - '0'); //通过减去字符 '0' 可以将一个数字字符转变成可以参与运算的整型数字 } if (j &gt;= 0) { t += (b[j] - '0'); } c += ((t % 10) + '0'); //通过加上字符 '0' 可以将参与运算后的整型数字重新转变回数字字符，存放进字符串数组中 t /= 10; } reverse(c.begin(), c.end()); //因为是从字符串末位一个一个往前倒着运算的，所以最后得到的结果要进行翻转 return c; } int main() { //使C++输入输出流变快 ios::sync_with_stdio(false); string a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; addfun(a, b) &lt;&lt; endl; return 0; }高精度减法模板：（高精-高精） 原题链接 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; bool cmp(string a, string b) { if (a.size() != b.size()) { return a.size() &gt; b.size(); } for (int i = 0; i &lt; a.size(); ++i) { if (a[i] != b[i]) { return a[i] &gt; b[i]; } } return true; } string subfun(string a, string b) { string c; int t = 0; for (int i = a.size() - 1, j = b.size() - 1; i &gt;= 0 || j &gt;= 0 || t &gt; 0; --i, --j) { if (i &gt;= 0) { t = (a[i] - '0') - t; //通过减去字符 '0' 可以将一个数字字符转变成可以参与运算的整型数字 } if (j &gt;= 0) { t -= (b[j] - '0'); } c += ((t + 10) % 10 + '0'); //通过加上字符 '0' 可以将参与运算后的整型数字重新转变回数字字符，存放进字符串数组中 if (t &lt; 0) { t = 1; } else { t = 0; } } while (c.size() &gt; 1 &amp;&amp; c.back() == '0') //去掉字符串末尾的0 { c.pop_back(); } reverse(c.begin(), c.end()); //因为是从字符串末位一个一个往前倒着运算的，所以最后得到的结果要进行翻转 return c; } int main() { //使C++输入输出流变快 ios::sync_with_stdio(false); string a, b; cin &gt;&gt; a &gt;&gt; b; if (cmp(a, b)) //判断有没有可能第一个数比第二个数小，减成负数的情况 { cout &lt;&lt; subfun(a, b) &lt;&lt; endl; } else { cout &lt;&lt; \"-\" &lt;&lt; subfun(b, a) &lt;&lt; endl; //如果会减成负数那么就要在前面加上负号 } return 0; }高精度乘法模板：（高精*低精） 原题链接 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; string mulfun(string a,int b) { string c; int t=0; for(int i=a.size()-1;i&gt;=0||t&gt;0;--i) { if(i&gt;=0) { t+=(a[i]-'0')*b; //通过减去字符 '0' 可以将一个数字字符转变成可以参与运算的整型数字 } c+=((t%10)+'0'); //通过加上字符 '0' 可以将参与运算后的整型数字重新转变回数字字符，存放进字符串数组中 t/=10; } reverse(c.begin(),c.end()); //因为是从字符串末位一个一个往前倒着运算的，所以最后得到的结果要进行翻转 return c; } int main() { //使C++输入输出流变快 ios::sync_with_stdio(false); string a; int b; cin&gt;&gt;a&gt;&gt;b; if(a==\"0\"||b==0) //因为0乘任何数都得0，所以两个数只要有一个是0就不用参与后面的运算了 { cout&lt;&lt;0&lt;&lt;endl; } else { cout&lt;&lt;mulfun(a,b)&lt;&lt;endl; } return 0; }高精度除法模板：（高精/低精） 原题链接 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; string divfun(string a,int b,int &amp;r) { string c; for(int i=0;i&lt;a.size();++i) { r=r*10+(a[i]-'0'); //通过减去字符 '0' 可以将一个数字字符转变成可以参与运算的整型数字 c+=((r/b)+'0'); //通过加上字符 '0' 可以将参与运算后的整型数字重新转变回数字字符，存放进字符串数组中 r%=b; } while(c.size()&gt;1&amp;&amp;c.front()=='0') //去掉字符串首位的0 { c = c.substr(1); } return c; } int main() { //使C++输入输出流变快 ios::sync_with_stdio(false); string a; int b; cin&gt;&gt;a&gt;&gt;b; int r = 0; cout&lt;&lt;divfun(a,b,r)&lt;&lt;endl; cout&lt;&lt;r&lt;&lt;endl; return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://yswm-m.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"练习","slug":"练习","permalink":"https://yswm-m.github.io/tags/%E7%BB%83%E4%B9%A0/"},{"name":"高精度","slug":"高精度","permalink":"https://yswm-m.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}]},{"title":"数据结构再战—约瑟夫环(循环链表)","slug":"25-数据结构再战—约瑟夫环(循环链表)","date":"2022-09-25T07:11:00.000Z","updated":"2022-10-17T01:31:17.217Z","comments":true,"path":"posts/25.html","link":"","permalink":"https://yswm-m.github.io/posts/25.html","excerpt":"","text":"学习思路 约瑟夫环是一个很经典的题目，有多种实现方法，为了练习链表我决定用三种方法实现：循环链表、数组标志位、数组模拟链表。 原题链接: AcWing 题目描述： N 个人围成一圈顺序编号，从 1 号开始按 1、2、3 顺序报数，报 m 者退出圈外，其余的人再从 1、2、3 开始报数，报 m 的人再退出圈外，依次类推。 请输出最后那个剩下的人的编号。 输入格式 输入一行包含 2 个整数 n，m。 注意：程序有多组输入数据，当输入为0时退出 输出格式 对于每组输入数据，输出对应的答案（每组数据中最后剩余的人的编号）用换行隔开 数据范围 所有测试点满足 1 ≤ n ≤ 300，m ≤ n。 输入样例： 300 9 10 3 11 5 0 0 输出样例： 34 4 8 循环链表数组标志位数组模拟链表循环链表实现代码: #include &lt;iostream&gt; using namespace std; typedef struct node { int data; struct node *next; } NODE, *Link; int main() { int n, m; // n为人数，m为报数，每当报数到m就退出1人 int i; int answer[100]; // answer保存每次的答案,最后统一输出 int count = 0; // count用来控制答案数组的下标 Link head, tail, p, q; //创建头节点 head = new NODE; head-&gt;data = -1; head-&gt;next = nullptr; //通过循环保存多组输入数据 while (1) { scanf(\"%d %d\", &amp;n, &amp;m); //如果n(人数)为0或者m(报数)为0则直接结束循环 if (n == 0 || m == 0) { //释放头节点 delete head; break; } else { //让另一个指针指向头节点 tail = head; for (i = 0; i &lt; n; ++i) { //按照人数构建链表 p = new NODE; p-&gt;data = i + 1; //保存每个人数的序号,从1开始 tail-&gt;next = p; //插到头节点的尾部 p-&gt;next = head-&gt;next; //最后一个节点的next指向第一个节点，这样就构成了一个循环链表 tail = p; //另一个指针移动到新增的最后一个节点，为下一次插入做准备 } //当循环链表构建完了之后 p = head-&gt;next; // p指针指向第一个链表节点 q = tail; // q指针指向尾节点 //报数,从1开始 i = 1; // p和q是一个首,一个尾,永远是一前一后的关系,一旦他们相遇,则说明只剩一个节点了 while (p != q) { //当 i 报数到 m if (i == m) { //把当前节点从链表中删除 //这里的意思是,q永远在p的前一个节点，q-&gt;next-&gt;next表示的是p的下一个节点,而p指向的就是要删除的当前节点 //当q-&gt;next = q-&gt;next-&gt;next时,就把p的前一个节点和p指向的当前的节点的链接断掉了,重新去指向了p的后一个节点 //这样p所在的这个节点就被链表这个队伍抛弃了 q-&gt;next = q-&gt;next-&gt;next; //然后就可以直接释放p所在的这个节点的内存 delete p; //将p移动到下一个有效节点上,q-&gt;next这时指向的是p被释放的节点的下一个有效节点 p = q-&gt;next; // i = 1重新开始报数 i = 1; } else { // q指向p所在的节点,而p一开始指向的是第一个有效节点 q = p; //然后p往后移动一位,这样q和p就构成了一前一后的关系,一直往后移动 p = p-&gt;next; //报数器加1，一直报数到m就删除p所指向的节点 i++; } } //维持链表的完整性，就是说当循环退出时链表中除了头节点被删的只剩下一个节点了，这个节点由p和q指针共同指着，这时头节点原本指向的第一个有效节点已经被删除，头节点和链表之间联系已经被断开 //如果还要对这个剩下的最后一个节点做其他操作那么可以用头节点重新链接这个最后的节点，如果题目没有要求可以不加这一句，只需要在程序最后把那最后一个节点删除就行了 // head-&gt;next = q; //将最后一个剩余的人的序号保存起来，它就是我们要的答案 answer[count] = p-&gt;data; //答案数组的计数器加一，进行新一轮的循环 count++; //删除最后一个节点 delete p; head-&gt;next = nullptr; //链表这时已为空，只剩下头节点了，可以将头节点的next置为空，这是一个好习惯 } } //按照题目要求输出最后的答案 for (int i = 0; i &lt; count; ++i) { cout &lt;&lt; answer[i] &lt;&lt; endl; } return 0; }数组标志位实现代码: #include &lt;iostream&gt; using namespace std; int main() { int n, m; // n为人数，m为报数 int number; //记录剩余的人数 int count = 1; // count代表当前的报数 int i, pos; while (cin &gt;&gt; n &gt;&gt; m) { //如果人数为0或者报数为0则直接终止程序 if (n == 0 || m == 0) { return 0; } number = n; // monkey数组存储人的编号和状态 int monkey[301] = {0}; //存储-1代表无效的数组部分，0代表退出的人，1至n+1代表还没退出的人序号 for (i = 0; i &lt; n; ++i) { monkey[i] = i + 1; } // pos控制当前处理的数组下标,指向数组的开始位置 pos = 0; while (number &gt; 1) { if (monkey[pos] &gt; 0) { if (count != m) { //报数+1 count++; //当前处理的数组下标+1 pos = (pos + 1) % n; } else { monkey[pos] = 0; //标记为0,设置当前人出局 count = 1; //报数重新开始 number--; //人数-1 pos = (pos + 1) % n; //当前处理的数组下标+1 } } else { //这条语句的妙处在于:当n的人数为10 时，pos为9,那么pos+1就变成了10,而10%10求余之后就变成了0,这样就构成了一个循环的情况 //永远在0~9之间循环,当超过9就重新变为0 pos = (pos + 1) % n; //当前处理的数组下标+1 } } //输出最后的结果 for (i = 0; i &lt; n; ++i) { //此时数组中退出的人的编号都变成了0,只有唯一的那个剩下的人的编号不是0,所以只要找到最后那个不是0的输出就行了 if (monkey[i] &gt; 0) { cout &lt;&lt; monkey[i] &lt;&lt; endl; } } } return 0; }数组模拟链表实现代码: #include &lt;iostream&gt; using namespace std; int main() { int n, m; // n为人数,m为报数 int number; //记录剩余的人数 int count; // count代表当前的报数 int i, pos, prior; // pos指向数组首位,prior指向数组末尾 while (cin &gt;&gt; n &gt;&gt; m) { //如果人数为0或者报数为0,则终止程序 if (n == 0 || m == 0) { return 0; } //数组存储下一个人的位置，标识为-1的代表退出的人 int monkey[301] = {0}; //初始化数组,数组存储下一个人的下标 for (i = 0; i &lt; n - 1; ++i) { monkey[i] = i + 1; } //下标为n-1的元素的下个序号为0，形成循环链表 monkey[i] = 0; // monkey[i+1] = -2; //将超过范围的元素标识为-2,方便跟踪的时候看数组内存 number = n; pos = 0; prior = n - 1; count = 1; while (number &gt; 1) //设置循环退出条件,也可以设置为:prior!=pos，prior永远指向pos的前一个节点 { //如果没有报数到m if (count != m) { prior = pos; // prior保存pos的上一个节点的下标,也就是prior指针指向pos所在的下标 // pos移动到下一个有效节点的下标,也就是pos指针指向下一个节点的下标，因为数组中存储的值刚好是下一个数组元素的下标 //所以monkey[pos]里面存储的就是pos要指向的下一个节点的下标 pos = monkey[pos]; //报数加1 count++; } else //当报数到了m { /*这里非常难理解，经过我一段时间的梳理，发现实际上就是：prior的下标在数组中对应的值是pos的下标,而pos的下标在数组中对应的值是pos的下一个数组元素的下标 当monkey[prior] = monkey[pos]之后，也就是把pos的下标在数组中对应的值(也就是pos的下一个数组元素的下标)赋给monkey[prior]，原本monkey[prior]里面存储的是 pos所在的数组元素的下标，现在就变成了pos的下一个数组元素的下标，这样monkey[prior]与pos所在的数组元素之间的联系就断开了 */ //更改链接关系 monkey[prior] = monkey[pos]; //出局的人,标识为-1,也就是将pos所在的数组元素标记为删除 monkey[pos] = -1; // pos移动到下一个有效节点,因为经过上面的赋值之后,monkey[prior]里面的值已经变成了原先pos所在数组元素的下一个数组元素的下标 //所以pos重新移动到了prior的下一个有效(不为-1)的数组元素 pos = monkey[prior]; //人的个数减一 number--; //重新开始报数 count = 1; } } //当循环结束后就只剩下最后那个没有被赋值为-1的人被pos和prior共同指着,那个人就是我们要的答案 //输出最后一个有效的人,因为pos对应的最后那个人的数组元素的值是比pos下标多1的，所以最后要加1 cout &lt;&lt; pos + 1 &lt;&lt; endl; } return 0; }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://yswm-m.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"练习","slug":"练习","permalink":"https://yswm-m.github.io/tags/%E7%BB%83%E4%B9%A0/"},{"name":"再战","slug":"再战","permalink":"https://yswm-m.github.io/tags/%E5%86%8D%E6%88%98/"}]},{"title":"数据结构再战—学生管理系统(链表)","slug":"24-数据结构再战—学生管理系统(链表)","date":"2022-09-24T06:46:00.000Z","updated":"2022-09-27T02:23:17.289Z","comments":true,"path":"posts/24.html","link":"","permalink":"https://yswm-m.github.io/posts/24.html","excerpt":"","text":"学习思路 为了彻底掌握链表，我决定写一个用链表实现的学生管理系统，其中有链表的增删改查和显示菜单界面，当把这些链表常用的操作都练熟了之后再去对应的做一些题，就可以彻底掌握链表 代码: #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; #define NO_Value 20 #define NAME_Value 11 typedef struct Student { char studentNo[NO_Value]; char studentName[NAME_Value]; } st; typedef struct node { struct Student data; struct node *next; } Node, *Link; void myMenu() //菜单界面 { cout &lt;&lt; \"============================ 欢迎来到学生管理系统 ============================\" &lt;&lt; endl; cout &lt;&lt; \"\\t\\t ----------------------------------------\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 1.增加学生记录 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 2.删除学生记录 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 3.查找学生记录 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 4.修改学生记录 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 5.统计学生人数 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 6.显示学生记录 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 7.退出系统 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t ----------------------------------------\\n\"; cout &lt;&lt; \"请输入您的选择: \"; } void inputStudent(Link p) //每当要增加学生时便调用这个函数接收用户的输入 { cout &lt;&lt; \"请输入学生的学号: \"; cin &gt;&gt; p-&gt;data.studentNo; cout &lt;&lt; \"请输入学生的姓名: \"; cin &gt;&gt; p-&gt;data.studentName; p-&gt;next = nullptr; } void inputStudentNo(char s[], char no[]) //每当要执行删除,修改和查询时便调用这个函数,接收用户输入的学号 { cout &lt;&lt; \"请输入要\" &lt;&lt; s &lt;&lt; \"的学生学号：\"; cin &gt;&gt; no; } bool addNode(Link head) //增加学生 { Link p, q; Link node; node = new Node; inputStudent(node); //调用这个函数接收用户输入要增加的学生的学号和姓名 q = head; p = head-&gt;next; if (head-&gt;next == nullptr) { head-&gt;next = node; } else { while (nullptr != p) { if (node-&gt;data.studentNo &lt; p-&gt;data.studentNo) { q-&gt;next = node; node-&gt;next = p; return true; } else { q = p; p = p-&gt;next; } } q-&gt;next = node; } return true; } bool deleteNode(Link head) //删除学生 { char no[NO_Value]; inputStudentNo(\"删除\", no); //调用这个函数接收用户输入要删除的学生的学号 Link q = head; Link p = head-&gt;next; if (head == NULL || head-&gt;next == NULL) { return false; } while (p) { if (strcmp(p-&gt;data.studentNo, no) == 0) { q-&gt;next = p-&gt;next; free(p); cout &lt;&lt; \"删除成功!\" &lt;&lt; endl; return true; } else { q = p; p = p-&gt;next; } } return false; } bool queryNode(Link head) //查找学生,通过学号查找 { char no[NO_Value]; inputStudentNo(\"查找\", no); //调用这个函数接收用户输入要查找的学生的学号 Link p = head-&gt;next; if (head == NULL || head-&gt;next == NULL) { return false; } while (p) { if (strcmp(p-&gt;data.studentNo, no) == 0) { cout &lt;&lt; \"查找到学号 \" &lt;&lt; p-&gt;data.studentNo &lt;&lt; \" 学生的姓名为：\" &lt;&lt; p-&gt;data.studentName &lt;&lt; endl; return true; } else { p = p-&gt;next; } } return false; } bool modifyNode(Link head) //修改学生 { char no[NO_Value]; inputStudentNo(\"修改\", no); //调用这个函数接收用户输入要修改的学生的学号 Link p = head-&gt;next; if (head == NULL || head-&gt;next == NULL) { return false; } while (p) { if (strcmp(p-&gt;data.studentNo, no) == 0) { cout &lt;&lt; \"请输入你要修改\" &lt;&lt; p-&gt;data.studentNo &lt;&lt; \"学生的姓名: \"; cin &gt;&gt; p-&gt;data.studentName; cout &lt;&lt; \"修改成功!\" &lt;&lt; endl; cout &lt;&lt; \"修改后学号 \" &lt;&lt; p-&gt;data.studentNo &lt;&lt; \" 学生的姓名为: \" &lt;&lt; p-&gt;data.studentName &lt;&lt; endl; return true; } else { p = p-&gt;next; } } return false; } int countNode(Link head) //统计学生人数 { Link p; int count = 0; p = head-&gt;next; while (p) { count++; p = p-&gt;next; } return count; } void displayNode(Link head) //显示系统现有的所有学生，也就是遍历整个链表输出链表所存储的数据，要注意如果为空就不进行遍历 { Link p = head-&gt;next; if (!p) { cout &lt;&lt; \"学生管理系统为空!\" &lt;&lt; endl; } else { while (p) { cout &lt;&lt; \"学生学号：\" &lt;&lt; p-&gt;data.studentNo &lt;&lt; \"\\t\"; cout &lt;&lt; \"学生姓名：\" &lt;&lt; p-&gt;data.studentName &lt;&lt; endl; p = p-&gt;next; } } } void clearLink(Link head) //释放整个链表的空间 { Link q, p; q = head; p = head-&gt;next; while (p) { q-&gt;next = p-&gt;next; free(p); p = q-&gt;next; } free(q); } int main() { int select; int count; Link head; head = new Node; head-&gt;next = nullptr; while (1) { //菜单页面 myMenu(); scanf(\"%d\", &amp;select); //接收用户的选择 switch (select) { case 1: //增加学生 if (addNode(head)) { cout &lt;&lt; \"插入成功!\" &lt;&lt; endl; } system(\"pause\"); system(\"cls\"); break; case 2: //删除学生 if (!deleteNode(head)) { cout &lt;&lt; \"删除失败,没有要删除的学生信息!\" &lt;&lt; endl; } system(\"pause\"); system(\"cls\"); break; case 3: //查找学生 if (!queryNode(head)) { cout &lt;&lt; \"查询失败,没有要查询的学生信息!\" &lt;&lt; endl; } system(\"pause\"); system(\"cls\"); break; case 4: //修改学生 if (!modifyNode(head)) { cout &lt;&lt; \"修改失败,没有要修改的学生信息!\" &lt;&lt; endl; } system(\"pause\"); system(\"cls\"); break; case 5: //统计学生人数 count = countNode(head); cout &lt;&lt; \"学生人数为: \" &lt;&lt; count &lt;&lt; endl; system(\"pause\"); system(\"cls\"); break; case 6: //显示现有学生 displayNode(head); system(\"pause\"); system(\"cls\"); break; case 7: //释放所有链表空间，终止程序 clearLink(head); return 0; default: cout &lt;&lt; \"输入不正确,应该输入1到7之间的数字\" &lt;&lt; endl; system(\"pause\"); system(\"cls\"); break; } } system(\"pause\"); return 0; }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://yswm-m.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"练习","slug":"练习","permalink":"https://yswm-m.github.io/tags/%E7%BB%83%E4%B9%A0/"},{"name":"再战","slug":"再战","permalink":"https://yswm-m.github.io/tags/%E5%86%8D%E6%88%98/"}]},{"title":"数据结构再战—单链表","slug":"23-数据结构再战—单链表","date":"2022-09-23T01:45:00.000Z","updated":"2022-09-27T02:23:09.406Z","comments":true,"path":"posts/23.html","link":"","permalink":"https://yswm-m.github.io/posts/23.html","excerpt":"","text":"学习思路 所谓单链表实际上就是通过指针将多个不同不连续的节点链接起来，每个节点都存储着不同的值，很多人在学习的过程中容易搞混指针和节点之间的关系，实际上只要记住一点：没有被分配空间的指针就不能算是节点， 指针可以改变节点的指向，也可以改变节点的值，也可以通过循环在多个节点之间游走，但是它没有被 new 分配空间，那么就永远不是节点 给指针分配空间： 这是一个结构体指针 struct node *head; 给指针分配空间 head = new struct node; 创建另一个结构体指针 struct node *p; 另一个指针指向head所维护的那块内存 p = head; 当指针被分配空间后它就成为了一个节点，可以通过head-&gt;data = 1 的方式给节点赋值，也可以创建另一个指针指向这个节点，当另一个指针指向这个节点并不是指向这个head指针本身，而是指向head指针所分配的那块空间， 也可以理解为共同指向head指针所指向的节点 指针向后移动，p-&gt;next 代表当前节点所保存的下一个节点的地址，p = p-&gt;next 代表指针p移动到下一个节点 p = p-&gt;next; 代码: #include &lt;iostream&gt; using namespace std; typedef struct Node { int data; // struct Node *prior; //加入这条语句即可把单链表变成双链表 struct Node *next; } * Link, Node; Link createNode(int a[], int n) //头插法,最后得到的链表的数据顺序与数组是相反的 { Link head = new Node; head-&gt;next = NULL; for (int i = 0; i &lt; n; ++i) { Link node = new Node; //每次都是在head的后面新增一个节点,而不是在新增节点的后面,所以最后得到的链表顺序与数组是相反的 node-&gt;data = a[i]; // node节点的指针域指向head的指针域,而head的指针域为NULL,也就是node的指针域指向NULL node-&gt;next = head-&gt;next; //最后当node的指针域指向NULL后,将head的指针域与NULL的链接断开,指向新的节点,这样既完成了头部插入 head-&gt;next = node; } return head; } Link newList(int a[], int n) //尾插法,最后得到的链表顺序与数组一致 { //创建头节点 Link head = new Node; head-&gt;next = NULL; //创建一个新的指针指向头节点 Link rear = head; for (int i = 0; i &lt; n; ++i) { Link node = new Node; node-&gt;data = a[i]; // node-&gt;next = NULL; //如果没有写这条语句,那么就要在最后面补上rear-&gt;next = NULL; //将新的指针的指针域指向新的节点,而新的指针原本指向的是head头节点,也就是让head头节点的指针域指向新的节点 rear-&gt;next = node; //最后让新的指针指向新的节点,这样就完成了插入 rear = node; } //如果插入到最后没有数据了,将新的指针的指针域指向NULL,而新的指针这时指向的一定是最后一个新的节点,也就是让最后一个新的节点的指针域指向NULL rear-&gt;next = NULL; // rear-&gt;next = head; //将上面的语句替换为这条语句即可将链表变成循环链表,对应的要将循环判断条件变成：p!=head,p-&gt;next!=head return head; } bool insertNode(Link head, int i, int x) //插入节点 { Link p = head; int j = 0; while (p != NULL &amp;&amp; j &lt; i - 1) { p = p-&gt;next; j++; } if (p == NULL) { return false; } //创建一个新的节点 Link node = new Node; node-&gt;data = x; //让新节点的指针域指向p的指针域,而p的指针域保存的是后一个节点的地址,也就是等于让新节点的指针域指向后一个节点 node-&gt;next = p-&gt;next; //然后当新节点的指针域指向后一个节点后,让p的指针域和后一个节点的链接断开,指向新节点,这样既完成了插入 p-&gt;next = node; return true; } bool deleteNode(Link head, int x) //删除节点 { //如果传入的是一个空表,或者只有一个头节点,就直接返回false if (head == NULL || head-&gt;next == NULL) { return false; } //创建两个指针p和q,p指向的是头节点的下一个节点,q指向的是头节点,q永远指向p的前一个节点,p永远指向q的下一个节点 Link p = head-&gt;next, q = head; //如果p不为空就一直往下查找 while (NULL != p) { //如果p的数据域等于x就代表找到了 if (p-&gt;data == x) { //将q的指针域指向p的指针域,而p的指针域指向的是下一个节点,也就是将q的指针域指向p的下一个节点,这样的话p的前一个节点与p指向的节点的链接就断掉了 q-&gt;next = p-&gt;next; //然后释放p所指向的节点 delete p; //这样便成功删除了一个节点 return true; } else { //如果没有查找到,则q指向p所在的节点,而p所在的节点是q原本指向的节点的下一个节点,这样便实现了q一直随着p往后移动 q = p; // p重新指向下一个节点 p = p-&gt;next; } } //如果都没有找到则说明链表中没有x这个节点,返回false return false; } void printNode(Link head) //打印链表 { Link p = head-&gt;next; while (NULL != p) { cout &lt;&lt; p-&gt;data &lt;&lt; \" \"; p = p-&gt;next; } puts(\"\"); } void clearLink(Link head) //释放链表 { //如果head不为空,也就是head指向的不是最后一个节点的后一个节点 while (NULL != head) { //新建一个节点q指向head所在的节点 Link q = head; // head往后移动一位 head = head-&gt;next; //删除q指向的节点,而q指向的节点是原本head指向的节点,也就是删除head原本指向的节点 delete q; } } int main() { int n; int a[101]; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) { scanf(\"%d\", &amp;a[i]); } // Link p = createNode(a, n); //头插法 Link p = newList(a, n); insertNode(p, 2, 10); deleteNode(p, 10); printNode(p); clearLink(p); printNode(p); return 0; }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://yswm-m.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"练习","slug":"练习","permalink":"https://yswm-m.github.io/tags/%E7%BB%83%E4%B9%A0/"},{"name":"再战","slug":"再战","permalink":"https://yswm-m.github.io/tags/%E5%86%8D%E6%88%98/"}]},{"title":"货仓选址 (每日一题)","slug":"22-货仓选址 (每日一题)","date":"2022-09-22T01:30:00.000Z","updated":"2022-10-17T01:30:34.563Z","comments":true,"path":"posts/22.html","link":"","permalink":"https://yswm-m.github.io/posts/22.html","excerpt":"","text":"原题链接: AcWing 题目描述: 在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN。 现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。 为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。 输入格式 第一行输入整数 N。 第二行 N 个整数 A1∼AN。 输出格式 输出一个整数，表示距离之和的最小值。 数据范围 1 ≤ N ≤ 100000, 0 ≤ Ai ≤ 40000 输入样例： 4 6 2 9 1 输出样例： 12 解题思路: 这道题是一个贪心问题，需要用到数学里的绝对值不等式，其实拆开来看就是一个求排序后数组中位数的差的题，因为要想距离这些商店都短，那么必然要在他们的距离之间寻求一个中位数，中位数有非常优秀的性质，比如说在这道题目中，每一个点到中位数的距离，都是满足全局的最有性，而不是局部最优性。 代码: #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5 + 1; int q[N], res, n; int main() { scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) { scanf(\"%d\", &amp;q[i]); } sort(q, q + n); //排序 for (int i = 0; i &lt; n; ++i) { res += abs(q[i] - q[n / 2]); //统计和中位数之间的差 } printf(\"%d\", res); return 0; }","categories":[{"name":"刷题","slug":"刷题","permalink":"https://yswm-m.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"练习","slug":"练习","permalink":"https://yswm-m.github.io/tags/%E7%BB%83%E4%B9%A0/"},{"name":"每日一题","slug":"每日一题","permalink":"https://yswm-m.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"招聘 (每日一题)","slug":"21-招聘 (每日一题)","date":"2022-09-21T03:26:00.000Z","updated":"2022-10-17T01:28:07.137Z","comments":true,"path":"posts/21.html","link":"","permalink":"https://yswm-m.github.io/posts/21.html","excerpt":"","text":"原题链接: AcWing 题目描述: 某公司招聘，有 n 个人入围，HR在黑板上依次写下 m 个正整数 A1,A2,…Am，然后这 n 个人围成一个圈，并按照顺时针顺序为他们编号 0,1,2,…n−1。 录取规则是： 第一轮从 0 号的人开始，取用黑板上的第 1 个数字，也就是 A1。 黑板上的数字按次序循环使用，即如果某轮用了第 k 个，如果 k &lt; m，则下一轮需要用第 k+1 个；如果 k=m，则下一轮用第 1 个。 每一轮按照黑板上的次序取用到一个数字 Ax，淘汰掉从当前轮到的人开始按照顺时针顺序数到的第 Ax 个人。 下一轮开始时轮到的人即为被淘汰掉的人的顺时针顺序下一个人，被淘汰的人直接回家，所以不会被后续轮次计数时数到。 经过 n−1 轮后，剩下的最后 1 人被录取，所以最后被录取的人的编号与 (n,m,A1,A2,…Am) 相关。 输入格式 输入包含多组测试数据。 第一行包含整数 T，表示共有 T 组测试数据。 接下来 T 行，每行包含若干个整数，依次存放 n,m,A1,A2,…Am，表示一组数据。 输出格式 输出共 T 行，每行对应相应的那组数据确定的录取之人的编号。 数据范围 0 &lt; T &lt; 10, 0 &lt; m, Ax &lt; 10^3, 0 &lt; n &lt; 10^7 输入样例： 1 4 2 3 1 输出样例： 1 样例解释 样例里只有 1 组测试数据，说的是有 4 人入围（编号 0∼3）。 黑板上依次写下 2 个数字：3、1，那么： 第一轮：当前轮到 0 号，数到数字 3，顺时针数第 3 个人是 2 号，所以淘汰 2 号，下一轮从 3 号开始，目前剩余：0、1、3； 第二轮：当前数到 3 号，取到数字 1，顺时针数第 1 个人是 3 号，所以淘汰 3 号，下一轮从 0 号开始，目前剩余：0、1； 第三轮：当前轮到 0 号，循环取到数字 3，顺时针数第 3 个人是 0 号，所以淘汰 0 号，最后只剩下 1 号，所以录取 1 号，输出 1； 解题思路: 这道题是一个典型的约瑟夫环问题，不同的就是把报数从3变成了另一个循环的数组，虽然可以依靠循环链表直接模拟出来，但是由于数据范围过大，用链表模拟会超时，因为链表的 new 操作是非常慢的，所以只能依靠数组， 但是我在尝试了用数组模拟循环链表后依旧超时，这时就只有依靠数学方法了，看来数学是一个永远绕不过去的坑，只有接受它才能让我继续前进。 循环链表模拟代码:（超时，通过6/10个数据） #include &lt;iostream&gt; using namespace std; const int N=1e3+1; int answer[N]; typedef struct node { int data; struct node *next; }*PQ,st; int main() { int n,m,t,i,pos = 0,count = 0; cin&gt;&gt;t; PQ head,tail,p,q; head = new st; head-&gt;data = -1; head-&gt;next = nullptr; while(t--) { cin&gt;&gt;n&gt;&gt;m; tail = head; for(i = 0;i&lt;n;++i) { p = new st; p-&gt;data = i; tail-&gt;next = p; p-&gt;next = head-&gt;next; tail = p; } for(i = 0;i&lt;m;++i) { cin&gt;&gt;answer[i]; } p = head-&gt;next; q = tail; i = 1; count = answer[pos]; while(p!=q) { if(i==count) { q-&gt;next = p-&gt;next; delete p; p = q-&gt;next; i = 1; pos = (pos+1)%m; count = answer[pos]; } else { q = p; p = p-&gt;next; i++; } } cout&lt;&lt;p-&gt;data&lt;&lt;endl; delete p; head-&gt;next = nullptr; pos = 0; count = 0; } delete head; return 0; } 数学方法是几种约瑟夫环解法里面最简短的，同时也是最难理解的，我本人也是理解不了，不过也许若干年后再回来看时就能够理解了 数学方法实现代码： #include &lt;iostream&gt; using namespace std; const int N = 1e3 + 10; int a[N]; /* 约瑟夫环递推公式： f(1) = 0; //表示最后一轮的胜出者当前编号是0 f(x) = (f(x - 1) + m) % x , 1 &lt; x &lt;= n //每一轮都找到胜出者在上一轮中的编号 不过本题里m是在变化的，所以要相应地变为： ==&gt; f(x) = (f(x - 1) + a[(n - x) % m]) % x, 1 &lt; x &lt;= n */ int main() { int T; cin &gt;&gt; T; while(T --){ int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; ++ i) scanf(\"%d\", &amp;a[i]); int ret = 0; for(int i = 2; i &lt;= n; ++ i){ ret = (ret + a[(n - i) % m]) % i; } cout &lt;&lt; ret &lt;&lt; endl; } return 0; }","categories":[{"name":"刷题","slug":"刷题","permalink":"https://yswm-m.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"练习","slug":"练习","permalink":"https://yswm-m.github.io/tags/%E7%BB%83%E4%B9%A0/"},{"name":"每日一题","slug":"每日一题","permalink":"https://yswm-m.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"击中战舰 (每日一题)","slug":"20-击中战舰 (每日一题)","date":"2022-09-20T02:26:00.000Z","updated":"2022-10-17T01:27:53.959Z","comments":true,"path":"posts/20.html","link":"","permalink":"https://yswm-m.github.io/posts/20.html","excerpt":"","text":"原题链接: AcWing 题目描述: 李华在玩一款叫做《海战》的小游戏，下面是游戏介绍。 给定一个 1×n 的方格矩阵，方格从左到右依次编号为 1∼n。 在这个方格矩阵中，隐藏着 a 个战舰。 每个战舰都占据 b 个连续的方格，每个方格最多只能被一个战舰占据。 每个战舰的具体位置未知。 玩家的任务就是在这种情况下，向一些方格发动精确打击，如果受到精确打击的方格被某个战舰占据着，则视为击中该战舰。 李华已经向 k 个方格发动了精确打击，不幸的是，一个战舰都没有击中。 请你计算，他至少还需要向多少个方格发动精确打击，才能确保自己可以至少击中一个战舰。 请给出一个具体方案。 输入格式 第一行包含 4 个整数 n,a,b,k。 第二行包含一个长度为 n 的 01 字符串，如果第 i 个字符为 1，则表示第 i 个方格已经受到了精确打击，如果第 i 个字符为 0，则表示第 i 个方格还未受到精确打击。保证字符 1 恰好出现 k 次。 输出格式 第一行输出李华还需要发动精确打击的最少方格数量。 第二行输出李华还需要发动精确打击的方格的具体编号，具体输出顺序随意。 如果方案不唯一，输出任意合理方案均可。 数据范围 前 3 个测试点满足 1 ≤ n ≤ 13。 所有测试点满足 1 ≤ n ≤ 2×10^5，1 ≤ a, b ≤ n，0 ≤ k ≤ n−1。 输入样例1： 5 1 2 1 00100 输出样例1： 2 4 2 输入样例2： 13 3 2 3 1000000010001 输出样例2： 2 7 11 解题思路: 这道题是一个模拟题，理解了题意之后发现：只需要遍历把所有能加的战舰就加到数组里，结束时战舰数量−a+1−a+1就是答案，也就是说先把那个所有连续的0算一下，计算可以存放多少个战舰，因为是至少，所以我们假设我们的运气最差，前p.size()-a都没有战舰，那么p.size()-a+1肯定会有战舰。 代码: #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; int main() { int n, a, b, k; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; k; string s; cin &gt;&gt; s; int cnt = 0; vector&lt;int&gt; p; for (int i = 0;i &lt; s.size();i++) { if (s[i] == '0') { cnt++; if (cnt == b) { cnt = 0; p.push_back(i + 1);//之所以加1是因为下标是从0开始 } } else { cnt = 0; } } cout &lt;&lt; p.size() - a + 1&lt;&lt;endl; for (int i = 0;i &lt; p.size() - a + 1;i++) { cout &lt;&lt; p[i]&lt;&lt;\" \"; } }","categories":[{"name":"刷题","slug":"刷题","permalink":"https://yswm-m.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"练习","slug":"练习","permalink":"https://yswm-m.github.io/tags/%E7%BB%83%E4%B9%A0/"},{"name":"每日一题","slug":"每日一题","permalink":"https://yswm-m.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"相遇问题 (每日一题)","slug":"19-相遇问题 (每日一题)","date":"2022-09-19T02:26:00.000Z","updated":"2022-10-17T01:26:44.225Z","comments":true,"path":"posts/19.html","link":"","permalink":"https://yswm-m.github.io/posts/19.html","excerpt":"","text":"原题链接: AcWing 题目描述: 在一个一维数轴的 x 位置处站着甲，y 位置处站着乙，其中 x","categories":[{"name":"刷题","slug":"刷题","permalink":"https://yswm-m.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"练习","slug":"练习","permalink":"https://yswm-m.github.io/tags/%E7%BB%83%E4%B9%A0/"},{"name":"每日一题","slug":"每日一题","permalink":"https://yswm-m.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"回文日期 (每日一题)","slug":"18-回文日期 (每日一题)","date":"2022-09-18T04:14:00.000Z","updated":"2022-10-17T01:26:20.681Z","comments":true,"path":"posts/18.html","link":"","permalink":"https://yswm-m.github.io/posts/18.html","excerpt":"","text":"原题链接: AcWing 题目描述: 在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。 牛牛习惯用 8 位数字表示一个日期，其中，前 4 位代表年份，接下来 2 位代表月份，最后 2 位代表日期。 显然：一个日期只有一种表示方法，而两个不同的日期的表示方法不会相同。 牛牛认为，一个日期是回文的，当且仅当表示这个日期的 8 位数字是回文的。 现在，牛牛想知道：在他指定的两个日期之间（包含这两个日期本身），有多少个真实存在的日期是回文的。 一个 8 位数字是回文的，当且仅当对于所有的 i(1≤i≤8) 从左向右数的第 i 个数字和第 9−i 个数字（即从右向左数的第 i 个数字）是相同的。 例如： 对于 2016 年 11 月 19 日，用 8 位数字 20161119 表示，它不是回文的。 对于 2010 年 1 月 2 日，用 8 位数字 20100102 表示，它是回文的。 对于 2010 年 10 月 2 日，用 8 位数字 20101002 表示，它不是回文的。 输入格式 输入包括两行，每行包括一个 8 位数字。 第一行表示牛牛指定的起始日期 date1，第二行表示牛牛指定的终止日期 date2。保证 date1 和 date2 都是真实存在的日期，且年份部分一定为 4 位数字，且首位数字不为 0。 保证 date1 一定不晚于 date2。 输出格式 输出共一行，包含一个整数，表示在 date1 和 date2 之间，有多少个日期是回文的。 数据范围 1≤N≤10^4 输入样例： 20110101 20111231 输出样例： 1 解题思路: 这道题是一个大模拟题，题目比较长，需要看得比较久，当看懂了题目后会发现其实就是一个给定两个任意日期求之间的时间是否是回文的题，那么就要考虑年月日的情况，有平年闰年，大月小月， 我们可以用一个全局数组将可能用到的日期存放起来，然后通过求余的方法求出当前日期的所在年月日，然后判断是否是平年闰年，最后按照要求判断是否是回文日期 代码: #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int months[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; bool check(int date) { int year = date / 10000; int month = date % 10000 / 100; int day = date % 100; if (!month || month &gt;= 13 || !day) return false; if (month != 2 &amp;&amp; day &gt; months[month]) return false; if (month == 2) { bool leap = year % 4 == 0 &amp;&amp; year % 100 || year % 400 == 0; if (day &gt; 28 + leap) return false; } return true; } int main() { int date1, date2; cin &gt;&gt; date1 &gt;&gt; date2; int res = 0; for (int i = 0; i &lt; 10000; i ++ ) { int x = i, r = i; for (int j = 0; j &lt; 4; j ++ ) r = r * 10 + x % 10, x /= 10; if (r &gt;= date1 &amp;&amp; r &lt;= date2 &amp;&amp; check(r)) res ++ ; } printf(\"%d\\n\", res); return 0; }","categories":[{"name":"刷题","slug":"刷题","permalink":"https://yswm-m.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"练习","slug":"练习","permalink":"https://yswm-m.github.io/tags/%E7%BB%83%E4%B9%A0/"},{"name":"每日一题","slug":"每日一题","permalink":"https://yswm-m.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"性感素数 (每日一题)","slug":"17-性感素数 (每日一题)","date":"2022-09-17T01:45:00.000Z","updated":"2022-10-17T01:25:46.109Z","comments":true,"path":"posts/17.html","link":"","permalink":"https://yswm-m.github.io/posts/17.html","excerpt":"","text":"原题链接: AcWing 题目描述: “性感素数 ”是指形如 (p,p+6) 这样的一对素数。 之所以叫这个名字，是因为拉丁语管“六”叫“sex”（即英语的“性感”）。 现给定一个整数，请你判断其是否为一个性感素数。 输入格式 输入在一行中给出一个正整数 N。 输出格式 若 N 是一个性感素数，则在一行中输出 Yes，并在第二行输出与 N 配对的另一个性感素数（若这样的数不唯一，输出较小的那个）。 若 N 不是性感素数，则在一行中输出 No，然后在第二行输出大于 N 的最小性感素数。 数据范围 1≤N≤10^8 输入样例1： 47 输出样例1： Yes 41 输入样例2： 21 输出样例2： No 23 解题思路: 这道题是一个素数筛题，因为数据范围不大不小，所以用普通的暴力肯定会超时，那么我们可以利用素数的特性，判断一个数是不是素数，只需要判断n的根号前几个数即可。因为素数的特性是除了1和它本身之外不能被其它任何数整除， 如果一个数不是素数是合数，那么一定可以由两个自然数相乘得到，其中一个大于或等于它的平方根，一个小于或等于它的平方根。并且成对出现，所以只用计算到该数的平方根以下看除了1有没有该数的因数，若没有，则是素数。 代码: #include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; int fun(int n) { if(n&lt;=1) { return 0; } for(int i=2;i&lt;=n/i;i++) //这里for循环的终止条件利用了试除法，也可以改为i&lt;=sqrt(n);直接求根号 { if(n%i==0) { return 0; } } return 1; } int main() { int n; scanf(\"%d\",&amp;n); if(fun(n)&amp;&amp;(fun(n-6)||fun(n+6))) { printf(\"Yes\\n\"); if(fun(n-6)) { printf(\"%d\",n-6); }else{ printf(\"%d\",n+6); } }else{ printf(\"No\\n\"); int i=n+1; while(1) { if(fun(i)&amp;&amp;(fun(i+6)||fun(i-6))) { printf(\"%d\",i); break; } i++; } } return 0; } 除了上面的方法外，素数判断还有其他更快的方法： 这里引入一个经典的题目： 原题链接 题目描述: 给定一个正整数 n，请你求出 1∼n 中素数的个数。 数据范围 1≤n≤10^6 普通筛法埃氏筛法线性筛法普通筛法：O(nlogn) #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e6+1; int q[N],ans,n; bool st[N]; void fun() { for(int i=2;i&lt;=n;i++) { if(!st[i]) { q[ans++]=i;//把素数存起来 for(int j=i;j&lt;=n;j+=i) //不管是合数还是质数，都用来筛掉后面它的倍数 { st[j]=true; //可以用质数就把所有的合数都筛掉； } } } } int main() { ios::sync_with_stdio(false); cin&gt;&gt;n; fun(); cout&lt;&lt;ans&lt;&lt;endl; return 0; }埃氏筛法：O(nloglogn) void get_primes1(){ for(int i=2;i&lt;=n;i++){ if(!st[i]){ primes[cnt++]=i; for(int j=i;j&lt;=n;j+=i) st[j]=true;//可以用质数就把所有的合数都筛掉； } } }线性筛法： O(n) void get_primes(){ //外层从2~n迭代，因为这毕竟算的是1~n中质数的个数，而不是某个数是不是质数的判定 for(int i=2;i&lt;=n;i++){ if(!st[i]) primes[cnt++]=i; for(int j=0;primes[j]&lt;=n/i;j++){//primes[j]&lt;=n/i:变形一下得到——primes[j]*i&lt;=n,把大于n的合数都筛了就 //没啥意义了 st[primes[j]*i]=true;//用最小质因子去筛合数 //1)当i%primes[j]!=0时,说明此时遍历到的primes[j]不是i的质因子，那么只可能是此时的primes[j]&lt;i的 //最小质因子,所以primes[j]*i的最小质因子就是primes[j]; //2)当有i%primes[j]==0时,说明i的最小质因子是primes[j],因此primes[j]*i的最小质因子也就应该是 //prime[j]，之后接着用st[primes[j+1]*i]=true去筛合数时，就不是用最小质因子去更新了,因为i有最小 //质因子primes[j]&lt;primes[j+1],此时的primes[j+1]不是primes[j+1]*i的最小质因子，此时就应该 //退出循环，避免之后重复进行筛选。 if(i%primes[j]==0) break; } } }","categories":[{"name":"刷题","slug":"刷题","permalink":"https://yswm-m.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"练习","slug":"练习","permalink":"https://yswm-m.github.io/tags/%E7%BB%83%E4%B9%A0/"},{"name":"每日一题","slug":"每日一题","permalink":"https://yswm-m.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"方格跳跃 (每日一题)","slug":"16-方格跳跃 (每日一题)","date":"2022-09-16T01:12:00.000Z","updated":"2022-10-17T01:25:26.744Z","comments":true,"path":"posts/16.html","link":"","permalink":"https://yswm-m.github.io/posts/16.html","excerpt":"","text":"原题链接: AcWing 题目描述: 小朋友们在玩跳方格游戏。 n 个方格排成一排，从左到右依次编号为 1∼n。 每个方格中都标有一个方向箭头，箭头分为两种：“&gt;” 和 “&lt;”。 “&gt;” 表示进入方格的小朋友需要向右跳动一格距离，“&lt;” 表示进入方格的小朋友需要向左跳动一格距离。 初始时，小朋友需要选择任意一个方格作为自己的初始位置，并从初始位置开始，按照每个方格的指示跳跃方向进行连续跳跃。 如果小朋友可以跳到界外，则视为赢得游戏胜利。 请你计算，为了赢得游戏胜利，共有多少个方格可以作为初始位置。 例如，当 n=4 且每个方格中的箭头方向依次为 &lt;&lt;&gt;&lt; 时，选择第 1 个或第 2 个方格作为初始位置，均可以跳到（左侧）界外，而选择第 3 个或第 4 个方格作为初始位置，则会陷入无限反复横跳，无法跳出界外，所以共有 2 个方格可以作为初始位置。 输入格式 第一行包含整数 n。 第二行包含一个长度为 n 的由 &lt; 和 &gt; 构成的字符串，其中第 i 个字符表示第 i 个方格中的方向箭头。 输出格式 一个整数，表示可以作为初始位置的方格数量。 数据范围 前 3 个测试点满足 1≤n≤10。 所有测试点满足 1≤n≤2×10^5。 输入样例1： 4 &lt;&lt;&gt;&lt; 输出样例1： 2 输入样例2： 5 &gt;&gt;&gt;&gt;&gt; 输出样例2： 5 输入样例3： 4 &gt;&gt;&lt;&lt; 输出样例3： 0 解题思路: 这道题实际上是一个思维题，一开始我还以为是什么大模拟之类的，后面发现其实就是从左边出的必须一直向左，右边出同理必须一直向右，否则就会陷入死循环，那么就只需要把从左边出的和从右边出的加起来就好了。 代码: #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int main() { int n; cin&gt;&gt;n; string s; cin&gt;&gt;s; int ans = 0; for(int i=0;i&lt;n&amp;&amp;s[i]=='&lt;';++i) { ans++; } for(int i = n-1;i&gt;=0&amp;&amp;s[i]=='&gt;';--i) { ans++; } cout&lt;&lt;ans&lt;&lt;endl; return 0; }","categories":[{"name":"刷题","slug":"刷题","permalink":"https://yswm-m.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"练习","slug":"练习","permalink":"https://yswm-m.github.io/tags/%E7%BB%83%E4%B9%A0/"},{"name":"每日一题","slug":"每日一题","permalink":"https://yswm-m.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"去掉0 (每日一题)","slug":"15-去掉0 (每日一题)","date":"2022-09-16T00:18:00.000Z","updated":"2022-10-17T01:24:53.712Z","comments":true,"path":"posts/15.html","link":"","permalink":"https://yswm-m.github.io/posts/15.html","excerpt":"","text":"原题链接: AcWing 题目描述: 给定一个字符串 s，其中的每个字符要么是 1，要么是 0。 我们希望字符串中的所有 1 能够形成一个连续的子串，例如，字符串 0、1、00111、01111100 均满足此条件，而字符串 0101、100001、11111111111101 均不满足此条件。 你可以从字符串中删除一些（也可以不删）0，使得字符串满足上述条件。 请问，你必须删除的最小 0 数量是多少。 输入格式 第一行包含整数 T，表示共有 T 组测试数据。 每组数据占一行，包含一个 01 字符串 s。 输出格式 每组数据输出一行结果，一个整数，表示必须删除的最小 0 数量。 数据范围 前 3 个测试点满足 1≤T≤10， 所有测试点满足 1≤T≤100，1≤|s|≤100。 输入样例： 3 010011 0 1111000 输出样例： 2 0 0 解题思路: 这道题咋一看像是那种求最长连续或不连续子串的类型的题，还以为可能会用到双指针算法，现在看来其实题目已经给了可以直接暴力求解的办法，既然说了可以不删除 0，那么实际上只要求出字符串中从左往右开始遇到第一个 1 之后到最后一个 1 之间的 0 的个数就行了，省略掉前面和末尾的 0，只用一个变量来对 1 之间的所有的 0 计数，最后得到的就是答案。 代码: #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int main() { int t; cin&gt;&gt;t; while(t--) { string s; cin&gt;&gt;s; int n = 0,m = 0; for(int i=0;s[i];++i) { if(s[i]=='0'&amp;&amp;m) { n++; } if(s[i]=='1') { m = 1; } } for(int i=s.size()-1;s[i]=='0'&amp;&amp;n;--i) { n--; } cout&lt;&lt;n&lt;&lt;endl; } return 0; }","categories":[{"name":"刷题","slug":"刷题","permalink":"https://yswm-m.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"练习","slug":"练习","permalink":"https://yswm-m.github.io/tags/%E7%BB%83%E4%B9%A0/"},{"name":"每日一题","slug":"每日一题","permalink":"https://yswm-m.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"单片机教程","slug":"14-单片机","date":"2022-09-15T02:58:00.000Z","updated":"2022-09-30T08:46:25.828Z","comments":true,"path":"posts/14.html","link":"","permalink":"https://yswm-m.github.io/posts/14.html","excerpt":"","text":"嵌入式自学之旅开始！ 视频链接 本教程用的单片机是C51的单片机，用的代码编写软件是keil，想要更进一步的可以直接买STM32的单片机 前置知识（常用的变量位数）： #include &lt;REGX52.H&gt; unsigned int //16位(单片机)，一般计算机上的int都是32位，前面的unsigned代表无符号，无符号int的范围是0~65535 short //16位 -32768~32767 long //32位 -2147483648~2147483647 unsigned long int //32位 0~4294967295 float //32位 3.4e-38~3.4e38 double //64位 1.7e-308~1.7e308 char //8位 -128~127 unsigned char //8位 0~255 实战代码: //要驱动52的开发板必须要引入这个头文件 #include &lt;REGX52.H&gt; //用_nop_()函数需要用到这个头文件 #include &lt;INTRINS.H&gt; int main() { //0亮 1不亮 //让第一个LED亮起 P2 = 0xFE; //1111 1110 //延时500毫秒,也就是半秒 Delaylms(1000); //让第二个亮起 P2 = 0xFD; //1111 1101 //延时 Delaylms(1000); //让第三个亮起 P2 = 0xFB; //1111 1011 //延时 Delaylms(N); //让第四个亮起 P2 = 0xF7; //1111 0111 //延时 Delaylms(N); //让第五个亮起 P2 = 0xEF; //1110 1111 //延时 Delaylms(N); //让第六个亮起 P2 = 0xDF; //1101 1111 //延时 Delaylms(N); //让第七个亮起 P2 = 0xBF; //1011 1111 //延时 Delaylms(N); //让第八个亮起 P2 = 0x7F; //0111 1111 //延时 Delaylms(N); return 0; } keil配置 新建项目为:Microchip下的AT89C52 STC-lSP配置 单片机型号选择:STC89C52RC/LE52RC 串口号选择:USB-SERTAL CH340(COM5) 打开程序文件，下载/编程到单片机 寄存器通过检测高低电平检测按键是否被按下","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://yswm-m.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"笔记","slug":"笔记","permalink":"https://yswm-m.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Mongodb教程","slug":"13-Mongodb","date":"2022-09-15T02:55:00.000Z","updated":"2022-09-30T08:30:08.526Z","comments":true,"path":"posts/13.html","link":"","permalink":"https://yswm-m.github.io/posts/13.html","excerpt":"","text":"安装mongodb数据库 启动数据库：在cmd窗口下输入mongo 查看数据库：show dbs 进入数据库：use test 创建数据库：首先先进入数据库：use test 然后向表中插入数据：db.user.insert({\"username\":\"zhangsan\",\"age\":20}) 查看当前数据库下的表：show collections 查看表里面的内容：db.user.find() 删除数据库：首先先进入数据库：use test 然后输入:db.dropDatabase() 删除一个表：db.test02.drop() 其中test02是表名 查找指定数据：db.user.find({\"age\":\"13\"}) 查找年龄为13的人的数据,db.user.find({\"username\":\"zhangsan\"}) 查找名字叫zhangsan的人的数据 查找表里面年龄大于22的数据：db.user.find({\"age\":{$gt:\"22\"}}) 查找表里面年龄小于22的数据：db.user.find({\"age\":{$lt:\"22\"}}) 查找表里面年龄大于等于22的数据：db.user.find({\"age\":{$gte:\"22\"}}) 查找表里面年龄小于等于22的数据：db.user.find({\"age\":{$lte:\"22\"}}) 查找表里面年龄大于等于23且小于等于26的数据：db.user.find({\"age\":{$gte:\"23\",$lte:\"26\"}}) 模糊查询：db.user.find({\"username\":/zhang/}) 查找表里面名字叫zhangsan的人 模糊查询：db.user.find({\"username\":/z/}) 查找表里面名字包含z的人 模糊查询：db.user.find({\"username\":/^z/}) 查找表里面名字以z为开头的人 模糊查询：db.user.find({\"username\":/n$/}) 查找表里面名字以n为结尾的人 查询指定列年龄大于20的name的数据：db.user.find({\"age\":{$gt:\"20\"}},{name:1}) 查询指定列年龄大于20的age的数据：db.user.find({\"age\":{$gt:\"20\"}},{age:1}) 查询指定列 name age数据,age&gt;25 db.user.find({age:{$gt:\"25\"}},{name:1,age:1}) 按照年龄升序排序：db.user.find().sort({age:1}) 按照年龄降序排序：db.user.find().sort({age:-1}) 查找的时候可以写多个条件：db.user.find({username:'zhangsan',age:\"22\"}) 名字既要是zhangsan,年龄也要是22 查询前5条数据：db.user.find().limit(5) 查询10条以后的数据：db.user.find().skip(10) 查询第3和第4条数据：db.user.find().skip(2).limit(2) 查询2条以后的数据中的前两条数据 往一个表里面新增100条数据： for(var i=1;i&lt;=100;i++){ db.user.insert({\"username\":\"zhangsan\"+i,\"age\":i}) }; 查询当前表里面有多少条数据：db.user.find().count() 分页查询：查询当前表第一页的10条数据：db.user.find().skip(0).limit(10) 分页查询：查询当前表第二页的10条数据：db.user.find().skip(10).limit(10) 分页查询：查询当前表第三页的4条数据：db.user.find().skip(20).limit(4) 查询名字叫做zhangsan1或zhangsan13的人 db.user.find({$or:[{\"username\":\"zhangsan1\"},{\"username\":\"zhangsan13\"}]}) 查询年龄是13或21的人 db.user.find({$or:[{\"age\":13},{\"age\":21}]}) 查询第一条数据：db.user.findOne() 查询表里面年龄大于60的人的数量 db.user.find({\"age\":{$gt:60}}).count() 将表中的zhangsan6修改成张三：db.user.update({\"username\":\"zhangsan6\"},{$set:{\"username\":\"张三\"}}) 给表中姓名为张三,年龄为6的人新增性别为男：db.user.update({\"username\":\"张三\",\"age\":6},{$set:{\"sex\":\"男\"}}) 将表中姓名为张三的人的年龄修改成58：db.user.update({\"username\":\"张三\"},{$set:{\"age\":58}}) 批量修改：将表中年龄为58的人的性别全部修改为男：db.user.update({\"age\":58},{$set:{\"sex\":\"男\"}},{multi:true}) 将表中姓名为张三的人删除：db.user.remove({\"username\":\"张三\"}) 删除表中的全部数据：db.user.remove({}) 将表中年龄大于30的数据全部删除：db.user.remove({\"age\":{$gt:30}}) 只删除表中年龄大于10的一条数据：db.user.remove({\"age\":{$gt:10}},{justOne:true}) 查看查询语句的执行时间：db.user.find({\"username\":\"zhangsan1\"}).explain(\"executionStats\") 其中executionTimeMillis就是执行时间(ms) 创建索引：db.user.createIndex({\"username\":1}) 创建了索引之后查询数据就会变快 查看当前表的索引：db.user.getIndexes() 删除索引：db.user.dropIndex({\"username\":1}) 复合索引：db.user.createIndex({\"username\":1,\"age\":-1}) 指定索引名：db.user.createIndex({\"username\":1},{\"name\":\"userindex\"}) 创建唯一索引：db.user.createIndex({\"age\":1},{\"unique\":true}) 当给age创建了唯一索引后再向表中插入同样的数据就会报错 删除唯一索引：db.user.dropIndex({\"userid\":1}) 创建超级管理员： use admin db.createUser({ user:'admin', pwd:'123456', roles:[{role:'root',db:'admin'}] }) 查看当前库的管理员权限：show users 修改Mongodb数据库配置文件： 在Mongodb文件夹下找到mongod.cfg文件,进入修改里面的security文件 security: authorization: enabled 在cmd窗口上输入：services.msc 进入mongodb的配置服务页面,重启mongodb服务 在cmd窗口上输入:mongo admin -u admin -p 123456 进入超级管理员页面 删除管理员：db.dropUser(\"admin\") 创建普通管理员： use user db.createUser( { user:\"useradmin\", pwd:\"123456\", roles:[{role:\"dbOwner\",db:\"user\"}] } ) 创建完成之后再退出到cmd窗口输入 mongo user -u useradmin -p 123456 进入普通管理员页面 修改管理员密码：db.updateUser(\"admin\",{pwd:\"12345\"}) 密码认证：db.auth(\"admin\",\"123456\") 在cmd窗口下直接密码认证就可以进入数据库,注意必须先链接数据库 mongo admin node.js操作数据库 首先先在文件夹创建一个项目：在当前目录下打开cmd窗口输入：npm init --yes 然后用vscode打开，在终端安装mongodb数据库：npm i mongodb --save 在文件夹下新建app.js文件","categories":[{"name":"数据库","slug":"数据库","permalink":"https://yswm-m.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"笔记","slug":"笔记","permalink":"https://yswm-m.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"MySQL教程","slug":"12-MySQL","date":"2022-09-15T02:50:00.000Z","updated":"2022-09-30T08:29:36.312Z","comments":true,"path":"posts/12.html","link":"","permalink":"https://yswm-m.github.io/posts/12.html","excerpt":"","text":"安装mysql5.7 在dos命令下:cd输入mysql server下的bin路径,mysql -h localhost -u root -p 输入密码 或者直接：cmd下：mysql -u root -p 创建库：create database itcast; 查看库：show databases; 修改库：ALTER DATABASE itcast DEFAULT CHARACTER SET gbk COLLATE gbk_bin;将数据库的编码改为gbk。 删除库：DROP DATABASE itcast; 4个库：mysql专门用来保存用户信息。 information_schema用来保存一些原数据信息 performance_schema用于收集一些性能参数 test测试数据库,可以用来建表，删表：drop table 表名; 查看某一个数据库：show create database itcast; 进入库：use test; 查看表的数量：show tables; 如果提示：Empty set (0.00 sec)就表示没有表 在test下查看mysql库：show tables from mysql; 查看自己当前所在库：select database(); 创建表：create table stuinfo( id int,表示有一个id列，类型是int name varchar(20));表示有一个name列，类型是字符串 这样就创建了一个只有两列的表。 查看表的结构：desc stuinfo; 查看表的数据：select * from stuinfo; 插入数据：insert into stuinfo (id,name) values(1,'john'); insert into stuinfo (id,name) values(2,'rose'); 再去查看表中的数据：select * from stuinfo; 修改表中的数据：update stuinfo set name='lilei' where id=1;把表中的第一个数据修改成lilei 5.7创建表：&lt; id int&lt;11&gt;, name varchar&lt;20&gt;, grade float &gt;; 5.7数据类型：整形：TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT。 浮点型：FLOAT,DOUBLE,DECIMAL(M,D)。 日期与时间类型： YEAR(年份),DATE(日期),TIME(时间),DATETIME(日期与时间),TIMESTAMP(日期与时间)。 字符串： CHAR(固定长度的字符串),VARCHAR(可变长度的字符串) 5.7查看表：show create table itcast; 或者：desc itcast; 重命名：alter table 旧的表名 rename to 新的表名; 重命名表中的数据：alter table 表名 change name username varchar(20);//把name修改成username; 查看数据表：show create table 表名； 修改字段的数据类型：alter table 表名 modify 字段名 数据类型； 添加字段：alter table 表名 add 新字段名 数据类型； 删除字段：alter table 表名 drop 字段名； 修改字段的位置：alter table 表名 modify 字段名1 数据类型 first|after 字段名2；//first为将字段名1修改为表的第一个字段，after为将字段1排到字段2的后面 设置主键约束：字段名 数据类型 primary key; 或者：primary key(字段名1，字段名2，字段名n);//设置主键可以方便快速查找字段，以下设置都是在建表的时候完成的 添加主键约束：alter table 表名 add primary key(字段名); 删除主键约束：alter table 表名 -﹥drop primary key; 非空约束：字段名 数据类型 not null;//使字段的值不能为空 唯一约束：字段名 数据类型 unique;//使表中的该字段的值不能重复出现 默认约束：字段名 数据类型 default 默认值；//默认约束用来给表中的字段插入默认值 自动增加：字段名 数据类型 auto_increment;//每插入一条记录，这个字段的值就会自动增加 作业：1.新建名为“Mydatabase”的数据库：create database Mydatabase; 2.打开Mydatabase数据库:use Mydatabase; 3.建立20移动数据表： create table 20move( student char(20) primary key, name char(8) not null, gender char(6) default'man', score float); 4.在数据表的姓名字段上创建名为'unique_name'的唯一性索引：create unique index unique_name on 20move(name); 5.在20移动表中录入数据： insert into 20move values ('20201001','zhangsan','man',85), ('20201002','lisi','man',70), ('20201003','wangwu','man',50), ('20201004','lili','woman',75), ('20201005','wuhua','woman',56); 查看表中的数据：select * from 20move; 6.修改表中不及格的同学信息，每人加10分:update 20move set score=score+10 where score&lt;60; 7.删除名为王五的记录：delete from 20move where name='wangwu';","categories":[{"name":"数据库","slug":"数据库","permalink":"https://yswm-m.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"笔记","slug":"笔记","permalink":"https://yswm-m.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Kali教程","slug":"11-Kali教程","date":"2022-09-15T02:45:00.000Z","updated":"2022-09-30T10:26:38.678Z","comments":true,"path":"posts/11.html","link":"","permalink":"https://yswm-m.github.io/posts/11.html","excerpt":"","text":"文章内容: 通过VMware安装kali的linux镜像,可以在官网上下载,建议选择磁链下载快些 然后接下来可以看视频教程 修改密码：sudo passwd root 然后输入3次密码 进入伪root模式：su root 然后输入密码 退出：exit 进入真root模式：su - root 然后输入密码 pwd 查看家目录 隐藏进入root后的提示信息：touch ~/ .hushlogin 清屏：clear 查看shell的类型：echo $SHELL 换源： vim /etc/apt/sources.list 进入后把官方自带的源，第2行的源注释掉 # 可以在下面输入命令:set nu 查看行号 将下面的中科大的源复制到里面最后一行，然后按下esc再输入 :wq 保存并退出 deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib 复制技巧，选中内容就视为自动复制，在粘贴的地方按下鼠标的滚轮就可以完成粘贴 deb代表软件的位置，deb-src代表软件的源代码位置 ctrl+c 强制退出 查看可以更新的软件列表 ：apt update 更新软件：apt upgrade 强制更新软件(可能会有一点兼容性的问题)：dist-upgrade 注意：要先获取更新列表再进行更新 在设置里电源管理器中可以关闭锁屏 安装输入法框架：sudo apt install fcitx 安装中文输入法：sudo apt install fcitx-googlepinyin 安装完成后重启：reboot 打开kali的开始菜单栏，搜索fcitx 打开fcitx输入法配置框 ,添加对应输入法 取消只展示当前语言输入法 点击上移按钮，把google拼音选为默认输入法 关机：init 0 在vm虚拟机中创建一个快照 在w11下按下win+R输入cmd进入dos命令窗口，输入：ipconfig 在里面找到无线局域网适配器 WLAN: 下的IPv4 地址和默认网关 测试地址的连通性：ping 192.168.0.107 ipv4地址 测试网关的连通性：ping 192.168.0.1 默认网关 打开kali系统，使用root账号登陆，输入密码 输入 ctrl+alt+t 打开终端 输入 ctrl+shift+'+'号 把终端字体放大 输入vim /etc/network/interfaces 进入ip配置文件 按下字母o键 在光标的下一行进行插入 输入下面的ip信息： auto eth0 iface eth0 inet static address 192.168.0.107 netmask 255.255.255.0 gateway 192.168.0.1 按下esc，输入 :wq 保存退出 如果后续改乱了可以输入 :e! 还原回一开始保存的时候 关闭网络服务：systemctl stop NetworkManager 重启网络服务：systemctl restart networking 注意第一次配置要输入两次 输入 ifconfig 查看现在的网络状态 通过ping可以查看网络链接的状态是否连通 配置dns：vim /etc/resolv.conf 将里面的nameserver的dns改成：114.114.114.114 ping baudu.com 进行测试 192.168.1.145 192.168.1.1","categories":[{"name":"linux","slug":"linux","permalink":"https://yswm-m.github.io/categories/linux/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"笔记","slug":"笔记","permalink":"https://yswm-m.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Linux教程","slug":"10-Linux","date":"2022-09-15T02:40:00.000Z","updated":"2022-09-30T10:26:54.869Z","comments":true,"path":"posts/10.html","link":"","permalink":"https://yswm-m.github.io/posts/10.html","excerpt":"","text":"文章内容: 通过VMware安装Ubuntu的linux镜像,可以在官网上下载,建议选择磁链下载快些 然后接下来可以看视频教程 在VMware所虚拟出来的Ubuntu系统镜像上进行操作 打开终端：ctrl+alt+t cat /etc/shells 查看当前目录下支持shell的文件 echo $SHELL 查看当前环境下的bash shell和bash的作用是一致的,都是用来执行命令 history 查看历史记录 按tab键可以补齐命令或者查找以某个字符开头的所有命令 热键：ctrl+p 回到上一行命令 ctrl+n 回到下一行命令 ctrl+b 回到左边的命令 ctrl+f 回到右边的命令 对应上下左右，ctrl+a 回到行头 ctrl+e 回到行尾 ctrl+u 清空整行 ctrl+l 清屏 放大 ctrl+Shift 加上'+'号 缩小 ctrl+ '-'号 cd .. 回到上一级目录 pwd 查看当前目录 ls 查看系统目录 系统目录介绍： bin 存放可执行文件 date 查看当前时间 cd bin 进入bin目录 ls 查看bin目录下的文件 找到date可执行文件 ./date 执行date dev 设备目录 存放设备文件，如鼠标mice cd dev 进入dev目录 ls 查看dev目录下的文件 echo mice 查看鼠标设备文件 sudo cat mice 进入鼠标设备文件 ctrl+c 退出 etc 用户配置文件 cd etc 进入etc文件 ls 查看etc目录下的文件 vi passwd 查看用户密码信息 ls ../ 查看当前目录的上一级目录下的文件夹 ls /home 查看home目录下的文件夹 ls / 查看根目录下的文件夹 ls -lah /home 查看home目录下的文件夹大小和时间，如果是d开头则代表是一个文件夹，如果是-开头则代表是一个文件 ls -a 查看当前目录下的隐藏文件 cd ~ 回到家目录 cd /etc/bin/ 通过绝对路径进入到ect目录下的bin文件夹 mkdir mydir 在当前目录下创建一个mydir目录 mkdir -p a/b/c 在当前目录下创建一个a文件夹，a文件夹里再创建一个b文件夹，b文件夹里再创建一个c文件夹 sudo apt install tree 下载tree工具 tree a/ 查看a目录的所有文件结构 cd mydir/ 进入mydir目录 mkdir a/ b/ c/ 创建多个文件夹 rm -rf * 删除当前目录下的所有文件夹 touch linux.txt 在当前目录创建一个.txt文件 touch ../linux 在上一级目录创建一个linux文件 touch /home/bing/myfile 通过绝对路径在home下的bing目录下创建一个myfile文件 rm file01 删除当前目录下的file01文件 rm /home/bing/file02 通过绝对路径删除bing目录下的file02文件 rm -rf a/ 删除当前路径下的a文件夹 rm -rf /home/bing/a/ 通过绝对路径删除home下的bing目录下a文件夹 cp linux bak/ 将当前目录下的linux文件复制到bak/目录下 cp -r abc/ bak/ 将当前目录下的abc/文件夹复制到bak/目录下 clear 清屏 mv linux bak/ 将当前目录下的linux文件移动到bak/文件夹下 cd bak/ 进入bak目录 mv linux linux007 将当前目录下的linux文件重命名为linux007 mv /home/bing/bak/linux007 . 通过绝对路径将home下的bing下的bak下的linux007文件移动到家目录下 man ls 查看Linux下的关于ls的所有命令手册 help cd 查看LInux下的关于cd的所有命令手册 man man 查看Linux下的关于man的所有命令手册 reboot 重启Linux系统 shutdown -h now 关机 vim 在目录下输入:vim linux007 进入vim编译linux007文件的界面 进入到编译界面后输入 i 表示编辑这个文件 在输入完代码后按下esc键退出编辑 然后输入':'号，再输入w，然后回车，当命令提示后输入y ,确定保存,回车 输入':' q 回车 退出vim 在目录下输入:gedit linux007 进入到gedit编译linux007文件的界面 然后在里面编辑文件，可以直接点击保存，关闭 在目录下输入:nano linux007 进入到nano编译linux007文件的界面 然后输入ctrl+o编辑文件名 回车 编辑文件，然后ctrl+s保存文件 ctrl+x退出 换源 更新清华源: vim /etc/apt/sources.list 查看当前源 sudo cp /etc/apt/sources.list sources.list.bak 备份源 https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/ 进入位置复制对应的版本的文件 sudo vim /etc/apt/sources.list 打开配置文件，按esc键后，先按gg,再按dG，将文本全部删除，然后复制上面网站中的内容 sudo apt-get update 更新软件源 sudo apt-get upgrade 读取软件列表，保存在本地电脑 gcc 在终端下输入:sudo apt update 然后输入密码，安装管理软件的包，sudo代表切换当前用户从switch user切换为root，apt update代表管理软件的包 sudo apt install build-essential gdb 安装gdb调试器 gcc --version 查看gcc是否安装成功 g++ --version 查看g++是否安装成功 gdb --version 查看gdb是否安装成功 sudo apt install cmake 安装cmake cmake --version 查看cmake是否安装成功 sudo apt-get install fcitx 安装搜狗输入法 编译 gcc编译c++文件有4步: .c/.cpp &gt;&gt;编译器(预编译)&gt;&gt;.i&gt;&gt;编译器(编译)&gt;&gt;.s&gt;&gt;汇编器&gt;&gt;.o&gt;&gt;连接器&gt;&gt;可执行文件 cd testcpp/ 进入testcpp文件夹 vim test.cpp 创建一个名为test.cpp的文件并通过vim编辑器进入 :set ts=4 回车 将tab键的宽度从默认的8改为4 按下 i 键进入输入模式 输入完代码后按esc退出 ，然后输入 :wq 保存并退出 退出到终端后输入 g++ test.cpp -o test 回车编译并链接test.cpp文件 输入ls 查看当前目录下的可执行文件,可执行文件颜色为绿色 输入 ./test 执行test可执行文件 rm test 删除可执行文件 g++ -E test.cpp -o test.i 将test编译为预处理文件 vim test.i 查看预处理文件 g++ -S test.i -o test.s 将test.i预处理文件编译成汇编语言文件 vim test.s 查看汇编语言文件 g++ -c test.s -o test.o 将汇编语言文件编译成机器语言的二进制可识别文件 vim test.o 查看机器语言二进制文件 g++ test.o -o test 将机器语言的二进制文件编译成可执行文件 ./test 运行可执行文件 g++ -g test.cpp -o test 产生一个能被调试的可执行文件test g++ test.cpp -o2 -o test_o2 使用-o2优化代码，并生成test_o2可执行文件 ls -lh 查看两个可执行文件的大小 ./test_o2 执行o2优化后的可执行文件 time ./test 通过time查看未优化的可执行文件的执行时间 real time ./test_o2 通过time查看优化后的可执行文件的执行时间 real g++ -lglog test.cpp 链接glog库，通过-l g++ -L/home/bing/mytestlibfolder -lmytest test.cpp 链接mytest库，通过-L加上库的绝对路径，再通过-l链接库 g++ -I/myinclude test.cpp 指定头文件所在的目录，在相对路径前面加上大写的i g++ -Wall test.cpp 打印警告信息 g++ -w test.cpp 关闭警告信息 g++ -std=c++11 test.cpp 设置c++编译标准编译test.cpp g++ test.cpp -o test 编译并指定输出文件名，将原本的a.out重命名为test g++ -DDEBUG test.cpp 如果在.cpp文件里定义了: #ifdef DEBUG cout&lt;&lt;\"DEBUG\"&lt;&lt;endl; #endif 那么执行上面的命令，在#ifdef DEBUG里的代码就会被执行 man gcc 查看gcc的英文手册 sudo apt install tree -y 下载tree查看目录文件 tree . 查看当前目录的结构 分文件编译 在根目录下创建Demo01文件夹，Demo01文件夹下分别创建include文件夹和src文件夹，在include文件夹创建swap.h头文件，在src文件夹下创建swap.cpp文件，最后再在Demo01文件夹下创建main.cpp文件 g++ main.cpp src/swap.cpp -Iinclude 分文件编译main.cpp文件，main.cpp文件里面引入了swap.h文件，再通过src/swap.cpp指定swap.cpp文件的目录，而swap.cpp文件里又引入了swap.h头文件，所以需要通过-I指定头文件目录 ./a.out 运行可执行文件 g++ main.cpp src/swap.cpp -Iinclude -Wall -std=c++11 -o b.out 重新生成可执行文件，加上报错提示信息和c++标准，并且把原本的a.out重命名为b.out ./b.out 运行可执行文件 rm *.out 将以.out结尾的文件全部删除 将swap.cpp文件生成静态库文件 在 Linux 中，库文件分成静态库和共享库两种➀。静态库以.a 作为后缀名，共享库以.so 结尾。所 有库都是一些函数打包后的集合， 差别在于静态库每次被调用都会生成一个副本，而共享库则只有 一个副本，更省空间。 静态库最后都会被集成到可执行文件中，动态库不会 cd src/ 进入src文件夹 g++ swap.cpp -c -I../include 将swap.cpp生成swap.o汇编文件，-I后面指定的是头文件目录 ar rs libswap.a swap.o 将swap.o汇编文件生成swap.a静态库文件，lib后面就是要生成的库文件名 cd .. 回到上级目录 g++ main.cpp -lswap -Lsrc -Iinclude -o static_main 编译main.cpp并链接静态库文件，-l后面指定静态库名称，-L后面指定静态库的路径，-I后面指定头文件目录，-o将文件重命名为static_main可执行文件 ./static_main 运行可执行文件 cd src/ 进入src文件夹 rm swap.o 删除.o汇编文件 g++ swap.cpp -I../include -fPIC -shared -o Iibswap.so 用swap.cpp生成swap.so的动态库，-I后面是头文件的目录 cd .. 回到上一级目录 同时有动态和静态库存在时会优先链接动态库 g++ main.cpp -Iinclude -lswap -Lsrc -o dyna_main 编译main.cpp文件，并且链接到src下的动态库，将生成的可执行文件重命名为dyna_main ls -l 查看当前目录下的文件的字节数 LD_LTBRARY_PATH=src ./dyna_main 执行动态库的可执行文件，其中src是动态库所在的目录 gdb 常用命令： h 查看命令帮助 r 运行文件(run-text:加载文本文件，run-bin:加载二进制文件) start 单步执行(停在第一行执行语句) l 查看源代码(list-n:从第n行开始查看代码，list+函数名:查看具体函数) set 设置变量的值 n 单步调试(逐过程) s 单步调试(逐语句:跳入自定义函数内部执行) bt 查看函数的调用栈和层级关系 f 切换函数的栈 i 查看函数内部局部变量的数值 finish 结束当前函数，返回到函数调用点 c 继续运行 p 打印值和地址 quit 退出gdb b+n 在第n行设置断点 i b 查看当前设置的所以断点 d breakpoints n 删除第n个断点 display 监视变量 undisplay 取消监视变量 watch 被监视的变量发生修改时,打印显示 i watch 显示监视的变量 enable breakpoints 启用断点 disable breakpoints 禁用断点 x 查看内存 run argv[1] argv[2] 调试时给命令行传参 set follow-fork-mode child#Makefile 项目管理:跟踪父子进程 在根目录新建一个Demo02文件夹，在里面用vim新建一个test01.cpp文件 :set nu 显示行号 分屏回到上一级目录下 g++ test01.cpp -o a_no_g 生成a_no_g可执行文件 然后再 g++ -g test01.cpp -o a_yes_g 生成a_yes_g带调试器的可执行文件 ls -l 查看两个可执行文件的大小 gdb a_no_g 进入调试可执行文件的界面，提示无法调试没有调试器的文件 quit 退出gdb调试界面 gdb a_yes_g 进入调试带调试器的可执行文件界面 //gdb打开后 ctrl-x ctrl-a 进入tui模式 比开两个窗口好多了 //也可以直接使用命令 gdbtui - q 要调试的文件名称 run 执行代码 break 13 在代码的第13行打一个断点 info breakpoints 提示断点的信息 b 14 在代码的第14行打一个断点 i b 提示断点的信息 quit 退出gdb gdb a_yes_g 重新进入调试界面 b 13 在代码13行打一个断点 r 运行程序 p i 查看i变量的值 p N 查看N变量的值 continue 继续执行 p i 查看i变量的值，因为是在一个循环里面，所以每次都会撞上那个断点，而i是不停变化的 display i 不断的监视i变量的值 c 继续执行 回车 按下回车键会继续执行上一次命令，跟c的效果是一样的 //n 一行一行执行 list 查看断点周围的代码 l 查看断点周围的代码 display sum 监视sum变量 c 继续执行 quit 退出程序 vscode 在浏览器输入 https://code.visualstudio.com/ 进入vscode官网下载linux版本并安装 快捷键：alt+'↑'，alt+'↓'，将某一行上下移动 ctrl+` 打开终端 ctrl+shift+p 打开命令面板 ctrl+p 转到其他文件 ctrl+w 关闭当前文件 ctrl+b 关闭侧边栏 F2 变量统一重命名 F12 转到定义处 ctrl+shift+F 在整个文件夹中查找 在桌面新建一个C++文件夹，然后 cd C++进入该文件夹，然后 code . 用vscode打开该文件夹 在文件夹中新建一个helloworld.cpp的文件 写完代码后在终端: g++ helloworld.cpp -o helloworld 生成可执行文件 然后 ./helloworld 运行 分文件编译：在根目录新建include文件夹和src文件夹，然后在include文件夹新建swap.h文件，在src文件夹新建swap.cpp文件，然后在根目录新建main.cpp文件，写完代码后打开终端输入：g++ main.cpp src/swap.cpp -Iinclude -o main 生成可执行文件 然后./main 运行 如果一个文件在打开的时候会被下一个打开的文件覆盖掉，那么就在打开的文件的名字上双击就可以固定 ctrl+shift+i 格式化 F2 将所有文件的某个函数名字重命名 CMake gcc实际编译，make是构建工具，cmake是跨平台自动化工具 cmake语法:参数之间使用空格或者分号隔开，指令不区分大小写，参数和变量区分大小写 指令：cmake_minimum_required(VERSION 3.0) 指定cmake最低版本 project(HELLO) 定义工程名称为HELLO set(SRC sayhello.cpp hello.cpp) 定义SRC变量，其值为main.cpp hello.cpp include_directories(/usr/include ./include) 将/usr/include 和 ./include添加到头文件路径搜索 link_directories(/usr/lib ./lib) 将/usr/lib 和./lib添加到库文件搜索路径 add_library(hello SHARED ${SRC}) 通过变量SRC生成libhello.so动态库 add_library(hello STATIC ${SRC}) 通过变量SRC生成libhello.a静态库 add_compile_options(-Wall -std=c++11 -o2) 添加编译参数 -Wall报错提示 c++11标准 -o2优化 add_executable(main main.cpp) 编译main.cpp生成可执行文件main target_link_libraries(main hello) 将hello动态库文件链接到可执行文件main add_subdirectory(src) 添加src子目录,src中需有一个CMakeLists.txt文件 aux_source_directory(. SRC) 定义SRC变量，其值为当前目录下所有源代码文件 add_executable(main ${SRC}) 编译SRC变量所代表的源代码文件,生成main可执行文件 常用变量: CMAKE_CXX_FLAGS g++编译选项 set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\") 在CMAKE_CXX_FLAGS编译选项后追加-std=c++11 set(CMAKE_BUILD_TYPE Debug) 设定编译类型为debug，可调试 set(CMAKE_BUILD_TYPE Release) 设定编译类型为release，可发布 Debug自动加-g参数，Release会加上o3优化以及关闭debug调试 CMAKE_C_COMPILER 指定C编译器 CMAKE_CXX_COMPILER 指定C++编译器 EXECUTABLE_OUTPUT_PATH 可执行文件输出的存放路径 LIBRARY_OUTPUT_PATH 库文件输出的存放路径 cmake案例: 用vscode在文件夹下新建一个文件名为: CMakeLists.txt cmake_minimum_required(VERSION 3.0) 指定cmake的最低版本 project(HELLOWORLD) 指定项目名称 add_executable(helloWorld_cmake helloworld.cpp) 指定编译的源文件，helloWorld_cmake是要生成的可执行文件名 在终端输入：cmake . 对当前目录下的cmake进行编译 在终端输入：make 生成可执行文件 ./helloWorld_cmake 运行 将其他的文件删除然后在终端输入: mkdir build 新建文件夹 cd build/ 进入文件夹 cmake .. 通过外部构建的方式构建项目，两个点代表在上一层查找CMakeLists.txt文件 make 生成可执行文件 ./helloWorld_cmake 运行 进入分文件编写的文件夹 在文件夹里面新建CMakeLists.txt文件 cmake_minimum_required(VERSION 3.0) 设置最低版本 project(SWAP) 指定项目名称 include_directories(include) 指定头文件存放的目录 add_executable(main_cmake main.cpp src/swap.cpp) 生成可执行文件 main_cmake是要生成的可执行文件名，main.cpp是源文件，src/swap.cpp是分文件的目录 mkdir build2 创建启动文件夹 cd build2/ 进入启动文件夹 cmake .. 启动项目 make 生成可执行文件 ls 查看文件 ./main_cmake 运行 实战 新建一个文件夹 mkdir Project cd Project/ 进入文件夹 code . 用vscode打开该文件夹 pwd 查看当前文件夹所在路径 分别创建include和src文件夹，在include文件夹中创建Gun.h头文件，在src文件夹中创建Gun.cpp文件，写完代码后在include文件夹中再创建一个Soldier.h头文件，在src文件夹中再创建一个Solider.cpp文件，写完代码后再在上一级目录下新建一个main.cpp文件，编写完代码后打开终端输入: g++ main.cpp src/Gun.cpp src/Solider.cpp -Iinclude -o myexe -Wall -g -o2 ./myexe 运行 在目录下新建 CMakeLists.txt文件 cmake_minimum_required(VERSION 3.0) 指定cmake版本 project(SOLIDERFIRE) 指定项目名称 set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wall\") 为编译添加优化选项 set(CMAKE_BUILD_TYPE Debug) 为编译添加调试选项 include_directories(${CMAKE_SOURCE_DIR}/include) 添加头文件目录 add_executable(my_cmake_exe main.cpp src/Gun.cpp src/Solider.cpp) mkdir build 新建启动文件夹 cd build/ 进入文件夹 cmake .. 编译项目 make 生成可执行文件 ./my_cmake_exe 运行 配置vscode 点击vscode侧边栏的调试按钮，点击run运行，点击C(GDB/LLDB)，再点击g++ -生成和调试活动文件 点击Abort生成launch.json文件 将\"program\"字段改成: \"program\":\"${workspaceFolder}/build/my_cmake_exe\", 代表可执行文件的路径 新建一个tasks.json文件","categories":[{"name":"linux","slug":"linux","permalink":"https://yswm-m.github.io/categories/linux/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"笔记","slug":"笔记","permalink":"https://yswm-m.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"动态规划","slug":"09-动态规划","date":"2022-09-15T02:38:00.000Z","updated":"2022-09-30T08:27:22.034Z","comments":true,"path":"posts/9.html","link":"","permalink":"https://yswm-m.github.io/posts/9.html","excerpt":"","text":"文章内容: 解决dp问题的基础关键: 有限集合求最值: 化零为整,所谓化零为整就是解决问题的时候不是一个元素一个元素的去枚举,而是每次枚举一类东西,一个子集 子集里的一堆元素...这个就可以看作是一个化零为整的过程,就是把一些有相似点的元素划分成一个子集,然后用 某一个状态来表示,这也叫做状态表示。 状态表示: 1、集合:如 f(i),我们要考虑的是 f(i)表示的是哪个集合,这个集合是什么,一般这个集合描述的是所有满足什么 什么条件(题目的条件)的方案的集合,这就是f(i)所表示的方案的集合,正是因为f(i)每次可以表示一类集合,而不是 一个元素,所以它才可以去优化时间复杂度。 例如:一个学校里有2000个人,如果我们要一个一个的去数那么要数2000次,但是如果我们按照一个一个班级去数那就 只需要数20次就行了,这就是优化的核心。 2、属性:一般f(i)里面存的是一个数字,如整数或者浮点数或布尔值,那么存的这个数和这个集合的关系就叫做属性 属性一般有三种\\:max(最大),min(最小),count(数量)。 状态计算: 所谓状态计算就是把状态表示的每一个步骤算出来,状态计算一般对应的是一个化整为零的过程。 化整为零: 所谓化整为零就是先看一下f(i)所表示的所有状态是什么,也就是把f(i)划分成若干个部分,然后每一个 部分分别去求,这里把部分叫做子集,这些子集一般要满足两个原则: 1.不重复,就是每一个元素只属于其中一个集合 2.不遗漏,就是这个子集里所有的元素一定是把f(i)里所有的元素都包含了 这样的话当我们想求f(i)的时候只需要分别求出每个子集的值就行了: 比如说f(i)的属性是最大值,那么只需要求出每一个子集的最大值再在这些最大值里取一个max就可以了。 比如说f(i)的属性是数量,那么只需要求出每一个子集的数量再相加就可以了。 注意:不重复这个原则其实可以不遵守,如果是求数量的话才需要遵守这个原则 比如说我们要在三个数 A,B,C里求最大值,那么就先求max(A,B)的最大值,再求max(B,C)的最大值,再把这两个最大 值进行一个比较就可以得到三个数的最大值,这里B就重复被用了两次。 以上就是化整为零的过程。 集合的划分: 一般划分集合的依据是找最后一个不同点 题目1：01背包问题 原题链接 解题思路: f[i][j]表示只看前i个物品,总体积是j的情况下,总价值最大是多少。 推理:假设在这些物品中有一个特殊的物品 i,那么便有两种情况: 1:不选第i个物品:f[i][j]=f[i-1][j];意思是不选第i个物品只考虑前i-1个物品体积是j的情况下的最大价值 2:选第i个物品:f[i][j]=f[i-1][j-v[i]];意思是选第i个物品那么物品的体积 j就要减去第i个物品的重量因为 既然已经选了第i个物品那么背包就要给它腾空间,所以j要减去v[i],然后既然第i个物品已经被考虑完了,那么 只需要继续考虑前 i-1个物品就好了,所以i要-1。 最终的答案就是在上面两种情况里选一个最大值:f[i][j]=max(1. , 2.); 初始值定为:f[0][0]=0;表示0个物品并且总体积是0的情况下最大价值是0 代码: #include &lt;bits/stdc++.h&gt; using namespace std; #define N 1001 int n, m; #if 0 因为f[N][N]是定义在全局变量的,全局变量在堆区,堆区默认初始化为0 #endif int f[N][N]; #if 0 v代表体积,w代表价值 #endif int v[N], w[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; v[i] &gt;&gt; w[i]; } for (int i = 1; i &lt;= n; ++i) { for (int j = 0; j &lt;= m; ++j) { #if 0 如果不选 #endif f[i][j] = f[i - 1][j]; #if 0 如果选 因为只有在第i个物品的重量小于j(背包的容量)的情况下才能选 #endif if (j &gt;= v[i]) { #if 0 因为选了第i个物品所以要加上第i个物品的价值 #endif f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); } } } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0; } 01背包问题优化: 闫式dp分析法 分析:其问题的本质就是在一个有限集合里求最大值,n是物品的体积是有限的,m是物品的价值也是有限的 v是背包里物品的容量,w是背包里的东西的价值,这些都是有限的 从几个角度看dp: 1.状态表示: 一般来说伴随着选择问题的题目的状态表示第一维都是\"只考虑前i个物品\"f(i)因为都是只考虑选或不选, 第二维\"一般都是几个限制\"比如说体积的限制或者重量的限制或者只能选几个的数量的限制等等\"f(i,j)\" 2.看描述的这个集合是什么: 所有满足条件1,条件2的这个元素的集合,条件就是状态表示里面的条件,那么这里的集合就是: &lt;\"所有只考虑前i个物品,并且总体积不超过j的选法的集合。\"&gt;!!!转换过来就是: 所有从1-n个物品当中选,并且总体积不超过m的选法的集合。 3.属性： 一般看问题问的是什么,那这个值就是什么,在这里问题问的是总价值最大是多少,那么这里的属性是: 集合当中每一个方案的最大价值:max。 4.状态计算: 找最后一个不同点: 所谓最后一个不同点就是我们选最后一个物品的方法,如:选第i个物品和不选第i个物品是两种方案 那么只需要将f(i,j)所表示的集合划分成两个子集: 左边的子集表示在f(i,j)当中所有不选择第i个物品的方案: 左子集在f(i,j)当中,所以它需要满足f(i,j)的限制,也就是说它需要满足:从1~i中选且总体积小于等于j, 并且它要不包含物品i,那么它就变成了从1~i-1中选且总体积小于等于j的方案的集合:f(i-1,j); 右边的子集表示在f(i,j)当中所有选择第i个物品的方案: 右边的子集又可以分为两个小的方案: 1.前面随便选最后一定包含第i个物品,这是不变的部分,那么它的价值就是w[i]。 2.前面不随便选而是在不包含第i个物品的前提下随便选,也就是说第i个物品已经提前内定被放进了背包 那么就需要用j-v[i],j代表背包的容量,v[i]代表物品的重量,然后再在除了这个已经放进背包的v[i]之外 的i-1个物品里面选,并且总体积小于等于(j-v[i])的方案。 那么右边的子集的最大值就是上面两个方案加起来的值,也就是变化部分的最大值加不变的值: f(i-1,j-v[i])+w[i];注意当j&lt;v[i]的时候右子集就不成立了,因为物品的重量大过了背包的容量 所有的状态计算需要满足两个原则: 1:不重复,每个方案要么不包含第i个物品,要么包含第i个物品 2:不遗漏,所有的方案都是在f(i,j)这个集合当中 所以如果我们要求f(i,j)的最大值的话,只需要求出左边这个子集的最大值,再求出右边这个子集的最大值 两个子集取一个max也就是f(左,右)的最大值:f(i,j)=max(f(i-1,j),f(i-1,j-v[i])+w[i]); 代码: #include &lt;bits/stdc++.h&gt; using namespace std; #define N 1001 int n, m; int f[N][N]; int v[N], w[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; v[i] &gt;&gt; w[i]; } #if 0 因为i要减一,如果从0开始的话会越界 #endif for (int i = 1; i &lt;= n; ++i) { for (int j = 0; j &lt;= m; ++j) { f[i][j] = f[i - 1][j]; if (j &gt;= v[i]) { f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); } } } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0; } 题目2：完全背包问题 原题链接 解题思路: 分析:完全背包和01背包的区别就是01背包里一个物品只能拿一次,而完全背包能拿无数次 状态表示: 所有满足只从前i个物品中选,且总体积不超过j的方案的集合 属性:最大值也就是max 总结:所有满足只从前n个物品中选,且总体积不超过m的方案的集合的最大值 状态计算: 与01背包不同,完全背包不止两个状态子集,而是要定义成多个状态子集: 选0个第i个物品,也就是不选:那么就是从1~i中选并且不选i=&gt;1~i-1&lt;=j=&gt;f(i-1,j); 选1个第i个物品,与第k个物品同理 选2个第i个物品,与第k个物品同理 选k个第i个物品,把上面分成两个状态,第一个状态是固定不变的,也就是选择第k[i]个物品是不变的 那么不变的物品价值就是w[i]; 第二个状态是变的,选择前面流动的1~k[i-1]个物品是变化的,我们要做的就是在流动k-1个物品里选择最大值 那么就是在1~i-1里(除了第i个物品)并且&lt;=j-v[i](因为最后背包要给第i个物品腾位置)。 那么最后这两种状态的公式是:f(i-1,j-v[i])+w[i];(w[i]是固定的要加上) ...一直到不能选为止也就是体积超过了j为止 最后把上面的公式都加起来选一个最大值: 因为f(i-1,j-v[i])+w[i]只是第2个集合(选1个第i个物品)的公式,还有剩下的集合的公式要一起加起来 f(i,j)=max(f(i-1,j),f(i-1,j-v[i])+w[i],f(i-1,j-2v[i])+2w[i].....j-kv[i]+kw[i])&lt;=j 优化等差数列消除: 直接将原来公式里的j变成上面公式的第二项j-v[i],那么公式就变成了: f(i,j-v[i])=max(f(i-1,j-v[i]),f(i-1,j-2v[i])+w,f(i-1,j-3v[i])+2w....))+w[i]; 上面的公式的每一项都比原来的公式少了一个w[i],所有最后要加上w[i]; 其实也就是把原来的公式从第二项 f(i-1,j-v[i])+w[i],开始变为另外一个公式,而原来的第一项公式 f(i-1,j)只需要在最后求最大值的时候加上就行了。 最终只需要在上面的两个公式中选一个最大值max就是我们要的答案: f(i,j)=max(f(i-1,j),f(i,j-v[i])+w[i]); 代码: #include &lt;iostream&gt; using namespace std; #define N 1001 int n, m; int dp[N][N]; int v[N], w[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; v[i] &gt;&gt; w[i]; } for (int i = 1; i &lt;= n; ++i) { for (int j = 0; j &lt;= m; ++j) { dp[i][j] = dp[i - 1][j]; if (j &gt;= v[i]) dp[i][j] = max(dp[i][j], dp[i][j - v[i]] + w[i]); } } cout &lt;&lt; dp[n][m] &lt;&lt; endl; return 0; } 题目3：多重背包问题 I 原题链接 解题思路: 现在有a件物品，每件物品都有他自己的价值与体积，因为每件只能放一次，那么咱们就按先后顺序一个一个拿起来判断，看能不能装下，若是能装下，看要不要拿，要不要拿肯定是看此时拿了的话能否构成此时的最优解。要判断是否是该状态下的最优解肯定要判断如果将该物品放入刚好满的话，那放他之前的最优解是什么。转换一下思维就是要求以 背包容积-该物品容积 为容积的背包装之前的物品的最优解【并不包括本物品以及之后的物品】。那么咱们就要通过从1遍历背包的容积来判断最优解，这就是所谓的基于之前的数据。 现在总结下思路 咱们要做这道题就要挨个物品判断要不要拿能不能拿，同时通过遍历背包容积判断每个容积下的最优解，以此来判断该种物品究竟拿了能不能带到此时的最优解。用二维数组dp[i-1][x],就可以完美的表示第i件物品之前容积为x时的最优解（第i件物品和它后面的物品都不可能在这个背包） 代码: #include &lt;bits/stdc++.h&gt; using namespace std; #define N 110 int n, m; int f[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) { int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; for (int j = m; j &gt;= 0; --j) { for (int k = 1; k &lt;= s &amp;&amp; k * v &lt;= j; ++k) { f[j] = max(f[j], f[j - k * v] + k * w); } } } cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 题目4：多重背包问题 II 原题链接 解题思路: 假设有一组商品，一共有11个。我们知道，十进制数字 11 可以这样表示 11=1011(B)=0111(B)+(11−0111(B))=0111(B)+0100(B) 11=1011(B)=0111(B)+(11−0111(B))=0111(B)+0100(B) 正常背包的思路下，我们要求出含这组商品的最优解，我们要枚举12次（枚举装0，1，2…12个）。 现在，如果我们把这11个商品分别打包成含商品个数为1个，2个，4个，4个（分别对应0001,0010,0100,0100）的四个”新的商品 “, 将问题转化为01背包问题，对于每个商品，我们都只枚举一次，那么我们只需要枚举四次 ，就可以找出这含组商品的最优解。 这样就大大减少了枚举次数。 这种优化对于大数尤其明显，例如有1024个商品，在正常情况下要枚举1025次 ， 二进制思想下转化成01背包只需要枚举10次。 如果仍然不是很能理解的话，取这样一个例子:要求在一堆苹果选出n个苹果。我们传统的思维是一个一个地去选，选够n个苹果就停止。这样选择的次数就是n次 二进制优化思维就是：现在给出一堆苹果和10个箱子，选出n个苹果。将这一堆苹果分别按照1,2,4,8,16,…5121,2,4,8,16,…512分到10个箱子里，那么由于任何一个数字 x 都可以从这10个箱子里的苹果数量表示出来，但是这样选择的次数就是 ≤10次 这样利用二进制优化，时间复杂度就从 O(n3) 降到O(n2logS)，从4∗10^9 降到了2∗10^7 代码: #include &lt;iostream&gt; using namespace std; const int N = 12010, M = 2010; int n, m; int v[N], w[N]; //逐一枚举最大是N*logS int f[M]; // 体积&lt;M int main() { cin &gt;&gt; n &gt;&gt; m; int cnt = 0; //分组的组别 for (int i = 1; i &lt;= n; i++) { int a, b, s; cin &gt;&gt; a &gt;&gt; b &gt;&gt; s; int k = 1; // 组别里面的个数 while (k &lt;= s) { cnt++; //组别先增加 v[cnt] = a * k; //整体体积 w[cnt] = b * k; // 整体价值 s -= k; // s要减小 k *= 2; // 组别里的个数增加 } //剩余的一组 if (s &gt; 0) { cnt++; v[cnt] = a * s; w[cnt] = b * s; } } n = cnt; //枚举次数正式由个数变成组别数 // 01背包一维优化 for (int i = 1; i &lt;= n; i++) for (int j = m; j &gt;= v[i]; j--) f[j] = max(f[j], f[j - v[i]] + w[i]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://yswm-m.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"动态规划","slug":"动态规划","permalink":"https://yswm-m.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"数据结构与算法","slug":"08-数据结构与算法","date":"2022-09-15T02:34:00.000Z","updated":"2022-09-30T08:37:50.068Z","comments":true,"path":"posts/8.html","link":"","permalink":"https://yswm-m.github.io/posts/8.html","excerpt":"","text":"文章内容: 数据结构与算法之旅 （正在自学中，此笔记会不断更新完善） 如果这世界上真有奇迹 那只是努力的另一个名字 ----《致美丽的你》---- 视频链接 学奔溃后和大佬的对话： 哈哈，我最近没看到消息。不要迷茫同学，克服当下的困难，做自己害怕的事，你会感到十分充实。我刷题也是一直受打击，不过我最近一天硬着头皮刷5道，这其实就是一个熟能生巧的过程，万事开头难。正是因为有差距，才要一点一点追赶。我之前也是喜欢和别人比，其实你可以不用和别人比，因为比了也无法缩小差距，还不如和昨天的自己比进步，每日有更多的收获。慢慢地过段时间，通过你的坚持不懈，你会发现，你和别人的距离缩小了。即使你认为很厉害的人他们也和你有同样的心理，因为他们比较对象不同，为什么有些人能顶得住压力，继续奋勇向前，当你只在乎自己是否有提升的时候，你就是无所畏惧的。想做的事，考虑清楚之后，尽管去做。你要记住，凡是不能够打倒你的，都会使你更强大。迷茫是常态，在迷茫之后又能迅速找到方向才是正解。人生是长跑，现在比你强的，以后未必，现在没你强的，以后或许会超越你，但这件事不是发生在现在，而是一步一个脚印走向的未来。希望能帮到你！ 时间复杂度： 看：N+N-1+N-2+N-3...... 比：N+N-1+N-2+........ swap：N次 = aN^2+6N+C 只要高阶项，不要低阶项，如果剩下的部分为f(N)，那么时间复杂度为o(f(N)) 如：选择排序每一次遍历只排序一个数，那么就是0~N-1,第二次遍历:0~N-2......那么等差数列就是:aN ^ 2+C,忽略掉高阶项和低阶项也就是忽略掉a和C,那么时间复杂度就是O(N^2); 异或： 相同为0,不同为1 如：a ^ b= ? a=0,b=1;则=1; a=0,b=0,则=0; a=1,b=1,则=0; a=10110,b=00111,则=10001; 那么可以推出结论：0^N=N（0跟任何数异或都是那个数本身） N^N=0（任何数跟任何数异或都是0） a^b=b^a（交换） a^b^c=a^(b^c)（b和c先异或再异或a）(一堆数)^(同一堆数)=(同一堆数)（跟谁先异或的顺序无关，结果一定是一样的） 应用到选择排序上： int a=17;int b=23; a=a^b;（a=17^23, b=23） b=a^b;（a=17^23 b=17^23^23（b=17^(23^23)=17^0）b=17） a=a^b;（a=17^23^17(a=23^(17^17)=23^0) a=23） 当上面的代码执行完以后a和b的值被交换了 注意：这样写的前提是a和b不能指向同一块区域 问题1：在一个整形数组中已知只有一种数出现了奇数次，其他的所有数出现了偶数次，怎么找到出现了奇数次的那个数？ 答：创建一个变量等于0,把那个变量跟数组中的每一个数都依次遍历异或一次，最后那个变量就等于那个奇数 问题2：在一个整形数组中如果有两种数出现了奇数次，其他所有数都出现了偶数次，怎么找到那两种出现了奇数次的数？ 答：创建一个变量eor，将数组所有的值遍历一遍，最后eor等于a ^ b(a和b就是那两种奇数)，创建一个变量right等于eor&amp;(~eor+1(取反eor再加1)再&amp;上eor)=数组中最右侧的1也就是被 ^ 后不是0的那些数，再创建一个变量eorl=0，再循环遍历数组,判断用right&amp;上数组中的每一个数是否不等于0，判断成功进来之后用eorl去异或第8位上数组里不是0的那些数，也就是进来之后的数组arr[i]，然后erol就变成了那两个奇数中的一个（a or b），最后eor^eorl就可以得到另一个奇数…… 插入排序： 就跟斗地主时拿牌插牌再拿牌一样 通过for循环遍历数组，第一个for循环i=1;i &lt; len;i++，第二个for循环里面创建一个变量j，j=i-1;j&gt;=0&amp;&amp;arr[j] &gt; arr[j+1];j--（i等于第二个数,j就等于比i小的前一个数,j+1就等于i,如果j所代表的前一个数大于j+1所代表的后一个数,则就把j和j+1进行交互,将较小的后一个数移到前面来,然后j--就代表j再等于更前一位的数,j+1就代表刚交换过来的那个数,然后再进行比较,一直到j减到第0位为止，也就是说一直在&lt;=i的前面不停的比较，最终i循环完也就排序完了）因为要交换的是j与j+1，所以交换代码可以这样写：arr[j]=arr[j] ^ arr[j+1];arr[j+1]=arr[j] ^ arr[j+1];arr[j]=arr[j] ^ arr[j+1]; 二分查找法: 用二分法查找的数组必须有序，其方法就是在中间找一个数X，然后判断中间的这个数X是否大于要查找的那个数num，如果大于则把数组中大于X的一堆数给砍掉，只在小于X的那堆数里找num，然后继续在小于X的那堆数里找中间数，继续判断砍掉另一半，最终找到num为止…… 问题1：在一个有序数组中有一个num，要求找到这个数组中num的最左值，也就是num第一次出现的位置? 答：假设这个数是3，那么先在中间找一个数,假设这个中间的数是4,那么4&gt;=3,满足则把4这个位置右边的数给省略掉，4这个位置用一个变量t记住，在这个位置左边找中间数，假设找到2，2不&gt;=3,不满足，则在2这个位置的右边找，在2这个位置的右边取中间一个数，假设取到了3，3&gt;=3满足，如果此时这个3的位置比之前那个4的位置往左了一点，也就是比t小了一点，那么就让t等于3那个位置，如果此时t的位置左边还有数则继续二分取中间数，假设又取到了3，3&gt;=3满足，继续用t等于3的这个位置，如果此时继续往左只有之前那个不满足的2的位置则当前这个3的位置就是最左值…… 问题2：在一个无序数组中任何两个相邻的数不相等，请找到一个该数组中局部最小的数？（局部最小的意思是这个数的左边和右边两个数都比它大，那么它就是局部最小，如果是0位则只需要比它右边的数小，如果是N-1则只需要比左边的N-2小）…… 答：先判断0位置是不是局部最小，如果是则直接返回，如果不是则表示0位置的数比1位置的数要大，然后再判断N - 1是不是局部最小(N代表的是数组的最后那个数)，如果是则返回，如果不是则代表N-1比N-2要大，那么此时0位置 ~ N-1位置一定有一个局部最小值，这时直接用二分法取0 ~ N中间位置，假设取到了X，如果X比X-1位置要小并且比X+1位置也小则直接返回X，否则X就比X-1位置或者X+1位置要大，那么此时这个局部最小值就在位置0 ~ X-1之间，那么就继续在位置0 ~ X-1中取中间二分，直到找到那个局部最小值为止…… 对数器： 针对一个题目需要准备两种不同的方法 创建两个函数，一个是算法，一个是暴力解法，再创建一个随机样本产生器（通过随机产生数据的函数random()，random() * N，int(random() * N)）也就是创建两个一模一样的数组，数组里面的值和长度是随机的，然后两个函数分别调用一遍，看是否结果一样，如果不一样则人工干预把它改成一样的 day02 递归问题： 求数组中某一个范围上的最大值： 先把要求的范围L跟R给传进来，如果L==R，则直接返回L，否则创建一个变量mid=L+((R-L)&gt;&gt;1);(这里的意思是右移一位求中间数，也可以看作是(R-L)/2) 然后利用递归方法分别求出左边的最大值和右边的最大值：fun(arr,L,mid); fun(arr,mid+1,R); 然后返回两个最大值中较大的那个：return max(leftMax,rightMax); master公式：T(N)=a * T(N / b)+O(N ^ d)，所有的递归都可以用这个公式求，其中a等于要调用递归的次数，b等于二分的区域,如果是分成两半那就是2分之N,如果是分成3份那就是3分之N，O(N ^ d)表示除去所有子递归调用后剩下的代码的时间复杂度，这个d指的是决策过程如果只有一个则d=0，O(1)就是剩下代码的时间复杂度……其公式可以如下：log(b,a) &lt; d： O(N ^ d)，log(b,a)&gt; d：O(N ^ log(b,a))，log(b,a)==d：O(N ^ d * logN) 归并排序： 利用二分的方法不断的递归调用，每次找一半排序，然后左一半和右一半排好序后进行比较，谁小拷贝谁，准备一个长度大小一模一样的数组，把左边右边比较后小的那个数拷贝进数组，拷贝完后就对下一个数进行比较拷贝(这里的左边和右边的比较都是从下标为最左边第一个数的位置开始比较的)，当有任意一半边越界时就不进行比较了，直接把剩余的数全部拷贝进数组，也就是合并两个有序数组，使合并后的数组有序…… 例如：先创建一个函数fun，判断数组arr是否等于NULL或者数组长度是否小于2，如果是则直接return，否则就调用process函数：process(arr,0,len); void process(int* arr,int L,int R){ //然后在函数里面判断L==R，如果等于则返回，否则创建一个变量等于数组长度的中间位置： int mid=L+((R-L)&gt;&gt;1); //然后将数组的左半边通过递归调用不停的二分排序，注意process只是调用，真正排序的功能代码在merge函数里面，因为每次递归都会调用自己和merge函数，所以可以实现一半有序： process(arr,L,mid); //再将数组的右半边通过递归调用不停的二分排序： process(arr,mid+1,R); //最后通过调用排序函数来将左边和右边的数传进去排序：merge(arr,L,mid,R); } void merge(int* arr,int L,int M,int R){ //创建一个新的数组用来存排好序的数长度跟原来的那个数组一样： vector&lt;int&gt; help(R - L + 1); //创建一个变量i专门给help使用： int i=0; //创建两个类似指针的变量一个指向L,一个指向右边的边界也就是右半边一开始的位置mid+1： int p1=L; int p2=M+1; //然后创建一个循环，循环条件是左边和右边的指针变量都没有越界： while(p1&lt;=M&amp;&amp;p2&lt;=R){ //如果都没有越界则左边和右边不停的进行比较，把小的那个拷贝进数组里： if (arr[p1] &lt;= arr[p2]){ help[i++] = arr[p1++]; } else { help[i++] = arr[p2++]; } } //然后再创建两个循环判断是否越界,一定会有一个越界所以下面两个while循环只会中一个： //如果p1没有越界则代表p2越界了,那么就把p1剩下的值拷贝到help数组里去： while(p1&lt;=M){ help[i++]=arr[p1++]; } //如果p2没有越界则代表p1越界了,那么就把p2剩下的值拷贝到help数组里去： while(p2&lt;=R){ help[i++]=arr[p2++]; } //执行完上面的循环之后help数组里就是已经排好序的新数组了，最后再将新数组把用来的数组拷贝替换掉，那么原来的数组就是排好序的数了： for(i=0;i&lt;help.size();i++){ arr[L+i]=help[i];//L表示数组的左边第一个下标 } } 问题1：小和问题:在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和，求一个数组的小和：【1，3，4，2，5】…… 例：每个数前面比它小的那个数加起来，如数组【1,3,4,2,5】1的前面没有，所以它的小和是0，3的前面有1，所以它的小和是1，4的前面有1，3，所以它的小和是1+3=4，2的前面只有1比它小，所以它的小和是1，5的前面有1,3,4,2比它小，所以它的小和是1+3+4+2=10；那么这个数组的小和就是全部小和加起来：0+1+4+1+10=16…… 转换思路：求一个数左边有多少个数比它小其实也是求右边有多少个数比它大，如数组【1,3,4,2,5】 1的右边比它大的数有4个，那么就是4个1 3的右边比它大的数有2个，那么就是2个3 4的右边比它大的数有1个，那么就是1个4 2的右边比它大的数有1个，那么就是1个2 5的右边比它大的数没有，那么就是0个5 那么( 4 个 1 ) 4 + ( 2 个 3 ) 6 + ( 1 个 4 ) 4 + ( 1 个 2 ) 2 = 16 代码： //创建一个fun函数判断arr是否等于NULL或者len&lt;2，是则返回0否则返回调用process函数的结果: int fun(int *arr, int len) { if (arr == NULL || len &lt; 2) { return 0; } return process(arr, 0, len); } //创建一个process函数在函数里不停的递归二分： int process(int *arr, int L, int R) { if (L == R)//如果左边和右边长度相同则直接返回0 { return 0; } int mid = L + ((R - L) &gt;&gt; 1);//找到数组中间位置 return process(arr, L, mid) + //左侧排序求小和的数量 process(arr, mid + 1, R) +//右侧排序求小和的数量 merge(arr, L, mid, R);//左侧排好和右侧排好合并之后加上merge求小和的数量 } //创建一个merge函数求每次递归过来的数的小和数量 int merge(int *arr, int L, int M, int R) { vector&lt;int&gt; help(R - L + 1);//创建一个和每次递归传过来的数组长度一模一样的动态数组 int i = 0;//创建一个变量i专门用来给help数组使用 int p1 = L;//创建一个指针变量等于最左边的下标 int p2 = M + 1;//创建一个指针变量等于右边的边界 int res = 0;//创建一个变量用来累加小和 while (p1 &lt;= M &amp;&amp; p2 &lt;= R) {//如果左边的下标指针变量和右边的下标指针变量都没有越界则进行比较 if (arr[p1] &lt; arr[p2])//如果左边的比右边的小 { //求小和的数量，R-p2+1代表右边界减去右边变量所指的下标后还剩下多少个数比左边的下标的数大再乘arr[p1]也就是左边下标所指的那个数得到多少个数比左边的数大就是多少个左边的数，如4个数比1大那就是4个1，然后用创建的变量累加起来 res += (R - p2 + 1) * arr[p1]; //得到小和的数之后再将小的那个数存进新创建的数组里面，这样最后数组里的数也排序好了 help[i++] = arr[p1++]; } else //如果左边的不比右边的小 { //则表示没有小和，res变量就不累加任何数 res += 0; //也是将小的那个数存进变量里，进来这里则表示右边比左边的小 help[i++] = arr[p2++]; } } //判断右边指针变量是否越界，如果越界则把左边剩余排序好的数给全部放进新数组里 while (p1 &lt;= M) { help[i++] = arr[p1++]; } //判断左边指针变量是否越界，如果越界则把右边剩余排序好的数给全部放进新数组里 while (p2 &lt;= R) { help[i++] = arr[p2++]; } //把新数组拷贝替换回原数组，这样原数组就是排好序的数了 for (i = 0; i &lt; help.size(); i++) { arr[L + i] = help[i]; } return res; } 问题2：逆序对问题:在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对和数量。 例子：【3,2,4,5,9,1,0】的逆序对是12 1. 3,2 2. 3,1 3. 3,0 4. 2,1 5. 2,0 6. 4,1 7. 4,0 8. 5,1 9. 5,0 10. 9,1 11. 9,0 12. 1,0 代码： int fun(int *arr, int len) { if (arr == NULL || len &lt; 2) { return 0; } return process(arr, 0, len - 1); } int process(int *arr, int L, int R) { if (L == R) { return 0; } int mid = L + ((R - L) &gt;&gt; 1); return process(arr, L, mid) + process(arr, mid + 1, R) + merge(arr, L, mid, R); } int merge(int *arr, int L, int M, int R) { //如果左边的数比右边的数大，则这两个数构成一个逆序对 vector&lt;int&gt; help(R - L + 1); int i = 0; int p1 = L; int p2 = M + 1; int res = 0; while (p1 &lt;= M &amp;&amp; p2 &lt;= R) { if (arr[p1] &gt; arr[p2]) { //最重要的就是这条，通过减p2的下标位置而知道有多少个右边的数比左边的数小 res += (R - p2 + 1); help[i++] = arr[p1++]; } else { res += 0; help[i++] = arr[p2++]; } } while (p1 &lt;= M) { help[i++] = arr[p1++]; } while (p2 &lt;= R) { help[i++] = arr[p2++]; } for (i = 0; i &lt; help.size(); i++) { arr[L + i] = help[i]; } return res; } day03 荷兰国旗问题： 问题1：给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。 答：创建一个指针变量i，从左边遍历数组，当[ i ] &lt; = num时，[ i ]和小于区域的下一个变量也就是还没进入小于区域的后一个变量交换，i++。 当[i] &gt; num时,i++;最后遍历完数组最后一个数时就完成了比num小的数在左边，比num大的数在右边。 问题2：给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。 答：创建一个i指针变量，当[i] &lt; num时,[i]和小于区域也就是还没进入小于区域的下一个数交换，小于区域向右扩将刚交换完的那个数扩进小于区域，i++。 当[ i ] = = num时,i++。 当[ i ] &gt; num时,[ i ]和大于区域前一个也就是还没进入大于区域的前一个数交换，大于区域左扩将刚交换的数扩进去，i原地不变继续执行逻辑1，如果小于num则和小于区域的后一个数交换左边区域继续扩。如果等于num则i++。 快速排序： 1.0版本：将排序问题拆分为将数组划分成大于Num的右子序列与小于等于Num的左子序列，即每次num位置都是相对正确的。递归让所有问题规模的数组都有序。 2.0版本：Num区域是已经排序好的，不断递归增加排序好的范围。 复杂度都是最坏情况O(n ^ 2)，最好情况就是划分值在中值附近。 day04 堆排序： 堆结构其实是一颗完全二叉树结构，根据下标把数据从零到末尾依次按二叉树排好,优先级队列其实就是堆结构，堆结构比堆排序重要的多 排好后这时任意一个节点的左右孩子位置可以通过公式求得：左孩子： 2 * i + 1，右孩子：2 * i + 2 它们的父亲可以通过：( i - 1 ) / 2 得到 堆排序跟完全二叉树不同的是堆结构分为大根堆和小根堆，大根堆是二叉树的头结点必须得是数组中最大的那个数，从大往小排，而小根堆是从小往大排。 代码： void fun(int* arr, int len) { if (arr == NULL || len &lt; 2) { return; } for (int i = 0; i &lt; len; i++) { heapInsert(arr, i); } } void heapInsert(int* arr, int index)//大根堆 { while (arr[index] &gt; arr[(index - 1) / 2]) { swap(arr[index] , arr[(index - 1) / 2]);//交换函数 index = (index - 1) / 2; } } 问题1：找到堆中的最大值然后把它去掉 答：找一个变量存储根节点的值，把根节点取出来和最后一个节点交换，将数组的长度len减一，这样最后一个节点的值就自动和堆断开连接了，然后交换后的根节点自动跟它的子节点里最大的比较，如果比子节点小自动换位。 代码： void fun(int *arr, int len) { if (arr == NULL || len &lt; 2) { return; } // for (int i = 0; i &lt; len; i++) //此时数组里的数已全变成大根堆 // { // heapInsert(arr, i); // } for(int i=len-1;i&gt;=0;i--){//自低向上的不停进入heapify找子节点比大小，当这个过程完了之后也是大根堆跟上面是等价的 heapify(arr,i,len);//如果用户不是一个一个的往数组里加数而是一堆数给你那么这个方法是最好的 } swap(arr[0], arr[--len]); //这里单独交换的意思其实就是等价于len-1， //因为下面的循环是从10~0,一共有11次，所以要在这里减一次并将第一个和最后一个交换 while (len &gt; 0) //通过遍历左右孩子来实现排序 { heapify(arr, 0, len); // O(logN) swap(arr[0], arr[--len]); } } void heapInsert(int *arr, int index) //大根堆 { while (arr[index] &gt; arr[(index - 1) / 2]) { swap(arr[index], arr[(index - 1) / 2]); index = (index - 1) / 2; } } void heapify(int *arr, int index, int heapSize) //判断左右子节点是否越界需要长度也就是heapSize { int left = index * 2 + 1; //左孩子 int largest; while (left &lt; heapSize) //当下方还有孩子的时候 { //两个孩子中谁的值大，把谁的下标给largest if (left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left]) // left+1是右孩子的下标，因为左孩子是i*2+1，右孩子是i*2+2 { //如果右孩子存在且右孩子的值大于左孩子 largest = left + 1; // largest等于右孩子的下标 } else { largest = left; // largest等于左孩子的下标 } if (arr[largest] &gt; arr[index]) //较大孩子的值和父亲的值比较 { largest = largest; //如果较大孩子比父亲大则largest不变 } else { largest = index; //如果较大孩子没有比过父亲则largest等于父亲的下标 } if (largest == index) //如果largest(孩子)==index(父亲)则表示父节点下面已经没有比父节点大的孩子了，父节点就是最大的了，则退出循环 { break; } swap(arr[largest], arr[index]); //如果largest!=index则表示largest(较大孩子)干过了index(父亲),则把孩子和父亲的值交换 index = largest; //交换过后index(父亲)=largest(较大孩子)也就是现在index(父亲)变成了原先的较大孩子继续往下走进行比较 left = index * 2 + 1; //这时左孩子就等于了原先较大孩子的左孩子继续循环，如果没有孩子了则会退出循环，如果有孩子但孩子都不比它大则也会退出循环 } } 问题2： 答：假设k=6，创建一个小根堆排序，排完后0位置上放的就是小根堆的最小值，然后把0位置弹出，放入第7个数字也就是新输入的第一个数字，这时小根堆的最小值在1位置上，然后继续弹出位置1上的最小值，再加入第8个数字，这时最小值在2位置上，这样依次弹出，最后数组临近结束的时候只要依次把小根堆弹出的数停好数组就有序了。 利用黑盒priority_queue创建堆排序代码： #include &lt;bits/stdc++.h&gt; using namespace std; int main() { //priority_queue&lt;int&gt; a; //这个就是堆排序的封装函数,默认是大顶堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap; //这样就是小顶堆 priority_queue&lt;pair&lt;int, int&gt; &gt; a;//pair用来比较元素，返回一整个数组的值,第一个数组里的值比较完比较第二个 // priority_queue&lt;string&gt; b; heap.push(8); heap.push(4); heap.push(9); heap.push(1); while (!heap.empty()) //如果队内元素不为空 { cout &lt;&lt; heap.top() &lt;&lt; \" \"; //输出头元素然后用pop()弹出 heap.pop();//一直循环弹出到没有元素为止 } cout&lt;&lt;\"\\n\"; pair&lt;int, int&gt; b(1, 2); pair&lt;int, int&gt; c(1, 3); pair&lt;int, int&gt; d(2, 5); a.push(d);//2，5 a.push(c);//1，3 a.push(b);//1，2 while (!a.empty()) { cout &lt;&lt; a.top().first &lt;&lt; ' ' &lt;&lt; a.top().second &lt;&lt; '\\n';//first代表第一个,second代表最后一个，它们代表数组里的两个值 a.pop(); } return 0; } /* top 访问队头元素 empty 队列是否为空 size 返回队列内元素个数 push 插入元素到队尾 (并排序) emplace 原地构造一个元素并插入队列 pop 弹出队头元素 swap 交换内容 */ 利用黑盒解决问题2，代码： void sortArr(vector&lt;int&gt; &amp;arr, int k) { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap; int index = 0; int len = arr.size(); for (; index &lt; min(len, k); index++) { heap.push(arr[index]); } int i = 0; for (; index &lt; len; i++, index++) { heap.push(arr[index]); arr[i] = heap.top(); } while (!heap.empty()) { arr[i++] = heap.top(); } } 比较器：给定数据调用语言内部的比较器sort，默认就会用快速排序来排。 代码： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; bool complare(int a,int b) { return a&gt;b; } int main() { int arr[] = {5, 4, 9, 1, 6, 2}; int len = sizeof(arr) / sizeof(arr[0]); //sort(arr, arr + len); //默认从小到大 // sort(arr,arr+len,greater&lt;int&gt;());//从大到小 //sort(str, str + 10, greater&lt;char&gt;());//对字符串从大到小排序 sort(arr,arr+len,complare);//通过在方法里改变函数的返回值也可以实现从大到小排序 return 0; } day05 桶排序 找到数组里位数最多的那个数，然后把数组里其它数通过在前面补零的方式让它们的位数跟数组里位数最多的那位数位数相等，然后准备跟位数里最大值一样多的桶(容器)，第一遍按个位数开始装桶，比如 100 就装进零号桶，072 就装进2号桶，017 就装进 7 号桶，当全部装完后就从左往右把桶里的数重新放进数组里，比如 0 号桶是 100 ， 2 号桶是 072 ， 3 号桶是 013 ，那么倒出来就是【 100，072，013 】，又比如2号桶装了两个数分别是 072 和 012 ，那么就按从上往下的顺序倒：【 100，072，012，013 】，当倒完个位数后就从十位数开始重新进桶，然后再从桶倒出到数组，然后再按百位数进桶再出桶，当最后一个位数出桶后数组就变成有序，因为是从左往右出桶，所以是从小到大 代码： void fun(vector&lt;int&gt; &amp;arr) { if (arr.size() &lt; 2) { return; } radixSort(arr, 0, arr.size() - 1, maxbits(arr)); } int maxbits(vector&lt;int&gt; &amp;arr) { int maxs = INT_MIN; for (int i = 0; i &lt; arr.size(); i++) { maxs = max(maxs, arr[i]); } int res = 0; //这里res=res==0?1:res;否则最大数是0的时候就会有问题 while (maxs != 0) { res++; maxs /= 10; } return res; } //实现1~17范围上排序 void radixSort(vector&lt;int&gt; &amp;arr, int L, int R, int digit) // digit代表这一批数的最大值 { const int radix = 10; int i = 0, j = 0; vector&lt;int&gt; bucket(R - L + 1); for (int d = 1; d &lt;= digit; d++) { vector&lt;int&gt; count(radix); for (i = L; i &lt;= R; i++) { j = getDigit(arr[i], d); count[j]++; } for (i = 1; i &lt; radix; i++) { count[i] = count[i] + count[i - 1]; } for (i = R; i &gt;= L; i--) { j = getDigit(arr[i], d); bucket[count[j] - 1] = arr[i]; count[j]--; } for (i = L, j = 0; i &lt;= R; i++, j++) { arr[i] = bucket[j]; } } } int getDigit(int x, int d) { return ((x / ((int)pow(10, d - 1))) % 10); } 排序总结： 插入排序： 插入的时候，比左边小，那么就跟左边交换，如果相等不交换，那么也做到了稳定性。 归并排序： 在拷贝数到help数组的时候如果相等先拷贝左边的就能够实现稳定，之前小和问题先拷贝的右边的就不能实现稳定。 快排和堆排不能实现稳定，桶排序和冒泡可以。 排序算法时间复杂度总结： 快排是最快的排序算法 排序算法中常见的坑： 排序算法优化： 在样本小的时候直接执行插入排序，当样本量大的时候才执行其他log * n的排序如快排，归并 另外希尔排序就是优化后的插入排序。 day06 链表——哈希表： c++中叫：UnOrderedMap，unordered_map","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://yswm-m.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"学习","slug":"学习","permalink":"https://yswm-m.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"C++_STL案例","slug":"32-C++_STL案例","date":"2022-09-15T02:27:00.000Z","updated":"2022-09-28T09:49:39.462Z","comments":true,"path":"posts/32.html","link":"","permalink":"https://yswm-m.github.io/posts/32.html","excerpt":"","text":"更多教程笔记请查看我的上一篇文章：点击跳转 c++自学之旅3.0（STL模板）开始！ 本次将使用所学过的C++STL模板写两个小案例练习 评委打分员工分组案例1-评委打分 //案例-评委打分 #include &lt;iostream&gt; using namespace std; #include &lt;deque&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;string&gt; //加随机数种子需要的头文件 #include &lt;time.h&gt; //对5名选手打分,去除最高分,去除最低分,取平均分 class Person { public: Person(string name, int score) { this-&gt;m_Name = name; this-&gt;m_Score = score; } //姓名 string m_Name; //平均分 int m_Score; }; void createPerson(vector&lt;Person&gt; &amp;v) { string nameSeed = \"ABCDE\"; for (int i = 0; i &lt; 5; i++) { //通过字符串拼接对名称赋值 string name = \"player\"; name += nameSeed[i]; //分数默认为0 int score = 0; Person p(name, score); //将创建的person对象,放入到容器中 v.push_back(p); } } //输出 void printVector(vector&lt;Person&gt; &amp;v) { cout &lt;&lt; \"avg: \" &lt;&lt; endl; for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; \"name: \" &lt;&lt; (*it).m_Name &lt;&lt; \" score: \" &lt;&lt; (*it).m_Score &lt;&lt; endl; } } //打分 void setScore(vector&lt;Person&gt; &amp;v) { for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) { //将评委的分数放入到deque容器中 deque&lt;int&gt; d; for (int i = 0; i &lt; 10; i++) { // 随机数:60~100 int score = rand() % 41 + 60; d.push_back(score); } cout &lt;&lt; \"player: \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" score: \" &lt;&lt; it-&gt;m_Score &lt;&lt; endl; //输出每个评委给的分数 for (deque&lt;int&gt;::iterator sit = d.begin(); sit != d.end(); sit++) { cout &lt;&lt; *sit &lt;&lt; \" \"; } cout &lt;&lt; endl; cout &lt;&lt; \"------------------------------------\" &lt;&lt; endl; //先排序,再去除最高分和最低分 sort(d.begin(), d.end()); //去除最高 d.pop_back(); //去除最低 d.pop_front(); //取平均分 int sum = 0; for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++) { //累加每个评委的分数 sum += *dit; } int avg = sum / d.size(); //将平均分赋值给选手 it-&gt;m_Score = avg; } } int main() { //随机数种子,加了后就可以让随机数根据时间进行改变 srand((unsigned int)time(NULL)); //存放5名选手的容器 vector&lt;Person&gt; v; //创建5名选手 createPerson(v); //打印 // printVector(v); //给5个选手打分 setScore(v); //输出每个选手最后的得分 printVector(v); return 0; }案例2–员工分组 //案例2--员工分组 #include &lt;iostream&gt; using namespace std; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;string&gt; #include &lt;ctime&gt; //给予不同的部门编号 // 0是策划 #define CEHUA 0 // 1是美术 #define MEISHU 1 // 2是研发 #define YANFA 2 //随机给10名员工分配部门和工资 class Worker { public: //员工姓名 string m_Name; //员工年龄 int m_Salary; }; void createWorker(vector&lt;Worker&gt; &amp;v) { string nameSeed = \"ABCDEFGHIJ\"; for (int i = 0; i &lt; 10; i++) { //创建一个员工 Worker worker; worker.m_Name = \"player\"; //这样的话每个员工的名字就都不一样了 worker.m_Name += nameSeed[i]; //工资,随机数 10000 ~ 19000 worker.m_Salary = rand() % 10000 + 10000; //将员工放入到容器中 v.push_back(worker); } } //员工分组 void setGroup(vector&lt;Worker&gt; &amp;v, multimap&lt;int, Worker&gt; &amp;m) { for (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++) { //产生随机部门编号 0 1 2的随机数 int deptId = rand() % 3; //将员工插入到分组中 // key代表部门编号,value代表具体的人 m.insert(make_pair(deptId, *it)); } } void showWorkerByGourp(multimap&lt;int, Worker&gt; &amp;m) { cout &lt;&lt; \"chehua: \" &lt;&lt; endl; //通过find找到策划部门的起始位置 multimap&lt;int, Worker&gt;::iterator pos = m.find(CEHUA); //统计策划部门有多少个人 int count = m.count(CEHUA); int index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++) { cout &lt;&lt; \"name \" &lt;&lt; pos-&gt;second.m_Name &lt;&lt; \" salary: \" &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; } cout &lt;&lt; \"--------------------------------\" &lt;&lt; endl; cout &lt;&lt; \"meisu: \" &lt;&lt; endl; pos = m.find(MEISHU); //统计美术部门有多少个人 count = m.count(MEISHU); index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++) { cout &lt;&lt; \"name \" &lt;&lt; pos-&gt;second.m_Name &lt;&lt; \" salary: \" &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; } cout &lt;&lt; \"--------------------------------\" &lt;&lt; endl; cout &lt;&lt; \"yanfa: \" &lt;&lt; endl; pos = m.find(YANFA); //统计美术部门有多少个人 count = m.count(YANFA); index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++) { cout &lt;&lt; \"name \" &lt;&lt; pos-&gt;second.m_Name &lt;&lt; \" salary: \" &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; } } int main() { //创建随机数种子 srand((unsigned int)time(NULL)); //创建员工 vector&lt;Worker&gt; vWorker; //创建 createWorker(vWorker); //员工分组 // multimap容器可以存放相同的key值 multimap&lt;int, Worker&gt; mWorker; //因为要把分组的信息插入到分组函数中,所以需要map setGroup(vWorker, mWorker); //分组显示员工 showWorkerByGourp(mWorker); //测试 // for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++) // { // cout &lt;&lt; \"name: \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" salary: \" &lt;&lt; it-&gt;m_Salary &lt;&lt; endl; // } return 0; }","categories":[{"name":"C++","slug":"C","permalink":"https://yswm-m.github.io/categories/C/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"学习","slug":"学习","permalink":"https://yswm-m.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"笔记","slug":"笔记","permalink":"https://yswm-m.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"C++自学笔记3.0（STL模板）","slug":"31-C++自学笔记3.0（STL模板）","date":"2022-09-15T02:16:00.000Z","updated":"2022-09-28T09:46:32.929Z","comments":true,"path":"posts/31.html","link":"","permalink":"https://yswm-m.github.io/posts/31.html","excerpt":"","text":"更多教程笔记请查看我的上一篇文章：点击跳转 C++自学之旅3.0（STL模板）开始！ 下面介绍的是algorithm这个C++内置的算法函数模板 algorithm： for_eachtransformfindfind_ifadjacent_findbinary_searchcountcount_ifsortrandom_shufflemergereversecopyreplacereplace_ifswapset_intersectionset_unionset_differencefor_each遍历算法 // algorithm算法模板-for_each #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;vector&gt; //普通函数 // for_each会不断的调用这个函数进行输出,这里用到了函数指针 void print01(int val) { cout &lt;&lt; val &lt;&lt; \" \"; } //仿函数 class Print02 { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; } }; void test01() { //常用遍历算法 for_each vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) { v.push_back(i); } //遍历,前两个参数是要遍历的容器区间,第三个参数可以是函数也可以是仿函数的函数对象 for_each(v.begin(), v.end(), print01); cout &lt;&lt; endl; //传入的是仿函数的匿名对象 for_each(v.begin(), v.end(), Print02()); } int main() { test01(); return 0; }transform搬运算法 // algorithm算法模板-transform #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;vector&gt; class Transform { public: //因为操作的是vector里int类型的数据,所以要返回int类型 int operator()(int v) { // return v; //可以在搬运过程中加上逻辑运算让结果不一样 return v + 100; } }; class Myprint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; } }; void test01() { vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) { v.push_back(i); } //目标容器 vector&lt;int&gt; vTarget; //重新指定容量,目标容器必须大于原容器 vTarget.resize(v.size()); //利用transform将第一个容器搬运到第二个容器,最后一个参数是匿名对象 transform(v.begin(), v.end(), vTarget.begin(), Transform()); //输出 for_each(vTarget.begin(), vTarget.end(), Myprint()); cout &lt;&lt; endl; } int main() { test01(); return 0; }find查找算法 // algorithm算法模板-find查找算法 #include &lt;iostream&gt; using namespace std; //使用find需要包含algorithm头文件 #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; void printVector(vector&lt;int&gt; &amp;v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } //查找内置的数据类型 void test01() { vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) { v.push_back(i); } //查找容器中是否有5这个元素,前两个参数是容器区间,第三个参数是要查找的值 //返回的是一个容器的迭代器 vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5); //如果it指向容器的尾指针则表示没有找到这个元素 if (it == v.end()) { //查找失败 cout &lt;&lt; \"find NULL!\" &lt;&lt; endl; } else { //查找成功 cout &lt;&lt; \"find success!\" &lt;&lt; *it &lt;&lt; endl; } // printVector(v); } //查找自定义的数据类型 class Person { public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } //重载operator==符号,让find知道如何查找Person的数据类型 // const是为了防止它修改底层代码 bool operator==(const Person &amp;p) { //如果名字和年龄都相等那么就是要找的那个数 if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) { return true; } else { return false; } } string m_Name; int m_Age; }; void test02() { vector&lt;Person&gt; v; //创建数据 Person p1(\"aaa\", 10); Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); Person p4(\"ddd\", 40); //将数据放入到容器中 v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); Person pp(\"bbb\", 20); //查找容器里面是否有p2这个对象 //知识点 自定义数据类型不能直接比较需要重载 // vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2); //或者直接创建一个一样的其他对象进行比较 vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), pp); if (it == v.end()) { cout &lt;&lt; \"find NULL\" &lt;&lt; endl; } else { cout &lt;&lt; \"find success! name: \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" age: \" &lt;&lt; it-&gt;m_Age &lt;&lt; endl; } } int main() { // test01(); test02(); return 0; }find_if查找算法 // algorithm算法模板-find_if查找算法 #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;string&gt; //仿函数 class GreaterFive { public: bool operator()(int val) { return val &gt; 5; } }; //查找内置的数据类型 void test01() { vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) { v.push_back(i); } //查找容器里大于5的数,前两个参数是容器的区间,第三个参数是函数对象 //返回的是容器的迭代器 vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); //如果it等于尾指针就是没有找到 if (it == v.end()) { //没有找到 cout &lt;&lt; \"find NULL\" &lt;&lt; endl; } else { //找到了! cout &lt;&lt; \"find success!\" &lt;&lt; endl; for (; it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } } } //查找自定义的数据类型 class Person { public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } string m_Name; int m_Age; }; class Greater20 { public: bool operator()(Person &amp;p) { return p.m_Age &gt; 20; } }; void test02() { vector&lt;Person&gt; v; //创建数据 Person p1(\"aaa\", 10); Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); Person p4(\"ddd\", 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); //查找容器中年龄大于20的对象 vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20()); if (it == v.end()) { cout &lt;&lt; \"find NULL!\" &lt;&lt; endl; } else { cout &lt;&lt; \"find success!\" &lt;&lt; endl; for (; it != v.end(); it++) { cout &lt;&lt; \"name: \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" age: \" &lt;&lt; it-&gt;m_Age &lt;&lt; endl; } } } int main() { // test01(); test02(); return 0; }adjacent_find查找算法 // algorithm算法模板-adjacent_find查找算法 #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;string&gt; void test01() { // adjacent_find作用是查找相邻的重复元素 vector&lt;int&gt; v; v.push_back(0); v.push_back(2); v.push_back(0); v.push_back(3); v.push_back(1); v.push_back(4); v.push_back(3); v.push_back(3); //查找相邻的重复元素,返回的是一个容器的迭代器 vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end()); //如果it等于尾指针则表示查找失败 if (it == v.end()) { cout &lt;&lt; \"find NULL!\" &lt;&lt; endl; } else { //查找成功 cout &lt;&lt; \"find success!\" &lt;&lt; endl; for (; it != v.end(); it++) { // 3 3 cout &lt;&lt; *it &lt;&lt; endl; } } } int main() { test01(); return 0; }binary_search二分查找算法 // algorithm算法模板-binary_search二分查找算法 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; //常用的查找算法 binary_search void test01() { vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) { v.push_back(i); } //查找容器中是否有9这个元素,前两个参数是容器的区间,第三个参数是要查找的值 //返回的是一个bool类型 //注意容器这里必须是有序且升序排序的序列，不可以是降序的 //降序的话可以使用重载版本，在后面添加greater&lt;int&gt;()这个仿函数 bool ret = binary_search(v.begin(), v.end(), 9); //如果找到了就为真,未找到为假 if (ret) { cout &lt;&lt; \"find success!\" &lt;&lt; endl; } else { cout &lt;&lt; \"find NULL!\" &lt;&lt; endl; } } int main() { test01(); return 0; }count统计查找算法 // algorithm算法模板-count统计查找算法 #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;vector&gt; //统计内置数据类型 void test01() { vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) { for (int j = 10; j &gt;= i; j--) { v.push_back(j); } } //利用count统计出容器中4的元素个数 //返回值是一个整型 int num = count(v.begin(), v.end(), 4); cout &lt;&lt; \"4 num: \" &lt;&lt; num &lt;&lt; endl; } //统计自定义的数据类型 class Person { public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } //统计自定义的数据类型时需要仿函数operator重载==号,返回类型是bool //注意:为了防止修改底层代码需要加const bool operator==(const Person &amp;p) { if (this-&gt;m_Age == p.m_Age) { return true; } else { return false; } } string m_Name; int m_Age; }; void test02() { vector&lt;Person&gt; v; Person p1(\"aaa\", 35); Person p2(\"bbb\", 35); Person p3(\"ccc\", 35); Person p4(\"ddd\", 30); Person p5(\"eee\", 40); Person p(\"vvv\", 35); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); //统计与p年龄相同的人有多少个 //注意:统计自定义的数据类型时需要仿函数operator重载==号 int num = count(v.begin(), v.end(), p); cout &lt;&lt; \"and vvv age num: \" &lt;&lt; num &lt;&lt; endl; } int main() { // test01(); test02(); return 0; }count_if统计查找算法 // algorithm算法模板-count_if统计查找算法 #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;vector&gt; //统计内置的数据类型 class Greater20 { public: //仿函数 bool operator()(int val) { return val &gt; 20; } }; void test01() { vector&lt;int&gt; v; v.push_back(10); v.push_back(40); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(20); //查找容器里有多少个大于20的数,前两个参数是容器的区间,第三个参数是仿函数的函数对象 //返回值是一个int类型 int num = count_if(v.begin(), v.end(), Greater20()); cout &lt;&lt; \"&gt;20 num: \" &lt;&lt; num &lt;&lt; endl; } //统计自定义的数据类型 class Person { public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } string m_Name; int m_Age; }; //创建谓词供count_if使用 class AgeGreater20 { public: bool operator()(const Person &amp;p) { return p.m_Age &gt; 20; } }; void test02() { vector&lt;Person&gt; v; Person p1(\"aaa\", 35); Person p2(\"bbb\", 35); Person p3(\"ccc\", 35); Person p4(\"ddd\", 40); Person p5(\"eee\", 20); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); //统计 年龄大于20的人员个数 传入的是一个仿函数的匿名函数对象 int num = count_if(v.begin(), v.end(), AgeGreater20()); cout &lt;&lt; \"&gt;20 age num: \" &lt;&lt; num &lt;&lt; endl; } int main() { // test01(); test02(); return 0; }sort排序算法 // algorithm算法模板-sort排序算法 #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;functional&gt; void myPrint(int val) { cout &lt;&lt; val &lt;&lt; \" \"; } void test01() { vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); //利用sort进行升序 sort(v.begin(), v.end()); //打印 for_each(v.begin(), v.end(), myPrint); cout &lt;&lt; endl; //利用sort仿函数进行降序 sort(v.begin(), v.end(), greater&lt;int&gt;()); //打印 for_each(v.begin(), v.end(), myPrint); cout &lt;&lt; endl; } int main() { test01(); return 0; }random_shuffle洗牌算法 // algorithm算法模板-random_shuffle洗牌算法 #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;ctime&gt; void myPrint(int val) { cout &lt;&lt; val &lt;&lt; \" \"; } void test01() { //加上随机数种子,这样洗牌就不会每次都相同 srand((unsigned int)time(NULL)); vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) { v.push_back(i); } //利用洗牌算法打乱容器中数据的顺序 random_shuffle(v.begin(), v.end()); //输出 for_each(v.begin(), v.end(), myPrint); cout &lt;&lt; endl; } int main() { test01(); return 0; }merge合并排序算法 // algorithm算法模板-merge合并排序算法 #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;vector&gt; void myPrint(int val) { cout &lt;&lt; val &lt;&lt; \" \"; } void test01() { vector&lt;int&gt; v1; vector&lt;int&gt; v2; //注意:使用merge时合并的两个容器必须是有序序列 for (int i = 0; i &lt; 10; i++) { v1.push_back(i); v2.push_back(i + 1); } //目标容器,将上面两个容器放入目标容器中 vector&lt;int&gt; vTarget; //要将目标容器的大小扩大到上面两个容器合并的大小 vTarget.resize(v1.size() + v2.size()); //前四个参数是两个容器的区间,第五个参数是目标容器的头部 //当两个容器合并后会自动按升序排序 //如果要合并后降序排序需要在第六个参数加greater&lt;int&gt;() merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); //输出 for_each(vTarget.begin(), vTarget.end(), myPrint); cout &lt;&lt; endl; } int main() { test01(); return 0; }reverse反转算法 // algorithm算法模板-reverse反转算法 #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;vector&gt; void myPrint(int val) { cout &lt;&lt; val &lt;&lt; \" \"; } void test01() { vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); //反转前 cout &lt;&lt; \"open: \" &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint); cout &lt;&lt; endl; //反转,传递的是容器的区间 reverse(v.begin(), v.end()); //反转后 cout &lt;&lt; \"end: \" &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint); } int main() { test01(); return 0; }copy拷贝算法 // algorithm算法模板-copy拷贝算法 #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;vector&gt; void myPrint(int val) { cout &lt;&lt; val &lt;&lt; \" \"; } void test01() { vector&lt;int&gt; v1; v1.push_back(10); v1.push_back(30); v1.push_back(50); v1.push_back(20); v1.push_back(40); vector&lt;int&gt; v2; //在拷贝前目标容器要开辟空间 v2.resize(v1.size()); //拷贝前 cout &lt;&lt; \"open: \" &lt;&lt; endl; for_each(v2.begin(), v2.end(), myPrint); cout &lt;&lt; endl; //拷贝,前两个参数传递的是容器的区间,第三个参数是目标容器的头部 copy(v1.begin(), v1.end(), v2.begin()); //拷贝后 cout &lt;&lt; \"end: \" &lt;&lt; endl; for_each(v2.begin(), v2.end(), myPrint); } int main() { test01(); return 0; }replace替换算法 // algorithm算法模板-replace替换算法 #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; } }; void test01() { vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); v.push_back(10); v.push_back(20); //替换前 cout &lt;&lt; \"open: \" &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //替换,前两个参数传递的是容器的区间,第三个参数是要被替换的数值,第四个参数是要替换的数值 //将容器的区间内部所有的20替换为2000 replace(v.begin(), v.end(), 20, 2000); //替换后 cout &lt;&lt; \"end: \" &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); } int main() { test01(); return 0; }replace_if指定替换算法 // algorithm算法模板-replace_if指定替换算法 #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; } }; //写一个谓词当作判断条件 class Greater30 { public: bool operator()(int val) { return val &gt;= 30; } }; void test01() { vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); v.push_back(10); v.push_back(20); //替换前 cout &lt;&lt; \"open: \" &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //替换,前两个参数传递的是容器的区间,第三个参数是要被替换的仿函数规则(谓词),第四个参数是要替换的数值 //将容器的区间内部所有大于等于30的数 替换为3000 replace_if(v.begin(), v.end(), Greater30(), 3000); //替换后 cout &lt;&lt; \"end: \" &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); } int main() { test01(); return 0; }swap交换算法 // algorithm算法模板-swap交换算法 #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; } }; void test01() { vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); v2.push_back(i + 100); } //交换前 cout &lt;&lt; \"open: \" &lt;&lt; endl; cout &lt;&lt; \"v1: \" &lt;&lt; endl; for_each(v1.begin(), v1.end(), myPrint()); cout &lt;&lt; endl; cout &lt;&lt; \"v2: \" &lt;&lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl; //交换,注意:在交换时两个容器的类型必须相同 swap(v1, v2); //交换后 cout &lt;&lt; \"--------------------------------------\" &lt;&lt; endl; cout &lt;&lt; \"end: \" &lt;&lt; endl; cout &lt;&lt; \"v1: \" &lt;&lt; endl; for_each(v1.begin(), v1.end(), myPrint()); cout &lt;&lt; endl; cout &lt;&lt; \"v2: \" &lt;&lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl; } int main() { test01(); return 0; }set_intersection交集算法 // algorithm算法模板-set_intersection交集算法 #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; } }; void test01() { //所谓交集就是两个容器中相同的部分 //注意:两个容器必须是有序的 vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); // 0~9 v2.push_back(i + 5); // 5~14 } //将两个容器的交集部分存入到第三个容器中 vector&lt;int&gt; vTarget; //需要提前指定大小 //最坏的情况 大容器包含小容器 开辟空间 取小容器的size即可 vTarget.resize(min(v1.size(), v2.size())); //获取交集,前四个参数是两个容器的区间,第五个参数是目标容器的头部 //返回值是一个迭代器,itEnd指向的是重复的最后位置，但是容器没完，后面还有初始化的0 vector&lt;int&gt;::iterator itEnd = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); //输出 用itend 就不会出现剩余的空间补0，其实不是不补0而是没有遍历到后面的0 for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl; } int main() { test01(); return 0; }set_union并集算法 // algorithm算法模板-set_union并集算法 #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; } }; void test01() { //所谓并集就是两个容器中不相同的部分,如果有相同的部分会优先去掉另一个相同的部分 //只保留一个原来的相同的部分 //注意:两个容器必须是有序的 vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); // 0~9 v2.push_back(i + 5); // 5~14 } //将两个容器的并集部分存入到第三个容器中 vector&lt;int&gt; vTarget; //需要提前指定大小 //最坏的情况 两个容器没有交集 并集就是两个容器相加 vTarget.resize(v1.size() + v2.size()); //获取并集,前四个参数是两个容器的区间,第五个参数是目标容器的头部 //返回值是一个容器的迭代器,指向目标容器的并集的最后部分 vector&lt;int&gt;::iterator it = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); //输出 用it 就不会出现剩余的空间补0，其实不是不补0而是没有遍历到后面的0 for_each(vTarget.begin(), it, myPrint()); cout &lt;&lt; endl; } int main() { test01(); return 0; }set_difference差集算法 // algorithm算法模板-set_difference差集算法 #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; } }; void test01() { //所谓差集就是两个容器中不相同(不属于交集)的部分 //按照顺序如果是v1和v2的差集那就只保留v1中和v2不同的部分 //如果是v2和v1的差集那就只保留v2中和v1不同的部分,也就是: // v1和v2的差集:0 1 2 3 4 // v2和v1的差集: 10 11 12 13 14 //它们各自都把相同的部分去掉了,只保留自身 vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); // 0~9 v2.push_back(i + 5); // 5~14 } //将两个容器的差集部分存入到第三个容器中 vector&lt;int&gt; vTarget; //需要提前指定大小 //最坏的情况 两个容器没有交集 要取两个容器中大的size作为目标容器开辟的空间 vTarget.resize(max(v1.size(), v2.size())); // v1和v2的差集为: cout &lt;&lt; \"v1 n v2: \" &lt;&lt; endl; //获取差集,前四个参数是两个容器的区间,第五个参数是目标容器的头部 //返回值是一个容器的迭代器,指向目标容器的差集的结束位置 vector&lt;int&gt;::iterator it = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); //输出 用it 就不会出现剩余的空间补0，其实不是不补0而是没有遍历到后面的0 for_each(vTarget.begin(), it, myPrint()); cout &lt;&lt; endl; // v2和v1的差集为: cout &lt;&lt; \"v2 n v1: \" &lt;&lt; endl; //获取差集,前四个参数是两个容器的区间,第五个参数是目标容器的头部 //返回值是一个容器的迭代器,指向目标容器的差集的结束位置 it = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin()); //输出 用it 就不会出现剩余的空间补0，其实不是不补0而是没有遍历到后面的0 for_each(vTarget.begin(), it, myPrint()); cout &lt;&lt; endl; } int main() { test01(); return 0; } 下面介绍的是vector这个C++内置的动态数组容器 vector： 用法操作对象嵌套实战重载指定大小插入和删除at访问元素收缩内存预留空间vector的用法 // vector的用法 #include &lt;iostream&gt; using namespace std; //用vector的容器需要包含这个头文件 #include &lt;vector&gt; //用其他的STL模板算法需要包含这个头文件 #include &lt;algorithm&gt; void myPrint(int val) { cout &lt;&lt; val &lt;&lt; \" \"; } void test01() { //&lt;&gt;括号里面是要操作的数据类型 vector&lt;int&gt; arr; //从尾部插入数据 arr.push_back(10); arr.push_back(20); arr.push_back(30); arr.push_back(40); //通过迭代器访问容器中的数据,arr.begin()指向容器中的第一个元素 vector&lt;int&gt;::iterator itBegin = arr.begin(); // arr.end()指向容器中的最后一个元素的下一个位置 vector&lt;int&gt;::iterator itEnd = arr.end(); //第一种遍历方式: // while (itBegin != itEnd) // { // cout &lt;&lt; *itBegin &lt;&lt; \" \"; // itBegin++; // } //第二种遍历方式 // for (vector&lt;int&gt;::iterator it = arr.begin(); it != arr.end(); it++) // { // cout &lt;&lt; *it &lt;&lt; \" \"; // } //第三种遍历方式,用algorithm里面提供的模板 //第一个参数是数组的起始位置,第二个参数是数组的结束位置,第三个参数是自定义的函数名 //在遍历的时候它会不停的调用这个函数,向这个函数传参数,再在函数里面进行输出 for_each(arr.begin(), arr.end(), myPrint); } int main() { test01(); return 0; }vector操作自定义的数据类型 // vector操作自定义的数据类型 #include &lt;iostream&gt; using namespace std; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; //自定义一个Person的数据类型 class Person { public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } string m_Name; int m_Age; }; void test01() { Person p1(\"aaa\", 10); Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); Person p4(\"ddd\", 40); Person p5(\"eee\", 50); vector&lt;Person&gt; v; //通过尾插的方式插入自定义的数据类型 v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); //遍历容器中的数据 for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) { //迭代器指向的是一个对象,所以可以用对象的方式获得属性 // cout &lt;&lt; \"name: \" &lt;&lt; (*it).m_Name &lt;&lt; \" age: \" &lt;&lt; (*it).m_Age &lt;&lt; endl; //因为it本身就是一个指针,所以可以通过指针的方式直接访问对象里的属性 cout &lt;&lt; \"name: \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" age: \" &lt;&lt; it-&gt;m_Age &lt;&lt; endl; } } void test02() { Person p1(\"aaa\", 10); Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); Person p4(\"ddd\", 40); Person p5(\"eee\", 50); //第二种方式:存放自定义数据类型的指针 vector&lt;Person *&gt; v; //通过尾插的方式插入自定义的数据类型的地址 v.push_back(&amp;p1); v.push_back(&amp;p2); v.push_back(&amp;p3); v.push_back(&amp;p4); v.push_back(&amp;p5); //遍历容器 for (vector&lt;Person *&gt;::iterator it = v.begin(); it != v.end(); it++) { //因为it是一个指针类型的迭代器,而指针类型的迭代器通过*解引用的方式解出来的是一个存放着对象地址的指针,所以还要通过指针的方式去访问对象里面的属性 cout &lt;&lt; \"name: \" &lt;&lt; (*it)-&gt;m_Name &lt;&lt; \" age: \" &lt;&lt; (*it)-&gt;m_Age &lt;&lt; endl; } } int main() { // test01(); test02(); return 0; }vector嵌套vector // vector嵌套vector #include &lt;iostream&gt; using namespace std; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; void test01() { //其实也是相当于一个数组里面存放着多个其他数组,可以看作是二维数组 vector&lt;vector&lt;int&gt;&gt; v; //创建一个小容器 vector&lt;int&gt; v1; vector&lt;int&gt; v2; vector&lt;int&gt; v3; vector&lt;int&gt; v4; //向小容器中添加数据 for (int i = 0; i &lt; 4; i++) { v1.push_back(i + 1); v2.push_back(i + 2); v3.push_back(i + 3); v4.push_back(i + 4); } //将小容器插入到大的容器中 v.push_back(v1); v.push_back(v2); v.push_back(v3); v.push_back(v4); //通过大容器把小容器中的所有数据都遍历一遍 for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) { //(*it)----vector&lt;int&gt; 当it解引用后出来的是小容器,所以还要遍历一遍小容器 for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) { // vit---vector&lt;int&gt; v1[0] 此时vie就等于小容器里面的首地址,通过解引用的方式拿到数组里面的值 //当一层循环遍历完了后也就是把大容器中的第一个数组遍历完了,然后就会遍历下一个数组 cout &lt;&lt; *vit &lt;&lt; \" \"; } cout &lt;&lt; endl; } } int main() { test01(); return 0; }vector实战 // vector实战 #include &lt;iostream&gt; using namespace std; #include &lt;vector&gt; //输出 void printVector(vector&lt;int&gt; &amp;v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { //默认构造 无参构造 vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); } printVector(v1); //通过区间的方式进行构造,也就是把v1中从第1号位置到倒数第1号位置之间的全部数据复制到v2中 vector&lt;int&gt; v2(v1.begin(), v1.end()); printVector(v2); //通过elem方式构造,也就是把10个100赋值给v3 vector&lt;int&gt; v3(10, 100); printVector(v3); //拷贝构造,将v3中的内容拷贝到v4中 vector&lt;int&gt; v4(v3); printVector(v4); } int main() { test01(); return 0; }vector函数重载 #include &lt;iostream&gt; using namespace std; #include &lt;vector&gt; void printVector(vector&lt;int&gt; &amp;v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); } printVector(v1); //赋值 operator= vector&lt;int&gt; v2; //其底层是函数重载,将v1的内容赋值给v2 v2 = v1; printVector(v2); // assign vector&lt;int&gt; v3; //通过成员函数assign,将v1区间里的内容复制到v3中 v3.assign(v1.begin(), v1.end()); printVector(v3); // n个elem方式赋值 vector&lt;int&gt; v4; //将10个100赋值到v4中 v4.assign(10, 100); printVector(v4); } int main() { test01(); return 0; }vector指定大小 #include &lt;iostream&gt; using namespace std; #include &lt;vector&gt; void printVector(vector&lt;int&gt; &amp;v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); } printVector(v1); //为真,代表容器为空 if (v1.empty()) { cout &lt;&lt; \"v1 NULL\" &lt;&lt; endl; } else { //容器不为空 cout &lt;&lt; \"v1 not NULL\" &lt;&lt; endl; //输出数组的容量,容量机制是快要插满时就扩展至原来的1.5倍 cout &lt;&lt; \"v1 area: \" &lt;&lt; v1.capacity() &lt;&lt; endl; //输出数组的长度 cout &lt;&lt; \"v1 size:\" &lt;&lt; v1.size() &lt;&lt; endl; } //重新指定大小,会默认用0来填充数组剩余的位置 // v1.resize(15); //也可以用100或者其他数替换0的位置作为填充值 v1.resize(15, 100); printVector(v1); //如果重新指定的比原来短了,超出部分会删除掉 v1.resize(5); printVector(v1); } int main() { test01(); return 0; }vector插入和删除 #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; #include &lt;vector&gt; void printVector(vector&lt;int&gt; &amp;v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { vector&lt;int&gt; v1; v1.push_back(10); v1.push_back(20); v1.push_back(30); v1.push_back(40); v1.push_back(50); printVector(v1); //尾删 v1.pop_back(); printVector(v1); //插入,在头部最前面插入一个100 v1.insert(v1.begin(), 100); printVector(v1); //利用重载的版本,在头部最前面插入2个1000 v1.insert(v1.begin(), 2, 1000); printVector(v1); //删除,删除最前面头部的元素 v1.erase(v1.begin()); printVector(v1); //利用重载的版本,将数组从开始到结束区间的所有数据全部删除 // v1.erase(v1.begin(), v1.end()); //清空,效果和上面一样 // v1.clear(); //删除倒数第二个位置上的元素 v1.erase(v1.end() - 2); //删除中间位置的元素 v1.erase(v1.begin() + v1.size() / 2); printVector(v1); } int main() { test01(); return 0; }vector用at的方式访问元素 // vector实战 #include &lt;iostream&gt; using namespace std; #include &lt;vector&gt; void test01() { vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); } //利用[]符号的方式访问数组中的元素,其底层是重载[] for (int i = 0; i &lt; v1.size(); i++) { cout &lt;&lt; v1[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; //利用at方式访问元素 for (int i = 0; i &lt; v1.size(); i++) { cout &lt;&lt; v1.at(i) &lt;&lt; \" \"; } cout &lt;&lt; endl; //利用front成员函数,获取第一个元素 cout &lt;&lt; \"one: \" &lt;&lt; v1.front() &lt;&lt; endl; //利用back成员函数,获取最后一个元素 cout &lt;&lt; \"end: \" &lt;&lt; v1.back() &lt;&lt; endl; } int main() { test01(); return 0; }vector巧用swap收缩内存 // vector实战 #include &lt;iostream&gt; using namespace std; #include &lt;vector&gt; void printVector(vector&lt;int&gt; &amp;v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); } //交换前 cout &lt;&lt; \"open:\" &lt;&lt; endl; printVector(v1); vector&lt;int&gt; v2; for (int i = 10; i &gt; 0; i--) { v2.push_back(i); } printVector(v2); //交换后 cout &lt;&lt; \"end:\" &lt;&lt; endl; //通过swap成员函数,把v1和v2的元素交换 v1.swap(v2); printVector(v1); printVector(v2); } // swap的调用时机 void test02() { vector&lt;int&gt; v; for (int i = 0; i &lt; 100000; i++) { v.push_back(i); } //输出容量 cout &lt;&lt; \"v area: \" &lt;&lt; v.capacity() &lt;&lt; endl; //输出长度 cout &lt;&lt; \"v size: \" &lt;&lt; v.size() &lt;&lt; endl; //重新指定大小 v.resize(3); //输出容量,重新指定大小后,容量并不会缩小,浪费空间 cout &lt;&lt; \"v area: \" &lt;&lt; v.capacity() &lt;&lt; endl; //输出长度 cout &lt;&lt; \"v size: \" &lt;&lt; v.size() &lt;&lt; endl; //巧用swap收缩内存 //利用拷贝构造创建一个匿名对象,让匿名对象和原本的数组进行交换 //在用完后匿名对象就自动释放了,然后原本的数组的容量就变成了匿名对象的容量 vector&lt;int&gt;(v).swap(v); //输出容量 cout &lt;&lt; \"v area: \" &lt;&lt; v.capacity() &lt;&lt; endl; //输出长度 cout &lt;&lt; \"v size: \" &lt;&lt; v.size() &lt;&lt; endl; } int main() { // test01(); test02(); return 0; }vector利用reverse预留空间 // vector实战 #include &lt;iostream&gt; using namespace std; #include &lt;vector&gt; void printVector(vector&lt;int&gt; &amp;v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { vector&lt;int&gt; v; //利用reserve预留空间 v.reserve(100000); //当利用reserve为动态数组预留了空间以后,编译器就不会自动开辟内存了,减少了内存的占用 //统计开辟的次数 int num = 0; int *p = NULL; for (int i = 0; i &lt; 100000; i++) { v.push_back(i); //因为内存不连续，所以就会挪地方。用头部指针来确定位置 if (p != &amp;v[0]) { //每次扩容释放原来的空间并重新申请空间，指针指向的地址就会和v[0]不同 p = &amp;v[0]; //所以在它重新开辟的时候判断指针就可以得到它开辟的次数 num++; } // Vector的扩容策略是找一块更大的空间复制原来的东西过去，所以首地址会变 } //如果没有利用reserve预留空间,那么编译器要new18次内存,但是预留了之后只需要new一次 cout &lt;&lt; \"num = \" &lt;&lt; num &lt;&lt; endl; //总结:如果一开始数据量比较大可以用reserve预留空间来减少编译器new的次数 } int main() { test01(); return 0; } 下面介绍的是string这个C++内置的字符串容器 string： 本质赋值操作字符串拼接查找和替换字符串比较字符存取插入和删除字符串截取string的本质 // string本质是一个类,底层是一个char*在维护 #include &lt;iostream&gt; using namespace std; //用string必须包含这个头文件 #include &lt;string&gt; #include &lt;algorithm&gt; void test01() { //默认构造 string s1; //可以用一个c语言风格的字符串来初始化string const char *str = \"hello,world\"; //有参构造 string s2(str); cout &lt;&lt; \"s2 = \" &lt;&lt; s2 &lt;&lt; endl; //拷贝构造 string s3(s2); cout &lt;&lt; \"s3 = \" &lt;&lt; s3 &lt;&lt; endl; //成员函数,其本质是复制10个字符a到数组中 string s4(10, 'a'); cout &lt;&lt; \"s4 = \" &lt;&lt; s4 &lt;&lt; endl; } int main() { test01(); return 0; }string的赋值操作 // string的赋值操作 #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;string&gt; void test01() { string str1; //正常赋值 str1 = \"hello,world\"; cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl; string str2; //拷贝构造,其底层利用的函数重载=号 str2 = str1; cout &lt;&lt; \"str2 = \" &lt;&lt; str2 &lt;&lt; endl; string str3; str3 = 'a'; cout &lt;&lt; \"str3 = \" &lt;&lt; str3 &lt;&lt; endl; string str4; //利用内置的模板函数赋值 str4.assign(\"hello C++\"); cout &lt;&lt; \"str4 = \" &lt;&lt; str4 &lt;&lt; endl; string str5; //将字符串的前5个字符拿过来保存到str5中 str5.assign(\"hello C++\", 5); cout &lt;&lt; \"str5 = \" &lt;&lt; str5 &lt;&lt; endl; string str6; //利用拷贝构造函数赋值 str6.assign(str5); cout &lt;&lt; \"str6 = \" &lt;&lt; str6 &lt;&lt; endl; string str7; //复制10个v字符到str7中 str7.assign(10, 'v'); cout &lt;&lt; \"str7 = \" &lt;&lt; str7 &lt;&lt; endl; } int main() { test01(); return 0; }string 字符串拼接 // string 字符串拼接 #include &lt;iostream&gt; using namespace std; #include &lt;algorithm&gt; #include &lt;string&gt; void test01() { string str1 = \"i\"; //通过+=号实现字符串拼接 str1 += \" love you\"; cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl; //追加字符 str1 += ':'; cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl; string str2 = \"LOL DNF\"; str1 += str2; cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl; string str3 = \"T\"; //通过成员函数拼接字符串 str3.append(\" Love \"); cout &lt;&lt; \"str3 = \" &lt;&lt; str3 &lt;&lt; endl; str3.append(\"game abcde\", 4); //将字符串中的前4个字符拼接到str3原本的字符串的后面 cout &lt;&lt; \"str3 = \" &lt;&lt; str3 &lt;&lt; endl; //将str2字符串中的内容追加到str3后面 // str3.append(str2); //将str2中从0号位置开始到3号位置结束的0~2下标的3个字符串截取到str3中 // str3.append(str2, 0, 3); //将str2中的从第4号位置开始(0~3)往后的3个字符截取到str3字符串中,参数1是从哪个位置开始截取,参数2是截取字符的个数 str3.append(str2, 4, 3); cout &lt;&lt; \"str3 = \" &lt;&lt; str3 &lt;&lt; endl; } int main() { test01(); return 0; }string的查找和替换 // string的查找和替换 #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; // 1.查找 void test01() { string str1 = \"abcdefgde\"; //查找str1字符串中有没有de这个字符串,从0号位置开始查找,返回值是一个下标 int pos = str1.find(\"de\"); //如果没有这个字符串存在就返回-1 if (pos == -1) { cout &lt;&lt; \"find error!\" &lt;&lt; endl; } else { // 3 返回的是字符第一次出现的位置 cout &lt;&lt; \"pos = \" &lt;&lt; pos &lt;&lt; endl; } // rfind和find的区别是:find是从左往右查,rfind是从右往左查 pos = str1.rfind(\"de\"); cout &lt;&lt; \"pos = \" &lt;&lt; pos &lt;&lt; endl; } // 2.替换 void test02() { string str1 = \"abcdefg\"; // replace替换函数,把从1号位置起,往后3个字符(bcd)替换成1111 str1.replace(1, 3, \"1111\"); // a1111efg cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl; } int main() { // test01(); test02(); return 0; }string字符串比较 // string字符串比较 #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; void test01() { //字符串比较是按ASCII进行比较的,一个一个字符的比 string str1 = \"hello\"; string str2 = \"xello\"; //调用成员函数进行比较,如果是相等则返回0 if (str1.compare(str2) == 0) { cout &lt;&lt; \"str1==str2\" &lt;&lt; endl; } else if (str1.compare(str2) &gt; 0) //这里的意思是说把str1的所有字符按ASCII值逐个跟str2进行比较,如果出现str1当中的某个ASCII值大于str2的情况则返回1 { cout &lt;&lt; \"str1&gt;str2\" &lt;&lt; endl; } else { cout &lt;&lt; \"str1&lt;str2\" &lt;&lt; endl; } } int main() { test01(); return 0; }string的字符存取 // string 字符存取 #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; void test01() { string str = \"hello\"; // cout &lt;&lt; \"str = \" &lt;&lt; str &lt;&lt; endl; // 1.通过[]访问单个字符,其底层是函数重载,size()获取字符串的长度 for (int i = 0; i &lt; str.size(); i++) { cout &lt;&lt; str[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; // 2.通过成员函数at的方式访问单个字符 for (int i = 0; i &lt; str.size(); i++) { cout &lt;&lt; str.at(i) &lt;&lt; \" \"; } cout &lt;&lt; endl; //修改单个字符,[]的方式 str[0] = 'x'; // xello cout &lt;&lt; \"str = \" &lt;&lt; str &lt;&lt; endl; //修改单个字符,at的方式: str.at(1) = 'x'; // xxllo cout &lt;&lt; \"str = \" &lt;&lt; str &lt;&lt; endl; } int main() { test01(); return 0; }string的插入和删除 // string的插入和删除 #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; void test01() { string str = \"hello\"; //插入,在第1号位置(e)的前面插入111 str.insert(1, \"111\"); // h111ello cout &lt;&lt; \"str = \" &lt;&lt; str &lt;&lt; endl; //删除,把从第1号位置(1)起,往后3个字符(111)删除 str.erase(1, 3); // hello cout &lt;&lt; \"str = \" &lt;&lt; str &lt;&lt; endl; } int main() { test01(); return 0; }string子串(字符串截取) // string子串(字符串截取) #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; void test01() { string str = \"abcdef\"; //把从第1号位置开始起,往后3个字符(bcd)截取到substr中 string substr = str.substr(1, 3); cout &lt;&lt; \"substr = \" &lt;&lt; substr &lt;&lt; endl; } //实用操作 void test02() { string email = \"zhangsan@email.com\"; //从邮件的地址中获取用户名的信息,也就是获取@字符前面的字符串 //先找到@字符的下标 int pos = email.find(\"@\"); //从0开始起,截取pos(8)个字符到userName中 //因为从0号位置起是包含0的,所以截取8个实际上截取的是0~7 string userName = email.substr(0, pos); cout &lt;&lt; \"userName = \" &lt;&lt; userName &lt;&lt; endl; } int main() { // test01(); test02(); return 0; } 下面介绍的是stack这个C++内置的栈容器 stack： 基本用法stack容器的用法 // stack容器 #include &lt;iostream&gt; using namespace std; //使用栈容器需要包含的头文件 #include &lt;stack&gt; void test01() { //创建一个栈 stack&lt;int&gt; s; //栈是一种先进后出,后进先出的容器 //入栈 s.push(10); s.push(20); s.push(30); s.push(40); //查看栈的长度 cout &lt;&lt; \"s size:\" &lt;&lt; s.size() &lt;&lt; endl; //判断栈是否为空,为空返回真,不为空返回假,通过取反的操作循环遍历出栈,直到栈为空为止 while (!s.empty()) { //查看栈顶元素 40 30 20 10 因为是先进后出,40是最后进的栈,所以先输出40 cout &lt;&lt; \"top: \" &lt;&lt; s.top() &lt;&lt; endl; //出栈 s.pop(); } //查看栈的长度 cout &lt;&lt; \"s size:\" &lt;&lt; s.size() &lt;&lt; endl; } int main() { test01(); return 0; } 下面介绍的是queue这个C++内置的队列容器 queue： 基本用法queue容器的基本用法 // queue容器 #include &lt;iostream&gt; using namespace std; //使用队列容器需要包含的头文件 #include &lt;queue&gt; #include &lt;string&gt; class Person { public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } string m_Name; int m_Age; }; void test01() { //队列是一个先进先出的容器 //创建一个队列 queue&lt;Person&gt; q; //队列也可以存储自定义的数据类型 Person p1(\"tanshen\", 30); Person p2(\"swk\", 100); Person p3(\"zbj\", 900); Person p4(\"sashen\", 800); //入队 q.push(p1); q.push(p2); q.push(p3); q.push(p4); //查看队列的大小 cout &lt;&lt; \"q size: \" &lt;&lt; q.size() &lt;&lt; endl; //判断队列是否为空,为空返回真,通过取反的操作一直循环出队,直到队列为空为止 while (!q.empty()) { //查看队头 cout &lt;&lt; \"top--name: \" &lt;&lt; q.front().m_Name &lt;&lt; \" age: \" &lt;&lt; q.front().m_Age &lt;&lt; endl; //查看队尾 cout &lt;&lt; \"back--name: \" &lt;&lt; q.back().m_Name &lt;&lt; \" age: \" &lt;&lt; q.back().m_Age &lt;&lt; endl; //出队 q.pop(); } //查看队列的大小 cout &lt;&lt; \"q size: \" &lt;&lt; q.size() &lt;&lt; endl; } int main() { test01(); return 0; } 下面介绍的是set这个C++内置的集合容器 set： 构造和赋值大小和交换插入和删除查找和统计与multiset的区别排序对象排序set容器的构造和赋值 // set容器的构造和赋值 #include &lt;iostream&gt; using namespace std; //使用set集合容器必须要加这个头文件 #include &lt;set&gt; void printSet(const set&lt;int&gt; &amp;s) { for (set&lt;int&gt;::const_iterator it = s.begin(); it != s.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { // set容器不允许插入重复的数据,且容器内部是有序的,其底层是一个二叉树 set&lt;int&gt; s1; //插入数据,注意:set没有尾插和头插,只有insert插入方式 s1.insert(100); s1.insert(20); s1.insert(300); s1.insert(40); s1.insert(500); //这里最后的20不会显示,因为set不允许插入重复值 s1.insert(20); //无论插入的是否有序,set内部都会自动排序 printSet(s1); //拷贝构造 将s1的数据全部拷贝到s2中 set&lt;int&gt; s2(s1); printSet(s2); // operator=赋值 set&lt;int&gt; s3; s3 = s2; printSet(s3); } int main() { test01(); return 0; }set大小和交换 // set大小和交换 #include &lt;iostream&gt; using namespace std; #include &lt;set&gt; void printSet(const set&lt;int&gt; &amp;s) { for (set&lt;int&gt;::const_iterator it = s.begin(); it != s.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } //大小 void test01() { set&lt;int&gt; s1; //插入数据 s1.insert(10); s1.insert(20); s1.insert(30); s1.insert(40); //打印容器 printSet(s1); //判断set是否为空,为空返回真 if (s1.empty()) { cout &lt;&lt; \"s1 NULL\" &lt;&lt; endl; } else { cout &lt;&lt; \"s1 not NULL\" &lt;&lt; endl; //查看set的元素个数 cout &lt;&lt; \"s1 size: \" &lt;&lt; s1.size() &lt;&lt; endl; } } //交换 void test02() { set&lt;int&gt; s1; //插入数据 s1.insert(10); s1.insert(20); s1.insert(30); s1.insert(40); set&lt;int&gt; s2; //插入数据 s2.insert(100); s2.insert(200); s2.insert(300); s2.insert(400); //交换前 cout &lt;&lt; \"open: \" &lt;&lt; endl; printSet(s1); printSet(s2); //交换 s1.swap(s2); //交换后 cout &lt;&lt; \"end: \" &lt;&lt; endl; printSet(s1); printSet(s2); } int main() { // test01(); test02(); return 0; }set插入和删除 // set插入和删除 #include &lt;iostream&gt; using namespace std; #include &lt;set&gt; void printSet(const set&lt;int&gt; &amp;s) { for (set&lt;int&gt;::const_iterator it = s.begin(); it != s.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { set&lt;int&gt; s1; //插入 s1.insert(30); s1.insert(30); s1.insert(20); s1.insert(40); //输出 printSet(s1); //删除 set中的第一个元素 因为set内部会自动排序,所以删除的其实是20,不是第一个插入的30 s1.erase(s1.begin()); printSet(s1); //删除的重载版本,直接传入数据就可以自动删除容器中对应的数据 s1.erase(40); printSet(s1); //清空区间的值 s1.erase(s1.begin(), s1.end()); printSet(s1); //清空,跟上面一样的效果 s1.clear(); printSet(s1); } int main() { test01(); return 0; }set的查找和统计 // set的查找和统计 #include &lt;iostream&gt; using namespace std; #include &lt;set&gt; void test01() { set&lt;int&gt; s1; //插入数据 s1.insert(10); s1.insert(20); s1.insert(30); s1.insert(40); //查找 返回的是一个迭代器 set&lt;int&gt;::iterator pos = s1.find(40); //如果返回的不是容器当中的尾指针则表示找到了 if (pos != s1.end()) { cout &lt;&lt; \"find success!\" &lt;&lt; *pos &lt;&lt; endl; } else { cout &lt;&lt; \"find error!\" &lt;&lt; endl; } } //统计 void test02() { set&lt;int&gt; s1; //插入数据 s1.insert(10); s1.insert(20); s1.insert(30); s1.insert(30); s1.insert(30); s1.insert(30); s1.insert(40); s1.insert(30); //统计30的个数 int num = s1.count(300); // 1 不过插入多少相同的数在set里面都只有1个 cout &lt;&lt; \"num: \" &lt;&lt; num &lt;&lt; endl; } int main() { // test01(); test02(); return 0; }set与multiset的区别 // set与multiset的区别 #include &lt;iostream&gt; using namespace std; #include &lt;set&gt; void test01() { set&lt;int&gt; s; // set的底层是一个pair的数据类型,而pair是一个成对出现的数据类型 //下面定义一个pair的数据类型,第一个数据类型是迭代器,第二个数据类型是bool //可以用这个数据类型定义一个变量用来接收set插入返回的结果 pair&lt;set&lt;int&gt;::iterator, bool&gt; ret = s.insert(10); // ret是一个set+bool的数据类型,如果为真则表示set插入成功 if (ret.second) { //插入成功 cout &lt;&lt; \"insert success!\" &lt;&lt; endl; } else { //插入失败 cout &lt;&lt; \"insert error!\" &lt;&lt; endl; } ret = s.insert(10); //在第二次向set容器插入相同的数据时插入失败了 if (ret.second) { //插入成功 cout &lt;&lt; \"insert2 success!\" &lt;&lt; endl; } else { //插入失败 cout &lt;&lt; \"insert2 error!\" &lt;&lt; endl; } //这是multiset,允许往容器中插入相同的数据 multiset&lt;int&gt; ms; //允许插入重复值,其它的成员函数和set相同 ms.insert(10); ms.insert(10); ms.insert(10); ms.insert(10); for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } int main() { test01(); return 0; }set容器排序 // set容器排序 #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; class MyCompare { public: //利用函数重载进行排序,第一个()代表重载()符号,第二个()代表函数的参数列表 //仿函数的返回值是一个bool类型 bool operator()(int v1, int v2) { return v1 &gt; v2; } }; void printSet(const set&lt;int&gt; &amp;s) { for (set&lt;int&gt;::const_iterator it = s.begin(); it != s.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } //因为原本的模板列表变了,所以不能再用上面的,要重写输出函数 void printSet2(const set&lt;int, MyCompare&gt; &amp;s) { for (set&lt;int, MyCompare&gt;::const_iterator it = s.begin(); it != s.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { // set容器本身是有序的,但是可以通过仿函数修改它的排序规则 set&lt;int&gt; s1; for (int i = 10; i &lt; 15; i++) { for (int j = 15; j &gt;= i; j--) { s1.insert(j); } } //排序前 cout &lt;&lt; \"open: \" &lt;&lt; endl; printSet(s1); //默认是升序排序,指定排序规则为降序排序 set&lt;int, MyCompare&gt; s2; for (int i = 10; i &lt; 15; i++) { for (int j = 15; j &gt;= i; j--) { s2.insert(j); } } //排序后: cout &lt;&lt; \"end: \" &lt;&lt; endl; printSet2(s2); } int main() { test01(); return 0; }set容器排序2–自定义数据类型排序 // set容器排序2--自定义数据类型排序 #include &lt;iostream&gt; using namespace std; #include &lt;set&gt; #include &lt;string&gt; class Person { public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } string m_Name; int m_Age; }; //利用仿函数指定排序规则 class comparePerson { public: //在对比过程中不可修改,所以要加上const bool operator()(const Person &amp;p1, const Person &amp;p2) { //按照年龄 降序 return p1.m_Age &gt; p2.m_Age; } }; //输出 void printSet(const set&lt;Person, comparePerson&gt; &amp;s) { for (set&lt;Person, comparePerson&gt;::const_iterator it = s.begin(); it != s.end(); it++) { cout &lt;&lt; \"name: \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" age: \" &lt;&lt; it-&gt;m_Age &lt;&lt; endl; } } void test01() { //利用仿函数修改排序规则 set&lt;Person, comparePerson&gt; s; //创建Perosn对象 Person p1(\"liubei\", 24); Person p2(\"zs\", 28); Person p3(\"lisi\", 25); Person p4(\"wangwu\", 21); //插入数据 s.insert(p1); s.insert(p2); s.insert(p3); s.insert(p4); //遍历数据 printSet(s); } int main() { test01(); return 0; } 下面介绍的是pair这个C++内置的对组容器,一般都和map哈希表容器配合使用 pair： 基本用法pair容器的基本用法 // pair对组容器 #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; void test01() { //使用pair不需要引入其他头文件 //创建pair,&lt;&gt;括号里面是两个不同的数据类型,()括号里面是给这两个不同的类型赋初值,也可以理解为有参构造函数 pair&lt;string, int&gt; p(\"Tom\", 20); //输出pair里面的值,第一个值是first,第二个值是second cout &lt;&lt; \"name: \" &lt;&lt; p.first &lt;&lt; \" age: \" &lt;&lt; p.second &lt;&lt; endl; //第二种方式: 在make_pair里面赋值 pair&lt;string, int&gt; p2 = make_pair(\"Jerry\", 30); //访问第一个数据是first,访问第二个数据是second cout &lt;&lt; \"name: \" &lt;&lt; p2.first &lt;&lt; \" age: \" &lt;&lt; p2.second &lt;&lt; endl; } int main() { test01(); return 0; } 下面介绍的是map这个C++内置哈希表容器 map： 构造和赋值大小和交换插入和删除查找和统计排序对象排序map容器构造和赋值 // map容器构造和赋值 #include &lt;iostream&gt; using namespace std; //要使用哈希容器需要引入这个头文件 #include &lt;map&gt; void printMap(const map&lt;int, int&gt; &amp;m) { for (map&lt;int, int&gt;::const_iterator it = m.begin(); it != m.end(); it++) { //在map输出时要输出一个对组,可以用(*it).的方式,也可以用-&gt;指针的方式,first是对组左边的值,second是对组右边的值 cout &lt;&lt; \"key: \" &lt;&lt; (*it).first &lt;&lt; \" value: \" &lt;&lt; it-&gt;second &lt;&lt; endl; } cout &lt;&lt; endl; } void test01() { // map底层是用二叉树实现的 //创建一个map,&lt;&gt;符号里面的值是成对出现的,第一个是key值,起到索引作用,第二个是value值,起到实值的作用 map&lt;int, int&gt; m; //插入数据,因为map里面的值是成对出现的,所以要使用pair成对的插入值 //可以理解为一个map里面存放着多个pair,其中左边的1起到的是索引key的作用,右边的10起到的是value实值的作用 m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(3, 30)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(4, 40)); //输出 注意:无论插入的顺序是什么,最后还是会按照key的顺序排序 printMap(m); //拷贝构造 map&lt;int, int&gt; m2(m); printMap(m); //赋值 map&lt;int, int&gt; m3; m3 = m2; printMap(m3); } int main() { test01(); return 0; }map容器大小和交换 // map容器大小和交换 #include &lt;iostream&gt; using namespace std; #include &lt;map&gt; void printMap(const map&lt;int, int&gt; &amp;m) { for (map&lt;int, int&gt;::const_iterator it = m.begin(); it != m.end(); it++) { cout &lt;&lt; \"key: \" &lt;&lt; it-&gt;first &lt;&lt; \" value: \" &lt;&lt; it-&gt;second &lt;&lt; endl; } cout &lt;&lt; endl; } //大小 void test01() { map&lt;int, int&gt; m; //通过pair往map里插入数据 m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); //判断map是否为空,如果为空则返回真 if (m.empty()) { //为空 cout &lt;&lt; \"map NULL!\" &lt;&lt; endl; } else { //不为空 cout &lt;&lt; \"map not NULL!\" &lt;&lt; endl; //查看map的长度 cout &lt;&lt; \"m size: \" &lt;&lt; m.size() &lt;&lt; endl; } } //交换 void test02() { map&lt;int, int&gt; m; //通过pair往map里插入数据 m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); map&lt;int, int&gt; m2; //通过pair往map里插入数据 m2.insert(pair&lt;int, int&gt;(4, 100)); m2.insert(pair&lt;int, int&gt;(5, 200)); m2.insert(pair&lt;int, int&gt;(6, 300)); //交换前 cout &lt;&lt; \"open: \" &lt;&lt; endl; printMap(m); printMap(m2); //交换 m.swap(m2); //交换后 cout &lt;&lt; \"end: \" &lt;&lt; endl; printMap(m); printMap(m2); } int main() { // test01(); test02(); return 0; }map的插入和删除 // map的插入和删除 #include &lt;iostream&gt; using namespace std; #include &lt;map&gt; void printMap(const map&lt;int, int&gt; &amp;m) { for (map&lt;int, int&gt;::const_iterator it = m.begin(); it != m.end(); it++) { cout &lt;&lt; \"key: \" &lt;&lt; it-&gt;first &lt;&lt; \" value: \" &lt;&lt; it-&gt;second &lt;&lt; endl; } cout &lt;&lt; endl; } void test01() { map&lt;int, int&gt; m; //第一种插入方式: m.insert(pair&lt;int, int&gt;(1, 10)); //第二种插入方式: make_pair也可以创建出一个对组 m.insert(make_pair(2, 20)); //第三种 通过迭代器插入 m.insert(map&lt;int, int&gt;::value_type(3, 30)); //第四种: 通过重载运算符[]的方式插入,[]里面的值代表key,=右边的值代表value m[4] = 40; //也可以利用[] 访问到value,但是要注意key下标越界的问题,如果越界了那么value会默认为0 cout &lt;&lt; m[4] &lt;&lt; endl; //输出 printMap(m); //删除 将map中第一个元素删除 m.erase(m.begin()); printMap(m); //通过key的方式删除,将map中key为3的数据删除,注意:不能按照value删除 m.erase(3); printMap(m); //按照区间的方式清空 m.erase(m.begin(), m.end()); //清空,跟上面一样 m.clear(); } int main() { test01(); return 0; }map的查找和统计 // map的查找和统计 #include &lt;iostream&gt; using namespace std; #include &lt;map&gt; void test01() { map&lt;int, int&gt; m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); //通过key查找,返回一个迭代器 map&lt;int, int&gt;::iterator pos = m.find(3); //如果迭代器不等于尾指针则表示找到了 if (pos != m.end()) { //输出找到的key和value值 cout &lt;&lt; \"find success! key = \" &lt;&lt; (*pos).first &lt;&lt; \" value = \" &lt;&lt; (*pos).second &lt;&lt; endl; } else { cout &lt;&lt; \"find error!\" &lt;&lt; endl; } //统计,通过key找到对应的值的个数 m.insert(pair&lt;int, int&gt;(3, 30)); m.insert(pair&lt;int, int&gt;(3, 40)); m.insert(pair&lt;int, int&gt;(3, 50)); //注意:map不允许插入重复的key的元素,无论插入多少,只要key是相同的那么就只会保留第一个插入的数据 // multimap的统计个数可能会大于1 int num = m.count(3); //所以统计map的key的个数num永远是1 cout &lt;&lt; \"num = \" &lt;&lt; num &lt;&lt; endl; cout &lt;&lt; m[3] &lt;&lt; endl; } int main() { test01(); return 0; }map容器排序 // map容器排序 #include &lt;iostream&gt; using namespace std; #include &lt;map&gt; class MyCompare { public: //仿函数 bool operator()(int v1, int v2) { //降序 return v1 &gt; v2; } }; void printMap(const map&lt;int, int, MyCompare&gt; &amp;m) { for (map&lt;int, int, MyCompare&gt;::const_iterator it = m.begin(); it != m.end(); it++) { cout &lt;&lt; \"key: \" &lt;&lt; it-&gt;first &lt;&lt; \" value: \" &lt;&lt; it-&gt;second &lt;&lt; endl; } cout &lt;&lt; endl; } void test01() { // map默认的排序规则是按key值从小到大升序排序,要改变排序规则需要借助仿函数 map&lt;int, int, MyCompare&gt; m; m.insert(make_pair(1, 10)); m.insert(make_pair(2, 20)); m.insert(make_pair(3, 30)); m.insert(make_pair(4, 40)); m.insert(make_pair(5, 50)); printMap(m); } int main() { test01(); return 0; }map容器排序-自定义数据类型排序 // map容器排序-自定义数据类型排序 #include &lt;iostream&gt; using namespace std; #include &lt;map&gt; #include &lt;string&gt; class Person { public: Person(string name, int age) { this-&gt;m_Age = age; this-&gt;m_Name = name; } string m_Name; int m_Age; }; class MyCompare { public: bool operator()(int v1, int v2) { return v1 &gt; v2; } }; void printMap(const map&lt;int, Person, MyCompare&gt; &amp;m) { for (map&lt;int, Person, MyCompare&gt;::const_iterator it = m.begin(); it != m.end(); it++) { cout &lt;&lt; \"key-age: \" &lt;&lt; it-&gt;first &lt;&lt; \" value-name: \" &lt;&lt; it-&gt;second.m_Name &lt;&lt; \" age: \" &lt;&lt; it-&gt;second.m_Age &lt;&lt; endl; } cout &lt;&lt; endl; } void test01() { //利用仿函数修改排序规则 map&lt;int, Person, MyCompare&gt; m; Person p1(\"zs\", 18); Person p2(\"lisi\", 20); Person p3(\"wangwu\", 28); Person p4(\"zaoliu\", 19); //将对象里的年龄作为key m.insert(make_pair(p1.m_Age, p1)); m.insert(make_pair(p2.m_Age, p2)); m.insert(make_pair(p3.m_Age, p3)); m.insert(make_pair(p4.m_Age, p4)); printMap(m); } int main() { test01(); return 0; } 下面介绍的是list这个C++内置双向链表容器 list： 基本使用赋值和交换大小操作插入和删除数据存取反转和排序对象排序list容器的基本使用 // list容器 #include &lt;iostream&gt; using namespace std; //使用链表需要包含的头文件 #include &lt;list&gt; //输出 void printList(const list&lt;int&gt; &amp;L) { for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { //链表可以对任意位置插入和删除元素 //缺点:遍历元素没有数组快,占用的空间比数组大 //创建一个链表 list&lt;int&gt; L1; // STL中的链表是一个双向链表,也就是每个节点有两个指针,一个指向前,一个指向后 //利用尾插添加数据 L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); //遍历 printList(L1); //利用区间的方式构造,将L1区间中所有的数据复制到L2中 list&lt;int&gt; L2(L1.begin(), L1.end()); printList(L2); //拷贝构造 list&lt;int&gt; L3(L2); printList(L3); // n个elem,将10个1000复制到L4中 list&lt;int&gt; L4(10, 1000); printList(L4); } int main() { test01(); return 0; }list赋值和交换 // list赋值和交换 #include &lt;iostream&gt; using namespace std; #include &lt;list&gt; void printList(const list&lt;int&gt; &amp;L) { for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { list&lt;int&gt; L1; //利用尾插添加数据进链表 L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); printList(L1); //利用operator=赋值 list&lt;int&gt; L2; L2 = L1; printList(L2); //利用区间赋值 list&lt;int&gt; L3; L3.assign(L2.begin(), L2.end()); printList(L3); list&lt;int&gt; L4; // n个elem方式,也就是10个100赋值给L4 L4.assign(10, 100); printList(L4); } //交换 void test02() { list&lt;int&gt; L1; //利用尾插添加数据进链表 L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); list&lt;int&gt; L2; //将10个100赋值给L2 L2.assign(10, 100); //交换前: cout &lt;&lt; \"open: \" &lt;&lt; endl; printList(L1); printList(L2); //交换,将L1和L2中的元素进行交换 L1.swap(L2); //交换后 cout &lt;&lt; \"end: \" &lt;&lt; endl; printList(L1); printList(L2); } int main() { // test01(); test02(); return 0; }list大小操作 // list大小操作 #include &lt;iostream&gt; using namespace std; #include &lt;list&gt; //输出 void printList(const list&lt;int&gt; &amp;L) { for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { list&lt;int&gt; L1; //利用尾插添加数据进链表 L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); //输出 printList(L1); //判断list容器是否为空,如果为空返回真 if (L1.empty()) { cout &lt;&lt; \"L1 NULL\" &lt;&lt; endl; } else { cout &lt;&lt; \"L1 not NULL\" &lt;&lt; endl; //输出list容器的长度(个数) cout &lt;&lt; \"L1 size:\" &lt;&lt; L1.size() &lt;&lt; endl; } //重新指定大小,默认用0填充剩余空间 // L1.resize(10); //重新指定大小,用1来填充剩余空间 L1.resize(10, 1); printList(L1); //重新指定大小,如果超出则将超出的部分删除 L1.resize(2); printList(L1); } int main() { test01(); return 0; }list插入和删除 // list插入和删除 #include &lt;iostream&gt; using namespace std; #include &lt;list&gt; void printList(const list&lt;int&gt; &amp;L) { for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { list&lt;int&gt; L; //尾插 L.push_back(10); L.push_back(20); L.push_back(30); //头插 L.push_front(100); L.push_front(200); L.push_front(300); //输出 300 200 100 10 20 30 因为100~300是头插的,10~30是尾插的,所以300在最前面 printList(L); //尾删 300 200 100 10 20 将最后一个元素30给删除了 L.pop_back(); printList(L); //头删 200 100 10 20 将第一个元素300给删除了 L.pop_front(); printList(L); //指定位置插入,在头部第一个元素的前面插入1000 L.insert(L.begin(), 1000); // 1000 200 100 10 20 printList(L); //通过迭代器插入 list&lt;int&gt;::iterator it = L.begin(); //在第二个元素(200)的前面插入2000 L.insert(++it, 2000); // 1000 2000 200 100 10 20 printList(L); //删除 it = L.begin(); //将头部第一个元素(1000)删除 L.erase(it); // 2000 200 100 10 20 printList(L); //通过迭代器将第二个元素(200)删除 it = L.begin(); L.erase(++it); printList(L); //移除 //尾插10000 L.push_back(10000); L.push_back(10000); L.push_back(10000); L.push_back(10000); printList(L); //利用成员函数remove直接把10000删除,括号里面写要删除的数据,所有匹配的值都会被删除 L.remove(10000); printList(L); //清空 L.clear(); printList(L); } int main() { test01(); return 0; }list数据存取 // list数据存取 #include &lt;iostream&gt; using namespace std; #include &lt;list&gt; void printList(const list&lt;int&gt; &amp;L) { for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { list&lt;int&gt; L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); // L1[0] 不可以用中括号的方式访问list中的元素 // L1.at(0) 不可以用at的方式访问list中的元素 //原因:链表的数据不是连续存储的,不能用访问数组的方式访问链表 printList(L1); //访问第一个元素 cout &lt;&lt; \"top: \" &lt;&lt; L1.front() &lt;&lt; endl; //访问最后一个元素 cout &lt;&lt; \"back: \" &lt;&lt; L1.back() &lt;&lt; endl; //迭代器不支持随机访问 list&lt;int&gt;::iterator it = L1.begin(); //错误,不允许直接+数,只能++或者-- // it = it + 1; it++; it--; } int main() { test01(); return 0; }list反转和排序 // list反转和排序 #include &lt;iostream&gt; using namespace std; #include &lt;list&gt; void printList(const list&lt;int&gt; &amp;L) { for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } //反转 void test01() { list&lt;int&gt; L1; for (int i = 1; i &lt; 5; i++) { for (int j = 5; j &gt;= i; j--) { L1.push_back(j); } } //反转前 cout &lt;&lt; \"open: \" &lt;&lt; endl; printList(L1); //反转 L1.reverse(); //反转后 cout &lt;&lt; \"end: \" &lt;&lt; endl; printList(L1); } //函数重载,使list的排序降序排序 bool myCompare(int v1, int v2) { return v1 &gt; v2; } //排序 void test02() { list&lt;int&gt; L1; for (int i = 1; i &lt; 5; i++) { for (int j = 5; j &gt;= i; j--) { L1.push_back(j); } } //排序前: cout &lt;&lt; \"open: \" &lt;&lt; endl; printList(L1); //默认升序排序,注意:不能用algorithm里面的sort排序模板,因为list不支持随机访问迭代器 //可以用内置的成员函数sort进行排序 L1.sort(); //排序后 cout &lt;&lt; \"end: \" &lt;&lt; endl; printList(L1); //利用函数重载降序排序 L1.sort(myCompare); //降序排序后: printList(L1); } int main() { // test01(); test02(); return 0; }list排序案例-自定义数据类型排序 // list排序案例-自定义数据类型排序 #include &lt;iostream&gt; using namespace std; #include &lt;list&gt; #include &lt;string&gt; class Person { public: Person(string name, int age, int height) { this-&gt;m_Name = name; this-&gt;m_Age = age; this-&gt;m_Height = height; } //姓名 string m_Name; //年龄 int m_Age; //身高 int m_Height; }; //指定排序规则 //如果要排序自定义类型则必须指定排序规则 bool comparePerson(Person &amp;p1, Person &amp;p2) { //高级排序: if (p1.m_Age == p2.m_Age) { //如果年龄相同的情况下,按照身高降序排序 return p1.m_Height &gt; p2.m_Height; } else { //按照年龄 升序排序： return p1.m_Age &lt; p2.m_Age; } } void printList(list&lt;Person&gt; &amp;L) { for (list&lt;Person&gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; \"name: \" &lt;&lt; (*it).m_Name &lt;&lt; \" age: \" &lt;&lt; (*it).m_Age &lt;&lt; \" height: \" &lt;&lt; (*it).m_Height &lt;&lt; endl; } } void test01() { list&lt;Person&gt; L1; Person p(\"swk\", 20, 181); Person p1(\"zbj\", 29, 190); Person p2(\"tanshen\", 19, 175); Person p3(\"shashen\", 18, 165); Person p4(\"zs\", 18, 200); Person p5(\"lisi\", 29, 195); //向容器中插入数据 L1.push_back(p); L1.push_back(p1); L1.push_back(p2); L1.push_back(p3); L1.push_back(p4); L1.push_back(p5); //输出排序前: cout &lt;&lt; \"open: \" &lt;&lt; endl; printList(L1); cout &lt;&lt; \"------------------------------\" &lt;&lt; endl; //排序,括号里面的是通过函数重载指定排序规则: L1.sort(comparePerson); //排序后: cout &lt;&lt; \"end: \" &lt;&lt; endl; printList(L1); } int main() { test01(); return 0; } 下面介绍的是deque这个C++内置双端队列容器 deque： 基本使用赋值操作判断元素大小和长度插入和删除数据存取排序deque容器的基本使用 // deque构造函数 #include &lt;iostream&gt; using namespace std; //使用deque容器必须包含这个头文件 #include &lt;deque&gt; //输出,加了const后就变成了只读的一个迭代器 void printDeque(const deque&lt;int&gt; &amp;d) { //通过迭代器输出 for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) { //错误,加了const后容器中的数据就只读不可修改了 //*it = 100; cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { deque&lt;int&gt; d1; //通过尾插法插入数据 for (int i = 0; i &lt; 10; i++) { d1.push_back(i); } printDeque(d1); //通过两个成员函数把d1所有区间的数据都赋值给d2 deque&lt;int&gt; d2(d1.begin(), d1.end()); printDeque(d2); //将10个100赋值给d3 deque&lt;int&gt; d3(10, 100); printDeque(d3); //拷贝构造,把d3赋值给d4 deque&lt;int&gt; d4(d3); printDeque(d4); } int main() { test01(); return 0; }deque赋值操作 // deque赋值操作 #include &lt;iostream&gt; using namespace std; #include &lt;deque&gt; void printDeque(const deque&lt;int&gt; &amp;d) { for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { deque&lt;int&gt; d1; for (int i = 0; i &lt; 10; i++) { d1.push_back(i); } //打印 printDeque(d1); // operator=号赋值 deque&lt;int&gt; d2; d2 = d1; printDeque(d2); // assign赋值 deque&lt;int&gt; d3; d3.assign(d1.begin(), d1.end()); printDeque(d3); deque&lt;int&gt; d4; //赋值10个100 d4.assign(10, 100); printDeque(d4); } int main() { test01(); return 0; }deque判断元素大小和长度 // deque判断元素大小和长度 #include &lt;iostream&gt; using namespace std; #include &lt;deque&gt; void printDeque(const deque&lt;int&gt; &amp;d) { for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { // deque其底层有一个中控器来控制里面的容器,无论增加多少个元素进去只要中控器能管理到就可以一直增加 deque&lt;int&gt; d1; for (int i = 0; i &lt; 10; i++) { d1.push_back(i); } //打印 printDeque(d1); //判断是否为空,空返回真 if (d1.empty()) { cout &lt;&lt; \"d1 NULL\" &lt;&lt; endl; } else { cout &lt;&lt; \"d1 not NULL\" &lt;&lt; endl; //获取容器的长度 cout &lt;&lt; \"d1 size: \" &lt;&lt; d1.size() &lt;&lt; endl; //注意:deque没有返回容量的成员函数 } //重新指定大小,用0来填充多余的空间 d1.resize(15); printDeque(d1); //重新指定大小,指定用1来填充多余的空间 d1.resize(15, 1); //重新指定大小,超出的部分会被删除 d1.resize(5); } int main() { test01(); return 0; }deque的插入和删除 // deque的插入和删除 #include &lt;iostream&gt; using namespace std; #include &lt;deque&gt; void printDeque(const deque&lt;int&gt; &amp;d) { for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { deque&lt;int&gt; d1; //尾插 d1.push_back(10); d1.push_back(20); d1.push_back(30); d1.push_back(40); //头插 d1.push_front(100); d1.push_front(200); //打印 200 100 10 20 30 40 因为10~40是从尾部插入的,而200和100是从头部插入的,所以顺序不同 printDeque(d1); //尾删 d1.pop_back(); printDeque(d1); //头删 d1.pop_front(); printDeque(d1); } void test02() { deque&lt;int&gt; d1; d1.push_back(10); d1.push_back(20); d1.push_front(100); d1.push_front(200); // 200 100 10 20 printDeque(d1); //在头部第一个元素的前面插入1000 d1.insert(d1.begin(), 1000); //在头部第一个元素的前面插入2个10000 d1.insert(d1.begin(), 2, 10000); // 10000 10000 1000 200 100 10 20 printDeque(d1); //按照区间进行插入 deque&lt;int&gt; d2; d2.push_back(1); d2.push_back(2); d2.push_back(3); //在d1的头部第一个元素的前面插入d2的全部数据 d1.insert(d1.begin(), d2.begin(), d2.end()); printDeque(d1); } void test03() { deque&lt;int&gt; d1; d1.push_back(10); d1.push_back(20); d1.push_front(100); d1.push_front(200); //删除 deque&lt;int&gt;::iterator it = d1.begin(); //迭代器一开始指向容器中第一个元素,it++后迭代器指向第二个元素 it++; //利用迭代器将第二个元素删除 d1.erase(it); // 200 10 20 printDeque(d1); //按照区间的方式删除,其实也就是清空 d1.erase(d1.begin(), d1.end()); printDeque(d1); //利用成员函数清空 d1.clear(); } int main() { // test01(); // test02(); test03(); return 0; }deque的数据存取 // deque的数据存取 #include &lt;iostream&gt; using namespace std; #include &lt;deque&gt; void test01() { deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_back(30); d.push_front(100); d.push_front(200); d.push_front(300); //通过[]方式访问元素 for (int i = 0; i &lt; d.size(); i++) { // 300 200 100 10 20 30 cout &lt;&lt; d[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; //通过at方式访问元素 for (int i = 0; i &lt; d.size(); i++) { cout &lt;&lt; d.at(i) &lt;&lt; \" \"; } cout &lt;&lt; endl; //访问第一个元素 cout &lt;&lt; \"one: \" &lt;&lt; d.front() &lt;&lt; endl; //访问最后一个元素 cout &lt;&lt; \"end: \" &lt;&lt; d.back() &lt;&lt; endl; } int main() { test01(); return 0; }deque排序 // deque排序 #include &lt;iostream&gt; using namespace std; //标准算法头文件 #include &lt;algorithm&gt; #include &lt;deque&gt; void printDeque(const deque&lt;int&gt; &amp;d) { for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } bool cmp(int a, int b) { return a &gt; b; } void test01() { deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_back(30); d.push_front(100); d.push_front(200); d.push_front(300); //升序排序 sort(d.begin(), d.end()); printDeque(d); //降序排序 sort(d.begin(), d.end(), cmp); printDeque(d); } int main() { test01(); return 0; } 下面介绍的是operator()这个C++内置仿函数重载的用法，以及谓词的概念。 operator()： 重载一元谓词二元谓词算术仿函数关系仿函数逻辑仿函数仿函数重载() //仿函数重载() #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; class MyAdd { public: int operator()(int v1, int v2) { return v1 + v2; } }; void test01() { //当一个类里有operator()重载函数,那么创建出来的对象就称为函数对象 //函数对象在使用时,可以像普通函数那样调用,可以有参数,可以有返回值 MyAdd myAdd; cout &lt;&lt; myAdd(10, 10) &lt;&lt; endl; } //函数对象超出普通函数的概念,可以有自己的状态 class MyPrint { public: MyPrint() { this-&gt;count = 0; } void operator()(string test) { cout &lt;&lt; test &lt;&lt; endl; //统计使用次数 this-&gt;count++; } //记录内部的状态 int count; }; void test02() { MyPrint myPrint; myPrint(\"hello world\"); myPrint(\"hello world\"); myPrint(\"hello world\"); myPrint(\"hello world\"); cout &lt;&lt; \"myPrint count: \" &lt;&lt; myPrint.count &lt;&lt; endl; } //函数对象可以作为参数传递 void doPrint(MyPrint &amp;mp, string test) { //函数传了一个自定义类型数据，在传一个字符串，然后自定义数据在内部执行重载 mp(test); } void test03() { MyPrint myPrint; doPrint(myPrint, \"Hello c++\"); } int main() { // test01(); // test02(); test03(); return 0; }一元谓词 //一元谓词 #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; class GreaterFive { public: //一元谓词:只有一个参数,返回类型是bool bool operator()(int val) { return val &gt; 5; } }; void test01() { //仿函数,返回值类型是bool类型,称为谓词 //在operator()仿函数重载时小括号里一个参数就是一元,两个参数就是二元 vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) { v.push_back(i); } //查找容器中大于5的数字 // find_if是algorithm里面的模板算法,参数是传容器的区间,第三个参数传的是仿函数的函数对象 //可以用匿名的函数对象GreaterFive()替代,返回的是一个迭代器,传入什么容器就用什么容器的迭代器接收 vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); //如果迭代器指向容器的尾指针则表示未找到 if (it == v.end()) { cout &lt;&lt; \"find error!\" &lt;&lt; endl; } else { //查找成功 cout &lt;&lt; \"find success!\" &lt;&lt; endl; for (; it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } } } int main() { test01(); return 0; }二元谓词 //二元谓词 #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; class MyCompare { public: //在对象里面重载()符号,是bool类型并有两个参数就是二元谓词 bool operator()(int v1, int v2) { return v1 &gt; v2; } }; void PrintVector(vector&lt;int&gt; &amp;v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { vector&lt;int&gt; v; v.push_back(10); v.push_back(40); v.push_back(20); v.push_back(30); v.push_back(50); sort(v.begin(), v.end()); //升序排序后: cout &lt;&lt; \"open: \" &lt;&lt; endl; PrintVector(v); //使用函数对象 修改算法规则 变为从大到小降序排序 //这里的MyCompare就是正常的函数调用，只不过是匿名对象，在sort里面会调用这个函数， //这时用到就是函数重载运算符 sort(v.begin(), v.end(), MyCompare()); cout &lt;&lt; \"--------------------------------------\" &lt;&lt; endl; //降序排序后: cout &lt;&lt; \"end: \" &lt;&lt; endl; PrintVector(v); } int main() { test01(); return 0; }内建函数对象,算术仿函数 //内建函数对象,算术仿函数 #include &lt;iostream&gt; using namespace std; //使用内建函数对象需要包含这个头文件 #include &lt;functional&gt; // negate 一元仿函数,取反仿函数 // plus 二元仿函数,加法 void test01() { //容器，内建仿函数都是类模板 //通过内置的函数创建一个函数对象 negate&lt;int&gt; n; //对50进行取反: -50 cout &lt;&lt; n(50) &lt;&lt; endl; } void test02() { plus&lt;int&gt; p; //两个整型相加: 30 cout &lt;&lt; p(10, 20) &lt;&lt; endl; /* 类似的内置仿函数还有很多: minus&lt;T&gt; 减法 multiplies&lt;T&gt; 乘法 divides&lt;T&gt; 除法 modulus&lt;T&gt; 取模 */ } int main() { // test01(); test02(); return 0; }内建函数对象,关系仿函数 //内建函数对象,关系仿函数 #include &lt;iostream&gt; using namespace std; #include &lt;functional&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; class MyCompare { public: bool operator()(int v1, int v2) { return v1 &gt; v2; } }; void printVector(vector&lt;int&gt; &amp;v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { //大于 greater&lt;T&gt; vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(20); v.push_back(50); v.push_back(40); printVector(v); //利用自定义函数对象实现降序排序 // sort(v.begin(), v.end(), MyCompare()); //利用内置函数对象实现降序排序 sort(v.begin(), v.end(), greater&lt;int&gt;()); printVector(v); /* 类似的关系仿函数还有很多: equal_to&lt;T&gt; 等于 not_equal_to&lt;T&gt; 不等于 greater&lt;T&gt; 大于 greater_equal&lt;T&gt; 大于等于 less&lt;T&gt; 小于 less_equal&lt;T&gt; 小于等于 */ } int main() { test01(); return 0; }内建仿函数-逻辑仿函数 //内建仿函数-逻辑仿函数 #include &lt;iostream&gt; using namespace std; #include &lt;functional&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; void printVector(vector&lt;bool&gt; &amp;v) { for (vector&lt;bool&gt;::iterator it = v.begin(); it != v.end(); it++) { //可以在输出前面加上boolalpha让输出0/1变为输出false/true cout &lt;&lt; boolalpha &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { //逻辑非 logical_not 也就是取反! vector&lt;bool&gt; v; // 在vector容器里:true为1,false为0 v.push_back(true); v.push_back(false); v.push_back(true); v.push_back(false); printVector(v); //利用逻辑非 将容器v搬运到容器v2中,并执行取反操作 vector&lt;bool&gt; v2; //将v2的大小变为v1的大小 v2.resize(v.size()); // transform包含在algorithm算法模板中 //其作用是将第一个容器的内容搬运到第二个容器中,其中第一个参数和第二个参数是第一个容器的区间 //第三个参数是要搬运到的容器的开始区间,第四个参数是逻辑仿函数用来取反,用来之后就 //可以将第一个容器中搬运到第二个容器的数据全部取反 transform(v.begin(), v.end(), v2.begin(), logical_not&lt;bool&gt;()); printVector(v2); /* 类似的逻辑仿函数还有很多: logical_and&lt;T&gt; 逻辑与 logical_or&lt;T&gt; 逻辑或 */ } int main() { test01(); return 0; }","categories":[{"name":"C++","slug":"C","permalink":"https://yswm-m.github.io/categories/C/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"学习","slug":"学习","permalink":"https://yswm-m.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"笔记","slug":"笔记","permalink":"https://yswm-m.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"C++自学笔记2.0（模板元编程）","slug":"30-C++自学笔记2.0（模板元编程）","date":"2022-09-15T02:15:00.000Z","updated":"2022-09-28T08:47:20.408Z","comments":true,"path":"posts/30.html","link":"","permalink":"https://yswm-m.github.io/posts/30.html","excerpt":"","text":"更多教程笔记请查看我的上一篇文章：点击跳转 c++自学之旅2.0（模板元编程）开始！ 函数模板 //函数模板 //模板的意义是使函数可重复化 #include &lt;iostream&gt; using namespace std; //两个整型交换的函数,通过引用交换 void swapInt(int &amp;a, int &amp;b) { int temp = a; a = b; b = temp; } //两个浮点型的数交换,通过引用 void swapDouble(double &amp;a, double &amp;b) { double temp = a; a = b; b = temp; } //如果要交换所有的数据类型的值那么要写无数个函数 //但是用模板就可以解决这个问题,模板只有在使用的时候才会确定数据类型 //定义一个模板,T是一个通用的数据类型,可以改名字 template &lt;typename T&gt; //当定义了模板之后就可以使用通用的数据类型T,T只有在函数被调用的时候才会指定数据类型 void mySwap(T &amp;a, T &amp;b) { T temp = a; a = b; b = temp; } void test01() { int a = 10, b = 20; // swapInt(a, b); //利用函数模板来交换两个整型的值 //模板有两种使用方式 // 1.自动类型推导,也就是直接使用,T自动推导出来传入的数据类型 // mySwap(a, b); // 2.显示指定类型,也就是直接告诉模板传入的是什么类型 //也就是说&lt;&gt;括号里面的就是告诉模板的类型,下面的函数就是告诉模板要传int类型的参数进去 mySwap&lt;int&gt;(a, b); cout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; \" \" &lt;&lt; \"b=\" &lt;&lt; b &lt;&lt; endl; double c = 1.1, d = 2.2; swapDouble(c, d); cout &lt;&lt; \"c=\" &lt;&lt; c &lt;&lt; \" \" &lt;&lt; \"d=\" &lt;&lt; d &lt;&lt; endl; } int main() { test01(); return 0; } 函数模板的注意事项 //函数模板的注意事项 #include &lt;iostream&gt; using namespace std; //函数模板可以使用class替代typename,也可以继续用typename和后面的类模板做区分 template &lt;class T&gt; void mySwap(T &amp;a, T &amp;b) { T temp = a; a = b; b = temp; } void test01() { int a = 10; int b = 20; char c = 'c'; //使用模板 // mySwap(a, b); 正确 //错误,因为模板类型不一致,无法匹配 // mySwap(a, c); cout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; \" \" &lt;&lt; \"b=\" &lt;&lt; b &lt;&lt; endl; } template &lt;class T&gt; void func() { cout &lt;&lt; \"func\" &lt;&lt; endl; } void test02() { //错误,函数模板里面必须要用到T才能使用 // func(); //解决方法:直接确定T的数据类型 func&lt;int&gt;(); } int main() { // 1.自动类型推导,必须推导出一致的数据类型,T才可以使用 test01(); // 2.模板必须要确定出T的数据类型才可以使用 test02(); return 0; } 函数模板案例-数组排序 //函数模板案例-数组排序 #include &lt;iostream&gt; using namespace std; //交换模板实现 template &lt;class T&gt; void mySwap(T &amp;a, T &amp;b) { T temp = a; a = b; b = temp; } //排序算法模板实现 template &lt;class T&gt; void mySort(T arr[], int len) //第一个参数是数组,第二个参数是数组长度 { //选择排序算法 for (int i = 0; i &lt; len; i++) { //认定最大值的下标 int max = i; for (int j = i + 1; j &lt; len; j++) { //如果认定的最大值比遍历出的数值要小,说明j下标的元素才是真正的最大值 if (arr[max] &lt; arr[j]) { max = j; } } //如果排序出来后max不再是一开始认定的值了那就交换两边的最大值 if (max != i) { mySwap(arr[max], arr[i]); } } } //提供输出的模板 template &lt;class T&gt; void printArray(T arr[], int len) { for (int i = 0; i &lt; len; i++) { cout &lt;&lt; arr[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; } void test01() { //测试char数组 char charArray[] = \"badcfe\"; int num = sizeof(charArray) / sizeof(charArray[0]); //排序 mySort(charArray, num); //输出 printArray(charArray, num); } void test02() { //测试int数组 int intArray[] = {7, 5, 1, 3, 9, 2, 4, 6, 8}; int num = sizeof(intArray) / sizeof(int); //排序 mySort(intArray, num); //输出 printArray(intArray, num); } int main() { // test01(); test02(); return 0; } 普通函数与模板函数的区别 //普通函数与模板函数的区别 #include &lt;iostream&gt; using namespace std; //普通函数 int myAdd01(int a, int b) { return a + b; } //函数模板 template &lt;class T&gt; T myAdd02(T a, T b) { return a + b; } void test01() { int a = 10; int b = 20; char c = 'c'; //普通函数调用,隐式转换,会将c字符转换为ASCII码中的99再相加 cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //自动类型推导,使用模板调用 cout &lt;&lt; myAdd02(a, b) &lt;&lt; endl; //错误,无法推导出一致的类型 // myAdd02(a, c); //解决方法,显示指定类型调用,指定为int,会发生隐式类型转换 cout &lt;&lt; myAdd02&lt;int&gt;(a, c) &lt;&lt; endl; } int main() { // 1.普通函数调用可以发生隐式类型转换 test01(); // 2.函数模板 用自动类型推导,不可以发生隐式类型转换 // 3.函数模板 用显示指定类型,可以发生隐式类型转换 return 0; } 普通函数与函数模板的调用规则 //普通函数与函数模板的调用规则 #include &lt;iostream&gt; using namespace std; //普通函数 void myPrint(int a, int b) { cout &lt;&lt; \"my function\" &lt;&lt; endl; } //利用模板进行函数重载 //这是可以重载的,因为函数类型不一样 template &lt;class T&gt; void myPrint(T a, T b) { cout &lt;&lt; \"my template function\" &lt;&lt; endl; } //函数模板重载函数模板 template &lt;class T&gt; void myPrint(T a, T b, T c) { cout &lt;&lt; \"my template2 functions\" &lt;&lt; endl; } void test01() { int a = 10; int b = 20; //当普通函数和函数模板发生重载(重名)时优先调用普通函数 // myPrint(a, b); //通过空模板参数列表,强制调用函数模板 //所谓空模板也就是什么类型都不传,直接传参数 // myPrint&lt;&gt;(a, b); //函数模板重载函数模板,通过参数不同来区分 // myPrint(a, b, 100); //如果函数模板产生更好的匹配,优先调用函数模板 char c1 = 'a'; char c2 = 'b'; //优先调用了模板,因为普通函数会发生隐式转换,而模板可以直接匹配 myPrint(c1, c2); } int main() { //注意:1.普通函数与函数模板是可以发生函数重载的 // 2.可以使用空模板参数列表来强制调用函数模板 // 3.如果函数模板和普通函数都可以实现,则优先调用普通函数 // 4.如果函数模板可以产生更好的匹配,则优先调用函数模板 test01(); return 0; } 模板的局限性 //模板的局限性 #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; //定义一个类(自定义数据类型) class Person { public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } string m_Name; int m_Age; }; //利用模板实现对比两个数据是否相等的函数 template &lt;class T&gt; bool myCompare(T &amp;a, T &amp;b) { if (a == b) { return true; } else { return false; } } //自定义一个Person的函数模板进行对象之间的判断操作 //这样就不会与上面的函数模板发生冲突 //这个相当于在原来的模板扩充功能，功能增加了 template &lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2) { if (p1.m_Name == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age) { return true; } else { return false; } } void test01() { int a = 10; int b = 20; //判断两个数据是否相等 bool ret = myCompare(a, b); if (ret) { cout &lt;&lt; \"a==b\" &lt;&lt; endl; } else { cout &lt;&lt; \"a!=b\" &lt;&lt; endl; } } void test02() { Person p1(\"Tom\", 10); Person p2(\"Tom\", 10); //错误,这就是模板的局限性,无法识别用自定义的数据类型进行==操作 //第一种方法:可以在函数模板里面对==符号进行运算符重载 //第二种方法:可以再自定义一个Person类型的函数模板,让它优先走这个函数模板 bool ret = myCompare(p1, p2); if (ret) { cout &lt;&lt; \"p1==p2\" &lt;&lt; endl; } else { cout &lt;&lt; \"p1!=p2\" &lt;&lt; endl; } } int main() { // test01(); test02(); return 0; } 类模板 //类模板 #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; //建立一个通用类,类中的成员的数据类型是不确定的,只有在调用时才确定具体的类型 //第一个NameType代表名字的类型,第二个AgeType代表年龄的类型 //也就是说模板中可以定义两个不同的类型 template &lt;class NameType, class AgeType&gt; class Person { public: //构造函数 Person(NameType name, AgeType age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } //输出函数 void showPerson() { cout &lt;&lt; \"name:\" &lt;&lt; this-&gt;m_Name &lt;&lt; \" age:\" &lt;&lt; this-&gt;m_Age &lt;&lt; endl; } NameType m_Name; AgeType m_Age; }; void test01() { //通过模板创建对象,传入不同的类型给构造函数初始化属性 Person&lt;string, int&gt; p1(\"swk\", 999); //输出 p1.showPerson(); } int main() { test01(); return 0; } 类模板与函数模板的区别 //类模板与函数模板的区别 #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; //定义一个类模板 // template &lt;class NameType, class AgeType&gt; //第二种定义类模板的方式,指定数据类型,这样在调用模板类的时候只需要传入一个类型就行了 //另外一个类型已经在定义模板时定义好了 template &lt;class NameType, class AgeType = int&gt; class Person { public: Person(NameType name, AgeType age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } //输出函数 void showPerson() { cout &lt;&lt; \"name: \" &lt;&lt; this-&gt;m_Name &lt;&lt; \" age = \" &lt;&lt; this-&gt;m_Age &lt;&lt; endl; } NameType m_Name; AgeType m_Age; }; // 1.类模板没有自动类型推导的使用发生 void test01() { //错误,无法用自动类型推导的方式调用构造函数传值,只能用模板(显示指定类型)的方式 // Person p(\"swk\", 1000); //正确 Person&lt;string, int&gt; p(\"swk\", 1000); //输出 p.showPerson(); } void test02() { //因为在定义模板的时候已经指定了一个数据类型,所以在调用的时候只需要传入另一个类型就行了 Person&lt;string&gt; p(\"zbj\", 999); //输出 p.showPerson(); //注：如果默认参数传的是 char ，而你显示指定 int ，编译器仍可以进行隐式转换 } // 2.类模板在参数列表中可以有默认参数 int main() { // test01(); test02(); return 0; } 类模板中成员函数的创建时机 //类模板中成员函数的创建时机 #include &lt;iostream&gt; using namespace std; class Person1 { public: //成员函数 void showPerson1() { cout &lt;&lt; \"Person1 show\" &lt;&lt; endl; } }; class Person2 { public: //成员函数 void showPerson2() { cout &lt;&lt; \"Person2 show\" &lt;&lt; endl; } }; //类模板 template &lt;class T&gt; class MyClass { public: T obj; //类模板中的成员函数 void func1() { // T如果是上面两个类的类型就可以点出来他们的函数 obj.showPerson1(); } //类模板中的成员函数，在一开始并不创建，而是再模板调用时再生成 void func2() { obj.showPerson2(); } }; void test01() { //这算是一个类成员函数调用另一个类的成员函数 MyClass&lt;Person1&gt; m; m.func1(); MyClass&lt;Person2&gt; m2; m2.func2(); } int main() { test01(); return 0; } 类模板对象做函数参数 //类模板对象做函数参数 #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; // T1代表string类型,T2代表int类型 template &lt;class T1, class T2&gt; class Person { public: Person(T1 name, T2 age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } void showPerson() { cout &lt;&lt; \"name: \" &lt;&lt; this-&gt;m_Name &lt;&lt; \" age: \" &lt;&lt; this-&gt;m_Age &lt;&lt; endl; } T1 m_Name; T2 m_Age; }; // 1.指定传入类型,也就是定义什么就传什么给函数作为形参,通过引用的方式来接收 void printPerson1(Person&lt;string, int&gt; &amp;p) { p.showPerson(); } void test01() { Person&lt;string, int&gt; p(\"swk\", 100); printPerson1(p); } // 2.参数模板化,传递,将模板中定义好的类型作为参数的类型 template &lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp;p) { p.showPerson(); //通过typeid().name()可以看到函数自动推导出来的数据类型 cout &lt;&lt; \"T1 :\" &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; \"T2 :\" &lt;&lt; typeid(T2).name() &lt;&lt; endl; } void test02() { Person&lt;string, int&gt; p(\"zbj\", 90); printPerson2(p); } // 3.整个类模板化,也就是直接把Person定义为T,当传入参数时就自动推导出T是Person类型 template &lt;class T&gt; void printPerson3(T &amp;p) { p.showPerson(); //查看T的数据类型 cout &lt;&lt; \"T: \" &lt;&lt; typeid(T).name() &lt;&lt; endl; } void test03() { Person&lt;string, int&gt; p(\"tanshen\", 30); printPerson3(p); } int main() { // test01(); // test02(); test03(); return 0; } 类模板与继承 //类模板与继承 #include &lt;iostream&gt; using namespace std; //通过类模板创建一个父类 template &lt;class T&gt; class Base { public: T m; }; //子类继承模板父类 //错误,必须要知道父类中的T类型,才能继承给子类 // class Son : public Base //正确,直接告诉父类中的T是int类型,才可以继承 class Son : public Base&lt;int&gt; { public: }; void test01() { Son s1; } //如果想灵活的指定父类中的T类型,那么子类也需要变为模板类 //其实也就是在继承时把父类原本的模板类型T,抽象成下面的T2,T2就代表父类的T,T1就代表子类自己用的模板类型 //当函数调用时会把T2所接收的数据类型传给父类的T,让父类的T也等于这个类型 //看到孩子眼睛是黑色的，那就知道父亲眼睛也是黑色，同理 template &lt;class T1, class T2&gt; class Son2 : public Base&lt;T2&gt; { public: Son2() { cout &lt;&lt; \"T1: \" &lt;&lt; typeid(T1).name() &lt;&lt; endl &lt;&lt; \"T2: \" &lt;&lt; typeid(T2).name() &lt;&lt; endl; } T1 obj; }; void test02() { //通过模板创建一个子类的对象,其中会把char类型传给T2,而T2又代表父类的继承模板T //所以也会把char类型传给父类的T Son2&lt;int, char&gt; S2; } int main() { // test01(); test02(); return 0; } 类模板成员函数的类外实现 //类模板成员函数的类外实现 #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; template &lt;class T1, class T2&gt; class Person { public: //只留函数声明,函数的具体实现通过类外实现 Person(T1 name, T2 age); // { // this-&gt;m_Name = name; // this-&gt;m_Age = age; // } void showPerson(); // { // cout &lt;&lt; \"name: \" &lt;&lt; this-&gt;m_Name &lt;&lt; \" age: \" &lt;&lt; this-&gt;m_Age &lt;&lt; endl; // } T1 m_Name; T2 m_Age; }; //模板构造函数类外实现,要在函数声明时加上template和在::作用域的前面加上&lt;&gt;符号 template &lt;class T1, class T2&gt; Person&lt;T1, T2&gt;::Person(T1 name, T2 age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } //模板成员函数的类外实现 template &lt;class T1, class T2&gt; void Person&lt;T1, T2&gt;::showPerson() { cout &lt;&lt; \"name: \" &lt;&lt; this-&gt;m_Name &lt;&lt; \" age: \" &lt;&lt; this-&gt;m_Age &lt;&lt; endl; } void test01() { //通过类外实现模板构造函数的方式来创建对象 Person&lt;string, int&gt; P(\"Tom\", 20); P.showPerson(); } int main() { test01(); return 0; } 类模板类外实现的分文件编写 主文件分文件day13.cpp文件内容: //类模板类外实现的分文件编写 #include &lt;iostream&gt; using namespace std; //包含.cpp头文件的原因: //因为类模板的成员函数在调用时才会创建,所以编译器会先看到.h的文件内容 //但是编译器在没有看到.cpp文件的内容之前是无法识别.h的文件内容的,所以直接引用.h会报错 //#include \"day13_person.cpp\" //第二种解决方法:将.h和.cpp文件中的内容写到一起,将后缀改为.hpp文件 #include \"day13_person.hpp\" void test01() { Person&lt;string, int&gt; p(\"Jerry\", 18); p.showPerson(); } int main() { test01(); return 0; }day13_person.hpp文件内容: //hpp = h + cpp, //此文件的作用是把.h和.cpp分文件中的内容全部写到一起 //解决.h文件引入时模板冲突的问题 //防止头文件重复包含 #pragma once #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; template &lt;class T1, class T2&gt; class Person { public: //模板函数的声明 Person(T1 name, T2 age); void showPerson(); T1 m_Name; T2 m_Age; }; //模板构造函数的类外分文件实现 template &lt;class T1, class T2&gt; Person&lt;T1, T2&gt;::Person(T1 name, T2 age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } //模板成员函数的类外分文件实现 template &lt;class T1, class T2&gt; void Person&lt;T1, T2&gt;::showPerson() { cout &lt;&lt; \"name: \" &lt;&lt; this-&gt;m_Name &lt;&lt; \" age: \" &lt;&lt; this-&gt;m_Age &lt;&lt; endl; } 模板类与友元 //模板类与友元 #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; //通过全局函数,打印Person信息 //因为全局函数类外实现比较麻烦 //要先声明模板类让编译器知道有这个类存在 template &lt;class T1, class T2&gt; class Person; //再把全局函数的具体实现放到最上面让编译器看到 //类外实现全局函数,因为要在类外识别类内的T1和T2,所以要加template template &lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; p) { cout &lt;&lt; \"name wai: \" &lt;&lt; p.m_Name &lt;&lt; \" age wai: \" &lt;&lt; p.m_Age &lt;&lt; endl; } //最后才在类里面声明全局函数 //定义一个模板类 template &lt;class T1, class T2&gt; class Person { //全局函数,类内实现 //这个函数是全局函数，不是成员函数，他只是被类内调用了 //因为是私有想要类外调用 所以要加友元 加了友元 编译器才不管你类内类外 你就是全局函数 friend void printPerson(Person&lt;T1, T2&gt; p) { cout &lt;&lt; \"name: \" &lt;&lt; p.m_Name &lt;&lt; \" age: \" &lt;&lt; p.m_Age &lt;&lt; endl; } //全局函数,类外实现,类内声明 //加一个空模板的参数列表 //如果全局函数是类外实现,需要让编译器提前知道这个函数的存在 friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; p); public: Person(T1 name, T2 age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } private: T1 m_Name; T2 m_Age; }; void test01() { //调用类内全局函数 Person&lt;string, int&gt; p(\"Tom\", 20); printPerson(p); } void test02() { //调用类外全局函数 Person&lt;string, int&gt; p(\"Jorry\", 20); printPerson2(p); } int main() { // test01(); test02(); return 0; } 类模板案例-实现一个通用的数组类(分文件编写) 主文件分文件day15.cpp文件内容: //类模板案例-实现一个通用的数组类 #include &lt;iostream&gt; using namespace std; #include \"day15_MyArray.hpp\" //输出数组 void printIntArray(MyArray&lt;int&gt; &amp;arr) { for (int i = 0; i &lt; arr.getSize(); i++) { cout &lt;&lt; arr[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; } //测试数组 void test01() { //创建一个模板对象,调用有参构造赋值为5 MyArray&lt;int&gt; arr1(5); for (int i = 0; i &lt; 5; i++) { //利用尾插法向数组中插入数据 arr1.Push_Back(i); } cout &lt;&lt; \"arr1: \" &lt;&lt; endl; printIntArray(arr1); //输出数组的容量 cout &lt;&lt; \"arr1 area:\" &lt;&lt; arr1.getCapacity() &lt;&lt; endl; //输出数组的长度 cout &lt;&lt; \"arr1 size:\" &lt;&lt; arr1.getSize() &lt;&lt; endl; //测试类中的拷贝构造函数 MyArray&lt;int&gt; arr2(arr1); cout &lt;&lt; \"arr2: \" &lt;&lt; endl; printIntArray(arr2); //尾删 arr2.Pop_Back(); //输出尾删后的数组的容量 cout &lt;&lt; \"arr2 area:\" &lt;&lt; arr2.getCapacity() &lt;&lt; endl; //输出尾删后的数组的长度 cout &lt;&lt; \"arr2 size:\" &lt;&lt; arr2.getSize() &lt;&lt; endl; //测试函数重载,一开始arr3的容量是100 //后来等号赋值的时候会先将arr3中的数据清空 //然后再把arr1的数据赋给arr3 // MyArray&lt;int&gt; arr3(100); // arr3 = arr1; } //测试自定义的数据类型 class Person { public: Person(){}; Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } string m_Name; int m_Age; }; //输出对象 void printPersonArray(MyArray&lt;Person&gt; &amp;arr) { for (int i = 0; i &lt; arr.getSize(); i++) { cout &lt;&lt; \"name: \" &lt;&lt; arr[i].m_Name &lt;&lt; \" age: \" &lt;&lt; arr[i].m_Age &lt;&lt; endl; } } //测试自定义的数据类型 void test02() { //传入自定义的数据类型 MyArray&lt;Person&gt; arr(10); Person p1(\"swk\", 999); Person p2(\"zbj\", 30); Person p3(\"zs\", 20); Person p4(\"lisi\", 25); Person p5(\"wangwu\", 27); //将数据插入到数组中 arr.Push_Back(p1); arr.Push_Back(p2); arr.Push_Back(p3); arr.Push_Back(p4); arr.Push_Back(p5); //打印数组 printPersonArray(arr); //输出容量 cout &lt;&lt; \"arr area: \" &lt;&lt; arr.getCapacity() &lt;&lt; endl; //输出长度 cout &lt;&lt; \"arr size: \" &lt;&lt; arr.getSize() &lt;&lt; endl; } int main() { // test01(); test02(); return 0; }day15_MyArray.hpp文件内容: //写一个自己的通用的数组类 #pragma once #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; template &lt;class T&gt; class MyArray { public: //有参构造 参数 容量 MyArray(int capacity) { // cout &lt;&lt; \"Myarray open\" &lt;&lt; endl; this-&gt;m_Capacity = capacity; this-&gt;m_Size = 0; // new一个相等于数组容量的空间 this-&gt;pAddress = new T[this-&gt;m_Capacity]; } //拷贝构造函数,防止浅拷贝的问题 MyArray(const MyArray &amp;arr) { // cout &lt;&lt; \"Myarray copy\" &lt;&lt; endl; this-&gt;m_Capacity = arr.m_Capacity; this-&gt;m_Size = arr.m_Size; // this-&gt;pAddress = arr.pAddress; //深拷贝,重新在堆区创建一个空间 this-&gt;pAddress = new T[arr.m_Capacity]; //将arr中的数据都拷贝过来 for (int i = 0; i &lt; this-&gt;m_Size; i++) { this-&gt;pAddress[i] = arr.pAddress[i]; } } //重载等于符号,防止浅拷贝的问题 //返回一个引用来实现链式编程 MyArray &amp;operator=(const MyArray &amp;arr) { // cout &lt;&lt; \"Myarray operator=\" &lt;&lt; endl; //先判断原来堆区是否有数据,如果有先释放 if (this-&gt;pAddress != NULL) { delete[] this-&gt;pAddress; this-&gt;pAddress = NULL; this-&gt;m_Capacity = 0; this-&gt;m_Size = 0; } //拷贝 this-&gt;m_Capacity = arr.m_Capacity; this-&gt;m_Size = arr.m_Size; //深拷贝 this-&gt;pAddress = new T[arr.m_Capacity]; //把数组中的数据都拿过来 for (int i = 0; i &lt; this-&gt;m_Size; i++) { this-&gt;pAddress[i] = arr.pAddress[i]; } //将自身返回 return *this; } //尾插法 void Push_Back(const T &amp;val) { //判断容量是否等于大小 if (this-&gt;m_Capacity == this-&gt;m_Size) { //容量已满,无法插入 return; } //将数据插入到数组当中的最后一个位置 this-&gt;pAddress[this-&gt;m_Size] = val; //更新数组的大小 this-&gt;m_Size++; } //尾删法 void Pop_Back() { //让用户访问不到最后一个元素,即为尾删 if (this-&gt;m_Size == 0) { //如果数组里没有数据就不删,直接退出 return; } //数组的大小减一,则用户就访问不到最后一个下标了 this-&gt;m_Size--; } //通过下标的方式访问数组中的元素,也就是重载[]符号 //如果函数调用后还想作为左值存在则需要返回引用 arr[0] = 100; //把数据本身返回,再进行赋值的操作 T &amp;operator[](int index) { //返回数组中下标对应的数据 return this-&gt;pAddress[index]; } //返回数组的容量 int getCapacity() { return this-&gt;m_Capacity; } //返回数组有效数据的长度 int getSize() { return this-&gt;m_Size; } //析构函数 ~MyArray() { // cout &lt;&lt; \"Myarray end\" &lt;&lt; endl; if (this-&gt;pAddress != NULL) { //这里是对象数组而不是对象指针数组 //所以不需要写for循环去释放每一个数组元素 delete[] this-&gt;pAddress; this-&gt;pAddress = NULL; } } private: //指针指向堆区开辟的真实数组 T *pAddress; //记录数组的容量 int m_Capacity; //数组的元素个数(大小) int m_Size; };","categories":[{"name":"C++","slug":"C","permalink":"https://yswm-m.github.io/categories/C/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"学习","slug":"学习","permalink":"https://yswm-m.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"笔记","slug":"笔记","permalink":"https://yswm-m.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"C++小案例-职工管理系统","slug":"29-C++小案例-职工管理系统","date":"2022-09-15T02:12:00.000Z","updated":"2022-09-28T07:36:47.995Z","comments":true,"path":"posts/29.html","link":"","permalink":"https://yswm-m.github.io/posts/29.html","excerpt":"","text":"更多教程笔记请查看我的上一篇文章：点击跳转 此系统采用分文件编写，使用类与对象，纯虚函数，多态，继承实现，数据存储在.txt文本中 主文件抽象类老板类老板类实现员工类员工类实现经理类经理类实现管理类管理类实现main.cpp文件代码: // C++小案例-职工管理系统 #include &lt;iostream&gt; #include &lt;stdlib.h&gt; //引入存放着管理类的.h文件 #include \"workerManger.cpp\" #include \"employee.cpp\" #include \"manager.cpp\" #include \"boss.cpp\" using namespace std; int main() { //测试代码 //创建一个人的类指针 // Worker *worker = NULL; // //将指针指向普通员工 // worker = new Employee(1, \"zs\", 1); // //通过父类指针调用子类函数,输出岗位的具体职责 // worker-&gt;showInfo(); // //用完后要释放 // delete worker; // //再用父类的指针指向经理的子类 // worker = new Manager(2, \"lisi\", 2); // //调用经理的岗位具体描述 // worker-&gt;showInfo(); // delete worker; // //再用父类的指针指向老板的子类 // worker = new Boss(3, \"wangwu\", 3); // worker-&gt;showInfo(); // delete worker; //实例化管理者对象 WorkerManager wm; //用来存储用户的选项 char choice = 0; while (true) { //调用管理类的成员函数 //展示菜单的成员函数 wm.Show_Menu(); //提示用户输入 cout &lt;&lt; \"Please enter your choice: \" &lt;&lt; endl; //接收用户的选项 cin &gt;&gt; choice; switch (choice) { case '0': //退出系统 wm.ExitSystem(); break; case '1': //增加职工 //调用定义好的添加函数 wm.Add_Emp(); break; case '2': //显示职工 wm.Show_Emp(); break; case '3': //删除职工 /* { //测试, // case语句里要加{}代码块才能定义变量 int ret = wm.IsExist(5); if (ret != -1) { //输出职工存在 cout &lt;&lt; \"Elempty yes\" &lt;&lt; endl; } else { //职工不存在 cout &lt;&lt; \"No Elempty\" &lt;&lt; endl; } break; } */ wm.Del_Emp(); break; case '4': //修改职工 wm.Mod_Emp(); break; case '5': //查找职工 wm.Find_Emp(); break; case '6': //排序职工 wm.Sort_Emp(); break; case '7': //清空文档 wm.Clean_File(); break; default: //输入错误直接清屏 system(\"cls\"); break; } } return 0; }worker.h文件代码: //此文件专门用来存放抽象类 #pragma once #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; //职工抽象类 class Worker { public: //显示个人信息,纯虚函数 virtual void showInfo() = 0; //获取岗位名称 virtual string getDeptName() = 0; //职工编号 int m_Id; //职工姓名 string m_Name; //部门编号 int m_DeptId; };boss.h文件代码: //此文件用来存放老板类 //此文件专门用来存放经理的类定义 #pragma once #include &lt;iostream&gt; using namespace std; //因为要有一个继承的操作,所以要包含父类的头文件 #include \"worker.h\" //在.h文件里面写类的定义的时候只需要写声明就好 //具体实现在.cpp文件里面 //老板类 class Boss : public Worker { public: //注意:在父类里函数可以在后面写=0 //但是在子类的函数定义后面不能写=0,因为要在其他文件中类外写具体实现 //构造函数 Boss(int id, string name, int dId); //显示个人信息,纯虚函数 virtual void showInfo(); //获取岗位名称 virtual string getDeptName(); };boss.cpp文件代码: //此文件用来实现老板类的成员函数的具体实现 #include \"boss.h\" //构造函数 Boss::Boss(int id, string name, int dId) { this-&gt;m_Id = id; this-&gt;m_Name = name; this-&gt;m_DeptId = dId; } //显示个人信息 void Boss::showInfo() { cout &lt;&lt; \"Employee_id: \" &lt;&lt; this-&gt;m_Id &lt;&lt; \"\\tEmployee_Name:\" &lt;&lt; this-&gt;m_Name &lt;&lt; \"\\tEmployee_DId:\" &lt;&lt; this-&gt;getDeptName() &lt;&lt; \"\\tjob description: Manage all affairs of the company\" &lt;&lt; endl; } //获取岗位名称 string Boss::getDeptName() { //返回老板的岗位名称 //不转string类型也行,因为会默认隐式转换 return string(\"Boss\"); }employee.h文件代码: //普通职工文件 #pragma once #include &lt;iostream&gt; #include \"worker.h\" using namespace std; //用普通职工类去继承在.h头文件里定义好的抽象类 class Employee : public Worker { public: //构造函数 //形参分别是职工的编号,职工的名字,所属部门的编号 Employee(int id, string name, int dId); //重写父类中的纯虚函数 //显示个人信息 virtual void showInfo(); //获取岗位名称 virtual string getDeptName(); };employee.cpp文件代码: //这个文件主要用于.h文件中的职工类的函数的具体实现 #include \"employee.h\" //类外实现函数的具体实现 //构造函数 Employee::Employee(int id, string name, int dId) { //这里的m_Id属性是从work.h文件里继承过来的 this-&gt;m_Id = id; // this的特性是谁调用this,this就指向谁 //也就是说当创建了一个Employee职工类的对象的时候,如果对象 //调用了构造函数传参,那么this就指向那个对象本身 this-&gt;m_Name = name; this-&gt;m_DeptId = dId; } //重写父类中的纯虚函数 //显示个人信息 void Employee::showInfo() { cout &lt;&lt; \"Employee_id: \" &lt;&lt; this-&gt;m_Id &lt;&lt; \"\\tEmployee_Name:\" &lt;&lt; this-&gt;m_Name &lt;&lt; \"\\tEmployee_DId:\" &lt;&lt; this-&gt;getDeptName() &lt;&lt; \"\\tjob description: Complete the tasks assigned above\" &lt;&lt; endl; //因为岗位并不是用数字表示的,所以要通过函数返回具体的岗位 //后一个参数是岗位职责,也就是岗位描述,完成上面安排的任务 } //获取岗位名称 string Employee::getDeptName() { //返回一个普通职工的岗位,因为默认返回字符串是char *类型,所以要转换成string类型 return string(\"employee\"); }manager.h文件代码: //此文件专门用来存放经理的类定义 #pragma once #include &lt;iostream&gt; using namespace std; //因为要有一个继承的操作,所以要包含父类的头文件 #include \"worker.h\" //在.h文件里面写类的定义的时候只需要写声明就好 //具体实现在.cpp文件里面 //经理类 class Manager : public Worker { public: //构造函数 Manager(int id, string name, int dId); //其实在继承中子类不需要在函数前面加上virtual关键字变成纯虚函数 //因为父类当中有纯虚函数,子类继承过来就自动是纯虚函数了 //不过写了也没啥影响,但是在其他文件中通过类外写具体函数实现的时候 //要记得把virtual关键字去掉 //显示个人信息,纯虚函数 virtual void showInfo(); //获取岗位名称 virtual string getDeptName(); };manager.cpp文件代码: //此文件用来写经理类的成员函数具体实现 #include \"manager.h\" //构造函数 Manager::Manager(int id, string name, int dId) { this-&gt;m_Id = id; this-&gt;m_Name = name; this-&gt;m_DeptId = dId; } //显示个人信息 void Manager::showInfo() { cout &lt;&lt; \"Employee_id: \" &lt;&lt; this-&gt;m_Id &lt;&lt; \"\\tEmployee_Name:\" &lt;&lt; this-&gt;m_Name &lt;&lt; \"\\tEmployee_DId:\" &lt;&lt; this-&gt;getDeptName() &lt;&lt; \"\\tjob description: Complete tasks assigned by boss and distribute tasks to ordinary employees\" &lt;&lt; endl; } //获取岗位名称 string Manager::getDeptName() { //返回经理的岗位名称 //不转string类型也行,因为会默认隐式转换 return string(\"manager\"); }workerManager.h文件代码: //这个文件专门用来存放管理类 //#pragma once可以防止头文件重复包含 #pragma once #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; //因为要定义一个职工数组,所以需要引入worker.h头文件 #include \"worker.h\" #include \"employee.h\" #include \"manager.h\" #include \"boss.h\" //文件操作的头文件 #include &lt;fstream&gt; //定义一个宏用来保存文件路径 #define FILENAME \"class_03/empFile.txt\" //管理类 class WorkerManager { public: //构造函数 WorkerManager(); //展示菜单的函数 void Show_Menu(); //退出功能 void ExitSystem(); //记录职工的人数 int m_EmpNum; //职工数组指针 Worker **m_EmpArray; //添加职工的函数声明,在.cpp文件中会做具体实现 void Add_Emp(); //保存文件,在.cpp文件中会做具体实现 void save(); //判断文件是否为空 bool m_FileIsEmpty; //统计文件中的人数 int get_EmpNum(); //初始化员工 void init_Emp(); //显示职工 void Show_Emp(); //删除职工 void Del_Emp(); //判断职工是否存在,如果存在则返回职工所在数组中的位置,不存在返回-1 int IsExist(int id); //修改职工 void Mod_Emp(); //查找职工 void Find_Emp(); //按照职工的编号排序 void Sort_Emp(); //清空文件 void Clean_File(); //快速排序升序 void quick_sort1(int l, int r); //快速排序降序 void quick_sort2(int l, int r); //析构函数 ~WorkerManager(); };workerManager.cpp文件代码: //此文件用来引入另一个.h的头文件,那里面存放着管理类 //并且在引入了父类之后需要在这个文件里,也就是类外文件写函数的具体实现 #include \"workerManager.h\" //调用.h文件里面的管理类的构造函数 WorkerManager::WorkerManager() { //读文件 ifstream ifs; ifs.open(FILENAME, ios::in); //在构造函数时，在检测文件是否存在前对文件是否为空初始化为false this-&gt;m_FileIsEmpty = false; //判断文件是否打开成功 if (!(ifs.is_open())) { //文件不存在 // cout &lt;&lt; \"No!\" &lt;&lt; endl; //初始化属性 //也就是一创建对象就调用这个构造函数 //将记录的人数初始化为0 this-&gt;m_EmpNum = 0; //初始化数组指针 this-&gt;m_EmpArray = NULL; //初始化文件是否为空 this-&gt;m_FileIsEmpty = true; ifs.close(); return; } //判断文件存在但是数据为空 char ch; //通过ifs对象函数不停的往字符里面读数据 ifs &gt;&gt; ch; //如果读到EOF就表示读完了 //先读一个,然后用eof判断是不是已经没了，读掉一个就没了，说明是空的 if (ifs.eof()) { //文件为空 // cout &lt;&lt; \"No NULL!\" &lt;&lt; endl; //初始化属性 //也就是一创建对象就调用这个构造函数 //将记录的人数初始化为0 this-&gt;m_EmpNum = 0; //初始化数组指针 this-&gt;m_EmpArray = NULL; //初始化文件是否为空,如果文件不存在或者文件没有数据就置为true this-&gt;m_FileIsEmpty = true; ifs.close(); return; } //当文件存在,并且也有记录数据,则调用定义好的函数统计文件中的数据 int num = this-&gt;get_EmpNum(); //输出职工人数 // cout &lt;&lt; \"EmpNum: \" &lt;&lt; num &lt;&lt; endl; //更新职工的人数为文件中的数据 this-&gt;m_EmpNum = num; //创建一个职工数组,数组的长度是文件中的数据的大小 this-&gt;m_EmpArray = new Worker *[this-&gt;m_EmpNum]; //将文件中的数据,存到数组中 this-&gt;init_Emp(); //测试代码 // for (int i = 0; i &lt; this-&gt;m_EmpNum; i++) // { // //输出文件存入到数组中的数据 // cout &lt;&lt; \"id: \" &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Id // &lt;&lt; \" name: \" &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Name // &lt;&lt; \" DepId: \" &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_DeptId &lt;&lt; endl; // } } //展示菜单 void WorkerManager::Show_Menu() { cout &lt;&lt; \"***********************************************************\" &lt;&lt; endl; //欢迎使用职工管理系统! cout &lt;&lt; \"******** Welcome to the staff management system! **********\" &lt;&lt; endl; // 0.退出管理程序 cout &lt;&lt; \"************* 0. Exit the management program **************\" &lt;&lt; endl; // 1.增加职工信息 cout &lt;&lt; \"************* 1. Increase employee information ************\" &lt;&lt; endl; // 2.显示职工信息 cout &lt;&lt; \"************* 2. Display employee information *************\" &lt;&lt; endl; // 3.删除离职职工 cout &lt;&lt; \"************* 3. Delete the former employees **************\" &lt;&lt; endl; // 4.修改职工信息 cout &lt;&lt; \"************* 4. Modify employee information **************\" &lt;&lt; endl; // 5.查找职工信息 cout &lt;&lt; \"************* 5. Look up employee information *************\" &lt;&lt; endl; // 6.按照编号排序 cout &lt;&lt; \"******************** 6. Sort by number ********************\" &lt;&lt; endl; // 7.清空所有文档 cout &lt;&lt; \"******************** 7. Clear all documents ***************\" &lt;&lt; endl; cout &lt;&lt; \"***********************************************************\" &lt;&lt; endl; cout &lt;&lt; endl; } //退出系统的具体实现 void WorkerManager::ExitSystem() { //提示用户选择了退出 cout &lt;&lt; \"Welcome to use next time\" &lt;&lt; endl; system(\"pause\"); //退出程序 exit(0); } //添加职工的具体实现 void WorkerManager::Add_Emp() { //提示用户请输入要添加的职工的数量 cout &lt;&lt; \"Please enter the number of employees to be added\" &lt;&lt; endl; //保存用户的输入数量 int addNum = 0; cin &gt;&gt; addNum; if (addNum &gt; 0) { //如果大于0的话就添加 //计算添加新空间的大小,新空间大小=原来的记录的人数+新增的人数 int newSize = this-&gt;m_EmpNum + addNum; //开辟新空间,这是一个动态数组,通过动态的在堆区开辟数据 //返回的是指向这块内存的一级指针,要用二级指针接收它 Worker **newSpace = new Worker *[newSize]; //将原来空间下的数据,拷贝到新空间下 if (this-&gt;m_EmpArray != NULL) { //判断如果原来数组中有数据则把原来数组中的数据全部拷贝到新开辟的数组中 for (int i = 0; i &lt; this-&gt;m_EmpNum; i++) { newSpace[i] = this-&gt;m_EmpArray[i]; } } //批量添加新数据 for (int i = 0; i &lt; addNum; i++) { //职工编号 int id; //职工姓名 string name; //部门选择 int dSelect; //提示用户请输入第i+1个新职工的编号 cout &lt;&lt; \"Please enter the first \" &lt;&lt; i + 1 &lt;&lt; \" Number of new employee:\" &lt;&lt; endl; cin &gt;&gt; id; //提示用户请输入第i+1个新职工的姓名 cout &lt;&lt; \"Please enter the first \" &lt;&lt; i + 1 &lt;&lt; \" Name of new employee:\" &lt;&lt; endl; cin &gt;&gt; name; //提示用户请输入第i+1个新职工的部门 cout &lt;&lt; \"Please enter the first \" &lt;&lt; i + 1 &lt;&lt; \" dSelect of new employee:\" &lt;&lt; endl; cout &lt;&lt; \"1.General Trade Union\" &lt;&lt; endl; cout &lt;&lt; \"2.Manager\" &lt;&lt; endl; cout &lt;&lt; \"3.Boss\" &lt;&lt; endl; cin &gt;&gt; dSelect; Worker *worker = NULL; switch (dSelect) { case 1: /* 如果为1则表示输入是一个普通员工 */ worker = new Employee(id, name, 1); break; case 2: /* 如果为1则表示输入是一个普通员工 */ worker = new Manager(id, name, 1); break; case 3: /* 如果为1则表示输入是一个普通员工 */ worker = new Boss(id, name, 1); break; default: break; } //将创建职工的指针,保存到数组中 //通过+i,在数组中找到要添加的人的具体位置 //也就是如果要加一个人,那么就加0,那个人就被加在0号位置,如果要加第二个人 //那么+i就是加1,那个人就被加在2号位置 newSpace[this-&gt;m_EmpNum + i] = worker; } //添加完成,释放原有的空间,这是释放数组的写法 delete[] this-&gt;m_EmpArray; //更改新空间的指向 //因为原来的空间被释放了后m_EmpArray指针就可以指向新的数组空间 this-&gt;m_EmpArray = newSpace; //更新新的职工人数 // newSize是在最上面定义的新空间的大小 // newSpace相当于把原来的复制了一份再加上新增的数据，所以可以释放掉原来的 this-&gt;m_EmpNum = newSize; //更新职工不为空的情况标志 this-&gt;m_FileIsEmpty = false; //提示添加成功 cout &lt;&lt; \"success add: \" &lt;&lt; addNum &lt;&lt; \" new Empwork!\" &lt;&lt; endl; //成功添加后保存到文件中 this-&gt;save(); } else { //如果小于0就提示无法添加 cout &lt;&lt; \"NO\" &lt;&lt; endl; } //当添加完成了提示用户按任意键清屏 system(\"pause\"); system(\"cls\"); } //保存文件 void WorkerManager::save() { ofstream ofs; //用输出的方式来打开文件---也就是写文件 ofs.open(FILENAME, ios::out); //将每个人的数据写入到文件中 for (int i = 0; i &lt; this-&gt;m_EmpNum; i++) { //利用ofs对数组里面每一行的数据通过文件写入 ofs &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Id &lt;&lt; \" \" &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Name &lt;&lt; \" \" &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_DeptId &lt;&lt; endl; } //关闭文件 ofs.close(); } //统计文件中的人数 int WorkerManager::get_EmpNum() { ifstream ifs; //打开文件--读 ifs.open(FILENAME, ios::in); int id; string name; int dId; int num = 0; //将一行内所有数据全部读到手 while (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; dId) { //统计人数变量 num++; } //将统计到的人数返回 return num; } //类外实现初始化员工 void WorkerManager::init_Emp() { ifstream ifs; //以读的方式打开 ifs.open(FILENAME, ios::in); int id; string name; int dId; //用来存放数组的下标 int index = 0; while (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; dId) { //创建一个父类指针 Worker *worker = NULL; //普通员工 if (dId == 1) { //通过父类指针调用子类函数,创建一个普通员工 worker = new Employee(id, name, dId); } else if (dId == 2) //经理 { worker = new Manager(id, name, dId); } else { //老板 worker = new Boss(id, name, dId); } //第一次将第一个人放入数组中第0号位置,第二次++将第二个人放到第1号位置 this-&gt;m_EmpArray[index] = worker; index++; } //关闭文件 ifs.close(); } //显示职工 void WorkerManager::Show_Emp() { //判断文件是否存在 if (this-&gt;m_FileIsEmpty) { //如果为true即为不存在 cout &lt;&lt; \"No NULL\" &lt;&lt; endl; } else { for (int i = 0; i &lt; m_EmpNum; i++) { //利用多态调用程序接口 this-&gt;m_EmpArray[i]-&gt;showInfo(); } } //按任意键后清屏 system(\"pause\"); system(\"cls\"); } //删除职工 void WorkerManager::Del_Emp() { //判断文件是否存在 if (this-&gt;m_FileIsEmpty) { cout &lt;&lt; \"No NULL\" &lt;&lt; endl; } else { //按照职工编号删除,提示用户输入要删除的数据的编号 cout &lt;&lt; \"please cin delete Id:\" &lt;&lt; endl; int id = 0; cin &gt;&gt; id; //判断要删除的职工的id存不存在 int index = this-&gt;IsExist(id); //说明职工存在,并且要删除掉index位置上的职工 if (index != -1) { //数组删除本质上就是数据往前移 //数组从0开始所以数组的总长度要减一 for (int i = index; i &lt; this-&gt;m_EmpNum - 1; i++) { //数据前移 this-&gt;m_EmpArray[i] = this-&gt;m_EmpArray[i + 1]; } //更新数组中记录的人员个数 this-&gt;m_EmpNum--; //同步更新到文件中 this-&gt;save(); cout &lt;&lt; \"delete success!\" &lt;&lt; endl; } else { //如果没有找到这个人就提示删除失败 cout &lt;&lt; \"delete error!\" &lt;&lt; endl; } } system(\"pause\"); system(\"cls\"); } //判断职工是否存在,如果存在则返回职工所在数组中的位置,不存在返回-1 int WorkerManager::IsExist(int id) { int index = -1; for (int i = 0; i &lt; this-&gt;m_EmpNum; i++) { //遍历数组判断如果数组中员工的id等于传入的id则找到了这个职工 if (this-&gt;m_EmpArray[i]-&gt;m_Id == id) { index = i; break; } } return index; } //修改职工 void WorkerManager::Mod_Emp() { //判断是否为空 if (this-&gt;m_FileIsEmpty) { //文件不存在 cout &lt;&lt; \"NO NULL\" &lt;&lt; endl; } else { //请输入要修改的职工的编号 cout &lt;&lt; \"please cin edit id: \" &lt;&lt; endl; int id; cin &gt;&gt; id; //判断要修改的职工编号是否存在 int ret = this-&gt;IsExist(id); if (ret != -1) { //查找到编号的职工 //释放数组当中原来的数据,为了让新的数据替换 delete this-&gt;m_EmpArray[ret]; int newId = 0; string newName = \"\"; int dSelect = 0; //提示用户查找到了职工,让用户输入新的职工号 cout &lt;&lt; \"find: \" &lt;&lt; id &lt;&lt; \"emelpty edit new Number:\" &lt;&lt; endl; cin &gt;&gt; newId; //提示用户查找到了职工,让用户输入新的职工姓名 cout &lt;&lt; \"find emelpty edit new name:\" &lt;&lt; endl; cin &gt;&gt; newName; //提示用户查找到了职工,让用户输入新的职工岗位 cout &lt;&lt; \"find emelpty edit new dSelect:\" &lt;&lt; endl; cout &lt;&lt; \"1.General Trade Union\" &lt;&lt; endl; cout &lt;&lt; \"2.Manager\" &lt;&lt; endl; cout &lt;&lt; \"3.Boss\" &lt;&lt; endl; cin &gt;&gt; dSelect; //创建一个父类的指针 Worker *worker = NULL; switch (dSelect) { case 1: worker = new Employee(newId, newName, dSelect); break; case 2: worker = new Manager(newId, newName, dSelect); break; case 3: worker = new Boss(newId, newName, dSelect); break; default: break; } //更新数据 到数组中 this-&gt;m_EmpArray[ret] = worker; //修改成功 cout &lt;&lt; \"edit success!\" &lt;&lt; endl; //保存到文件中 this-&gt;save(); } else { //修改失败 cout &lt;&lt; \"edit error\" &lt;&lt; endl; } } system(\"pause\"); system(\"cls\"); } //查找职工 void WorkerManager::Find_Emp() { //文件不存在 if (this-&gt;m_FileIsEmpty) { cout &lt;&lt; \"NO NULL\" &lt;&lt; endl; } else { //请输入查找的方式 cout &lt;&lt; \"please cin find function: \" &lt;&lt; endl; //按照职工的编号查找 cout &lt;&lt; \"1.elempty Id: \" &lt;&lt; endl; //按照职工的姓名查找 cout &lt;&lt; \"2.elempty name: \" &lt;&lt; endl; int select = 0; cin &gt;&gt; select; if (select == 1) { //按照编号查找 int id; //请输入职工的编号 cout &lt;&lt; \"please cin elempty id: \" &lt;&lt; endl; cin &gt;&gt; id; //判断这个职工的编号是否存在 int ret = IsExist(id); if (ret != -1) { //找到职工 cout &lt;&lt; \"find success!\" &lt;&lt; endl; //将找到的职工显示 this-&gt;m_EmpArray[ret]-&gt;showInfo(); } else { //如果找不到就提示查找失败 cout &lt;&lt; \"find error\" &lt;&lt; endl; } } else if (select == 2) { //按照姓名查找 string name; cout &lt;&lt; \"please cin find name\" &lt;&lt; endl; cin &gt;&gt; name; //判断是否查找成功的标志 //默认未找到 bool flag = false; for (int i = 0; i &lt; m_EmpNum; i++) { if (this-&gt;m_EmpArray[i]-&gt;m_Name == name) { //查找成功,输出找到的那个人的Id号 cout &lt;&lt; \"find success elempty Id:\" &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Id &lt;&lt; \"elempty All:\" &lt;&lt; endl; //如果进来了这个循环就表示找到了这个人 flag = true; //调用显示信息的接口,输出关于那个编号的人的所有信息 this-&gt;m_EmpArray[i]-&gt;showInfo(); } } //如果循环结束后依然等于false就表示查找失败 if (flag == false) { //查找失败 cout &lt;&lt; \"find error\" &lt;&lt; endl; } } else { //输入错误 cout &lt;&lt; \"cin error\" &lt;&lt; endl; } } system(\"pause\"); system(\"cls\"); } //按照职工的编号排序 void WorkerManager::Sort_Emp() { //文件不存在 if (this-&gt;m_FileIsEmpty) { cout &lt;&lt; \"No NULL\" &lt;&lt; endl; system(\"pause\"); system(\"cls\"); } else { //提示用户请选择排序的方式 cout &lt;&lt; \"please Sort function:\" &lt;&lt; endl; //按照职工的编号进行升序排序 cout &lt;&lt; \"1.an elempty Id a&lt;b\" &lt;&lt; endl; //按照职工的编号进行降序排序 cout &lt;&lt; \"2.an elempty Id a&gt;b\" &lt;&lt; endl; //接受用户的选择 int select = 0; cin &gt;&gt; select; // //选择排序算法 // for (int i = 0; i &lt; m_EmpNum; i++) // { // //声明一个最小值或者最大值的下标 // int minOrMax = i; // for (int j = i + 1; j &lt; this-&gt;m_EmpNum; j++) // { // //升序 // if (select == 1) // { // if (this-&gt;m_EmpArray[minOrMax]-&gt;m_Id &gt; this-&gt;m_EmpArray[j]-&gt;m_Id) // { // minOrMax = j; // } // } // else //降序 // { // if (this-&gt;m_EmpArray[minOrMax]-&gt;m_Id &lt; this-&gt;m_EmpArray[j]-&gt;m_Id) // { // minOrMax = j; // } // } // } // //判断一开始认定的最小值或最大值 是否是 计算的最小值或最大值 如果不是 交换数据 // if (i != minOrMax) // { // Worker *temp = this-&gt;m_EmpArray[i]; // this-&gt;m_EmpArray[i] = this-&gt;m_EmpArray[minOrMax]; // this-&gt;m_EmpArray[minOrMax] = temp; // } // } //快速排序 if (select == 1) { this-&gt;quick_sort1(0, this-&gt;m_EmpNum - 1); } else { this-&gt;quick_sort2(0, this-&gt;m_EmpNum - 1); } //排序成功,输出排序后的结果 cout &lt;&lt; \"Sort success! Sort All: \" &lt;&lt; endl; //将排序后的结果保存到文件中 this-&gt;save(); //输出排序后的结果 this-&gt;Show_Emp(); //在Show_Emp()输出函数中已经做了清屏的操作,所以在下面就不用写了 } } //快速排序类外实现 void WorkerManager::quick_sort1(int l, int r) { if (l &gt;= r) { return; } int i = l - 1, j = r + 1; Worker *x = this-&gt;m_EmpArray[l + (r - l) / 2]; while (i &lt; j) { do { ++i; } while (this-&gt;m_EmpArray[i]-&gt;m_Id &lt; x-&gt;m_Id); do { --j; } while (this-&gt;m_EmpArray[j]-&gt;m_Id &gt; x-&gt;m_Id); if (i &lt; j) { swap(this-&gt;m_EmpArray[i], this-&gt;m_EmpArray[j]); } } quick_sort1(l, j); quick_sort1(j + 1, r); } //快速排序类外实现 void WorkerManager::quick_sort2(int l, int r) { if (l &gt;= r) { return; } int i = l - 1, j = r + 1; Worker *x = this-&gt;m_EmpArray[l + (r - l) / 2]; while (i &lt; j) { do { ++i; } while (this-&gt;m_EmpArray[i]-&gt;m_Id &gt; x-&gt;m_Id); do { --j; } while (this-&gt;m_EmpArray[j]-&gt;m_Id &lt; x-&gt;m_Id); if (i &lt; j) { swap(this-&gt;m_EmpArray[i], this-&gt;m_EmpArray[j]); } } quick_sort2(l, j); quick_sort2(j + 1, r); } //清空文件 void WorkerManager::Clean_File() { //提示用户是否确定清空 cout &lt;&lt; \"confirm clear?\" &lt;&lt; endl; cout &lt;&lt; \"1.Yes\" &lt;&lt; endl; cout &lt;&lt; \"2.No\" &lt;&lt; endl; //接收用户的输入 int select = 0; cin &gt;&gt; select; if (select == 1) { //清空文件,在ofs构造函数中就指定文件路径 // trunc代表删除文件后重新创建 ofstream ofs(FILENAME, ios::trunc); ofs.close(); //清空数组 if (this-&gt;m_EmpArray != NULL) { //删除堆区的每个职工对象 for (int i = 0; i &lt; this-&gt;m_EmpNum; i++) { delete this-&gt;m_EmpArray[i]; this-&gt;m_EmpArray[i] = NULL; } //删除堆区的数组指针 delete[] this-&gt;m_EmpArray; //删除完后将指针置为空 this-&gt;m_EmpArray = NULL; //将表示数组长度的变量等于0 this-&gt;m_EmpNum = 0; //将判断文件是否为空的标识为true; this-&gt;m_FileIsEmpty = true; } cout &lt;&lt; \"clear success!\" &lt;&lt; endl; } system(\"pause\"); system(\"cls\"); } //类外实现析构函数 WorkerManager::~WorkerManager() { //对象销毁前将创建的数组释放掉 //再将数组指针置为空 //判断如果数组不为空 if (this-&gt;m_EmpArray != NULL) { //要先清空内部的数组元素，再清空数组,因为数组元素也是new出来的 for (int i = 0; i &lt; this-&gt;m_EmpNum; i++) { //将数组当中的每一个元素都置为空 if (this-&gt;m_EmpArray[i] != NULL) { delete this-&gt;m_EmpArray[i]; } } delete[] this-&gt;m_EmpArray; this-&gt;m_EmpArray = NULL; } }","categories":[{"name":"C++","slug":"C","permalink":"https://yswm-m.github.io/categories/C/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"学习","slug":"学习","permalink":"https://yswm-m.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"笔记","slug":"笔记","permalink":"https://yswm-m.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"案例","slug":"案例","permalink":"https://yswm-m.github.io/tags/%E6%A1%88%E4%BE%8B/"}]},{"title":"C++自学笔记","slug":"07-C++自学笔记","date":"2022-09-15T02:10:00.000Z","updated":"2022-09-30T10:13:05.499Z","comments":true,"path":"posts/7.html","link":"","permalink":"https://yswm-m.github.io/posts/7.html","excerpt":"","text":"C++自学之旅开始！ 视频链接 常量： #define Day 7 const int a=12; 常量不可修改 系统随机生成数： int num=rand()%100+1//生成1~100之间的随机数 求有7的数： if(i%7==0||i%10==7||i/10==7)//倍数，个位，十位 乘法口诀表： for(int i=1;i&lt;=9;i++) { for(int j=1;j&lt;=i;j++) { cout&lt;&lt;j&lt;&lt;\" * \"&lt;&lt;i&lt;&lt;\"=\"&lt;&lt;j*i&lt;&lt;\" \"; } } 如果是奇数输出，偶数不输出： for(int i=0;i&lt;=100;i++) { if(i%2==0) { continue; } cout&lt;&lt;i&lt;&lt;endl; } goto goto语句：无条件的跳转代码 goto后面是一个标记，如果标记存在则执行到goto语句时自动跳转到标记语句 #include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; \"1\" &lt;&lt; endl; /* goto语句：无条件的跳转代码 goto后面是一个标记，如果标记存在则执行到goto语句时自动跳转到标记语句 */ goto FLAG; // goto会直接跳到FLAG语句执行FLAG下面的代码 cout &lt;&lt; \"2\" &lt;&lt; endl; cout &lt;&lt; \"3\" &lt;&lt; endl; FLAG: cout &lt;&lt; \"4\" &lt;&lt; endl; cout &lt;&lt; \"5\" &lt;&lt; endl; return 0; } 数组找最大值： int arr[5]={300,500,400,200,250}; int max=0; for(int i=0;i&lt;5;i++) { if(arr[i]&gt;max) max=arr[i]; } cout&lt;&lt;max&lt;&lt;endl; 数组逆转： int arr[5]={33,77,99,88,100}; int start=0; int end=sizeof(arr)/sizeof(arr[0])-1;//数组长度 while(start&lt;end){//只要起始位置小于结束位置 int temp=arr[start]; arr[start]=arr[end]; arr[end]=temp; start++; end--; } 二维数组定义方式： int arr[2][3]=//行数是可以省略的，列数不能 { {1,2,3}, {4,5,6} }; 算出二维数组的行数和列数： sizeof(arr)/sizeof(arr[0])//行数 sizeof(arr[0])/sizeof(arr[0][0])//列数 统计成绩： int arr[3][3]= { {100,100,100}; {50,60,80}; {60,70,80}; }; string names[3]={\"张三\",\"李四\",\"王五\"}; for(int i=0;I&lt;3;i++) { int sum=0; for(int j=0;j&lt;3;j++) { sum+=arr[i][j]; } cout&lt;&lt;names[i]&lt;&lt;\":\"&lt;&lt;sum&lt;&lt;endl; } 函数的分文件： 创建一个.h的头文件，在头文件中写函数的声明,在分文件中写函数的具体实现： 头文件分文件主文件在外部文件定义就可以使用了,先在.h文件声明： day03_fun.h文件代码： //这是.h文件 #include &lt;iostream&gt;//必须要包含这个引用这个文件的cpp //另一个文件才能使用cout using namespace std; void fun(int a,int b);然后在.cpp编写函数代码,再在主文件中引用并调用函数名称。 day03_fun.cpp文件代码: //这是另一个.cpp文件 #include \"day03_fun.h\"//只能是\"\"号不能是&lt;&gt;,\"\"代表自定义的文件 void fun(int a,int b) { int temp=a; a=b; b=temp; cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b&lt;&lt;endl; }day03.cpp文件代码： //这是主.cpp文件 #include &lt;iostream&gt; #include \"day03_fun.cpp\" using namespace std; int main() { int a = 10, b = 20; //在.h文件中定义函数声明,在.cpp文件中编写函数具体实现的代码,再在这个文件中引入.cpp文件就可以直接使用这个函数 fun(a, b); return 0; } 指针 指针就是一个地址，通过指针可以来保存地址 定义一个指针改变变量的值: int a=10; int * p; p=&amp;a; *p=1000; 这时a的值已改变为1000; 输出a的值和*p的值都是1000 指针一般占4个字节，64位下占8个字节 空指针： 指针变量指向内存中编号为0的空间，用途是初始化指针变量,空指针所指向的空间是不可访问的 int * p=NULL;//这就是空指针 *p=100;//此条是错误的,空指针不可以访问,因为内存编号为0~255是系统占用内存，不可访问。 野指针：指针指向了没有权利操纵的一块内存 int * p=(int *)0x1110;//这就是野指针,指针指向了一块没有申请过的空间。 const修饰指针：常量指针 const int * p=&amp;a;//这就是常量指针,在指针前面加上const就是常量指针，特点：指针的指向可以修改，但是指针指向的值不可以改： *p=20;//这条是错的，指针指向的值不可以改 p=&amp;b;//正确，指针的指向可以改 const修饰常量：指针常量 int * const p=&amp;a;//这就是指针常量，特点：指针的指向不可以改，指针指向的值可以改 *p=20;//正确，指向的值可以改 p=&amp;b;//这条是错误的，指针的指向不可以改 const即修饰指针又修饰常量 const int * const p=&amp;a;//这就是即修饰指针又修饰常量，特点：指针的指向和指针指向的值都不可以改 指针访问数组： int arr[10]={1,2,3,4,5,6,7,8,9,10}; int *p=arr;//用指针指向数组的首地址，也就是第一个元素 cout&lt;&lt;*p&lt;&lt;endl;//输出为数组第一个数，也就是1 p++;//让指针向后偏移4个字节 cout&lt;&lt;*p&lt;&lt;endl;//输出数组第二个数，也就是2 利用指针遍历数组： int *p2=arr;//先拿到数组的首地址 for(int i=0;i&lt;10;i++) { cout&lt;&lt;*p2&lt;&lt;endl;//输出完后 p2++;//指针向后偏移一位 } 利用指针实现函数的值的交换 int a=10; int b=20; swap01(&amp;a,&amp;b);//地址传递 void swap01(int *p1,int *p2)//利用指针实现值的改变 { int temp=*p1; *p1=*p2; *p2=temp; } cout&lt;&lt;a&lt;&lt;b&lt;&lt;endl;//这时a=20,b=10 指针复习强化: //指针复习强化 #include &lt;iostream&gt; using namespace std; void test01(); void test02(); int main() { //指针 = &amp;变量 //*指针 = 指针指定的变量的值 int *p; int a = 5; // p指针指向a变量的地址 p = &amp;a; int *q; int b = 10; // q指针指向b变量的地址 q = &amp;b; int *r; //通过第三个指针将p和q指针指向的变量交换 //让p指向b变量,q指向a变量 // r=p 也就是让p指针指向的a变量的地址赋值给r指针 r = p; // p=q 也就是让q指针指向的b变量的地址赋值给p指针 p = q; // q=r 也就是让r指针指向的a变量的地址赋值给q指针 q = r; //这时通过*p修改的变量不是a变量而是b变量 //通过*q修改的不是b变量而是a变量 *p = 99; *q = 100; cout &lt;&lt; \"*p = \" &lt;&lt; *p &lt;&lt; \" a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"*q = \" &lt;&lt; *q &lt;&lt; \" b = \" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"*r = \" &lt;&lt; *r &lt;&lt; endl; test01(); test02(); return 0; } void test01() { //通过指针按先大后小的顺序输出两个整数 int a, b, *p, *q, *r; printf(\"请输入两个整数:\\n\"); scanf(\"%d %d\", &amp;a, &amp;b); p = &amp;a; q = &amp;b; if (a &lt; b) { r = p; p = q; q = r; } printf(\"较大的数为%d 较小的数为%d\\n\", *p, *q); } void test02() { //指针变量与一维数组 int *p, *q, a[3] = {5, 10, 15}; //指针p指向数组a中的第一个元素a[0],a[0]里面存放的值为5 p = &amp;a[0]; //指针q指向数组a中的第二个元素a[1],a[1]里面存放的值为10 q = &amp;a[1]; //通过指针p修改数组a[0]的值,a[0]原本的值是5,*2之后变成10 *p = *p * 2; //通过指针q修改数组a[2]的值,指针q原本指向的是a[1],但是当q+1之后指针往前移动一位,指针q的指向 //就变成了a[2],而a[2]里面存放的值是15,当*p拿到a[0]的值10之后再*2得到20并赋值给*q指向的a[2]的值 *(q + 1) = *p * 2; printf(\"通过指针修改后数组的值为: \\n\"); for (int i = 0; i &lt; 3; i++) { cout &lt;&lt; a[i] &lt;&lt; \" \"; } } 封装一个函数对数组进行冒泡排序： int arr[10]={4,3,6,7,9,2,10,5,100,88}; int len=sizeof(arr)/sizeof(arr[0]); bubbleSort(arr,len); void bubbleSort(int *arr,int len) { for(int i=0;i&lt;len-1;i++)//冒泡排序 { for(int j=0;j&lt;len-i-1;j++) { if(arr[j]&gt;arr[j+1]) { int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } } 这时数组就已经排好序了,只要输出就好 结构体： 结构体属于用户自定义的数据类型，允许用户存储不同的数据类型 创建学生数据类型： struct Student { string name//姓名 int age;//年龄 int score;//分数 }s3; 通过学生类型创建具体学生： struct Student s1;//创建 s1.name=\"张三\";//赋值 s1.age=18;//赋值 s1.score=100;//赋值 struct Student s2={\"李四\",19,90};//在创建的时候就赋值 s3.name=\"王五\";//在定义时就已经创建了s3变量 s3.age=20;//在定义时就已经创建了s3变量 s3.score=60;//在定义时就已经创建了s3变量 结构体数组： struct Student//定义一个结构体 { string name; int age; int score; }; Student stuArray[3]=//创建结构体数组 { {\"张三\",18,100}, {\"李四\",28,99}, {\"王五\",38,66} }; stuArray[2].name=\"赵六\";//重新修改结构体数组的值 stuArray[2].age=80; stuArray[2].score=60; for(int i=0;i&lt;3;i++) { cout&lt;&lt;stuArray[i].name&lt;&lt;stuArray[i].age&lt;&lt;stuArray[i].score&lt;&lt;endl; } 结构体指针： 利用结构体指针来操作结构体成员变量 struct Student { string name; int age; int score; }; Student s={\"张三\",18,100};//创建结构体变量并赋值 Student *p=&amp;s;//创建一个结构体指针指向结构体变量 cout&lt;&lt;p-&gt;name&lt;&lt;p-&gt;age&lt;&lt;p-&gt;score&lt;&lt;endl;//通过指针访问结构体里的变量并输出,访问需要用“-&gt;”号 结构体嵌套结构体： struct Student { string name; int age; int score; }; struct teacher { int id; string name; int age; int score; struct Student stu;//在结构体内部引用另一个结构体创建另一个结构体变量 }; teacher t;//创建老师结构体 t.id=1000; t.name=\"老王\"; t.age=50; t.stu.name=\"小王\"//表示调用了老师结构体当中的学生结构体 t.stu.age=18; t.stu.score=70; cout&lt;&lt;t.name&lt;&lt;\" \"&lt;&lt;t.stu.name&lt;&lt;endl; 将结构体做函数参数： struct Student { string name; int age; int score; }; Student s={\"张三\",20,85}; printStudent1(s); printStudent2(&amp;s); void printStudent1(struct Student s)//值传递 { s.age=200;//这里的修改只在函数内生效 cout&lt;&lt;s.name&lt;&lt;s.age&lt;&lt;s.score&lt;&lt;endl; } void printStudent2(struct student *p)//地址传递 { p-&gt;age=100;//通过地址传递直接修改了值 cout&lt;&lt;p-&gt;name&lt;&lt;p-&gt;age&lt;&lt;p-&gt;score&lt;&lt;endl; } 结构体中const使用场景： void printfStudent(const Student *s) { s-&gt;age=150;//这条会报错，因为const不能修改 cout&lt;&lt;s-&gt;name&lt;&lt;s-&gt;age&lt;&lt;endl; } 结构体案例1： 创建三个老师结构体，每个老师下面有五个学生结构体，每个学生的分数是不同的。 #include &lt;iostream&gt; using namespace std; #include &lt;ctime&gt; //用来创建随机数 struct Student { string sName; int score; }; struct Teacher { string tName; struct Student sArray[5]; }; void allocateSpace(Teacher tArray[], int len) //给老师和学生赋值 { string nameSeed = \"ABCDE\"; for (int i = 0; i &lt; len; i++) { tArray[i].tName = \"Teacher_\"; //给老师赋值 tArray[i].tName += nameSeed[i]; //区别不同的老师 for (int j = 0; j &lt; 5; j++) { tArray[i].sArray[j].sName = \"Student_\"; //给学生赋值 tArray[i].sArray[j].sName += nameSeed[j]; //区别不同的学生 int random = rand() % 61 + 40; //随机数40~100 tArray[i].sArray[j].score = random; } } } void printInfo(Teacher tArray[], int len) { for (int i = 0; i &lt; len; i++) { cout &lt;&lt; tArray[i].tName &lt;&lt; endl; for (int j = 0; j &lt; 5; j++) { cout &lt;&lt; tArray[i].sArray[j].sName &lt;&lt; \" \" &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl; } } } int main() { srand((unsigned int)time(NULL));//创建随机数种子,以当前时间来创建随机数 Teacher tArray[3]; //创建三个老师 int len = sizeof(tArray) / sizeof(tArray[0]); allocateSpace(tArray, len); //在里面创建五个学生并赋值 printInfo(tArray, len); return 0; } 结构体案例2： 设计一个英雄结构体，包括姓名，年龄，性别，创建结构体数组，结构体存放5名英雄，通过冒泡排序的算法将数组中的英雄按照年龄进行升序排序。 #include &lt;iostream&gt; using namespace std; struct Hero //定义英雄的结构体 { string name; //姓名 int age; //年龄 string sex; //性别 }; void bubbleSort(Hero *p, int len) //利用冒泡交换结构体 { for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - i - 1; j++) { if (p[j].age &gt; p[j + 1].age) //比较年龄 { struct Hero temp = p[j]; //实现结构体交换 p[j] = p[j + 1]; p[j + 1] = temp; } } } } void printArray(Hero heroArray[], int len) { for (int i = 0; i &lt; len; i++) { cout &lt;&lt; heroArray[i].name &lt;&lt; \" \" &lt;&lt; heroArray[i].age &lt;&lt; \" \" &lt;&lt; heroArray[i].sex &lt;&lt; endl; } } int main() { struct Hero heroArray[5] = { {\"liubei\", 23, \"man\"}, {\"guangyu\", 22, \"man\"}, {\"zhangfei\", 20, \"man\"}, {\"zhaoyue\", 21, \"man\"}, {\"diaocan\", 19, \"woman\"} }; int len = sizeof(heroArray) / sizeof(heroArray[0]); //排序前: printArray(heroArray, len); bubbleSort(heroArray, len); //排序后： printArray(heroArray, len); return 0; } 通讯录管理系统： 代码: #include &lt;iostream&gt; using namespace std; #define MAX 1000 struct Person //设计联系人结构体 { string m_Name; //姓名 int m_Sex; //性别 int m_Age; //年龄 string m_Phone; //电话 string m_Addr; //住址 }; struct Addressbooks //设计通讯录结构体 { struct Person personArray[MAX]; //通讯录保存的联系人数组 int m_Size; //通讯录当前记录联系人个数 }; void addPerson(Addressbooks *abs) //添加联系人 { if (abs-&gt;m_Size == MAX) { cout &lt;&lt; \"Address book full\" &lt;&lt; endl; //已满 return; } else //如果没满才添加 { string name; cout &lt;&lt; \"name:\" &lt;&lt; endl; cin &gt;&gt; name; abs-&gt;personArray[abs-&gt;m_Size].m_Name = name; //将输入的名字存入数组 cout &lt;&lt; \"sex:\" &lt;&lt; endl; cout &lt;&lt; \"1 --- man\" &lt;&lt; endl; cout &lt;&lt; \"2 --- woman\" &lt;&lt; endl; int sex = 0; while (true) { cin &gt;&gt; sex; if (sex == 1 || sex == 2) { abs-&gt;personArray[abs-&gt;m_Size].m_Sex = sex; //将输入的名字存入数组 break; } cout &lt;&lt; \"error\" &lt;&lt; endl; } cout &lt;&lt; \"age:\" &lt;&lt; endl; int age = 0; while (true) { cin &gt;&gt; age; if (age &gt; 0 &amp;&amp; age &lt;= 150) { abs-&gt;personArray[abs-&gt;m_Size].m_Age = age; //将输入的年龄存入数组 break; } cout &lt;&lt; \"error\" &lt;&lt; endl; } cout &lt;&lt; \"phone:\" &lt;&lt; endl; string phone; cin &gt;&gt; phone; abs-&gt;personArray[abs-&gt;m_Size].m_Phone = phone; //将输入的电话号码存入数组 cout &lt;&lt; \"Addr:\" &lt;&lt; endl; string address; cin &gt;&gt; address; abs-&gt;personArray[abs-&gt;m_Size].m_Addr = address; //将输入的住址存入数组 abs-&gt;m_Size++; //更新通讯录人数 cout &lt;&lt; \"successfully add !\" &lt;&lt; endl; //添加成功 system(\"pause\"); //按任意键继续 system(\"cls\"); //清屏 } } void showPerson(Addressbooks *abs) //显示所有联系人 { if (abs-&gt;m_Size == 0) { cout &lt;&lt; \"Address book NULL\" &lt;&lt; endl; //为空 system(\"pause\"); //按任意键继续 system(\"cls\"); //清屏 return; //退出 } else { for (int i = 0; i &lt; abs-&gt;m_Size; i++) //遍历通讯录 { cout &lt;&lt; \"name: \" &lt;&lt; abs-&gt;personArray[i].m_Name &lt;&lt; '\\t'; cout &lt;&lt; \"sex: \" &lt;&lt; (abs-&gt;personArray[i].m_Sex == 1 ? \"man\" : \"woman\") &lt;&lt; '\\t'; cout &lt;&lt; \"age: \" &lt;&lt; abs-&gt;personArray[i].m_Age &lt;&lt; '\\t'; cout &lt;&lt; \"phone: \" &lt;&lt; abs-&gt;personArray[i].m_Phone &lt;&lt; '\\t'; cout &lt;&lt; \"Addr: \" &lt;&lt; abs-&gt;personArray[i].m_Addr &lt;&lt; endl; } } system(\"pause\"); //按任意键继续 system(\"cls\"); //清屏 } int isExist(Addressbooks *abs, string name) //检查联系人是否存在,返回联系人的具体数组位置 { for (int i = 0; i &lt; abs-&gt;m_Size; i++) { if (abs-&gt;personArray[i].m_Name == name) //找到用户输入的用户名了 { return i; //返回这个人的位置也就是数组下标 } } return -1; //没有找到则返回-1 } void deletePerson(Addressbooks *abs) //删除指定的联系人 { cout &lt;&lt; \"delete name:\" &lt;&lt; endl; //请输入要删除联系人的名字 string name; cin &gt;&gt; name; /*之前前面加 &amp;是要改变通讯录里面的信息， 而这个函数只需要得到返回值，不需要对具体通讯录的东西进行修改*/ int ret = isExist(abs, name); //检查联系人是否存在 if (ret != -1) //存在的话ret就是这个人的下标 { /// cout &lt;&lt; \"found it!\" &lt;&lt; endl; //找到了 for (int i = ret; i &lt; abs-&gt;m_Size; i++) { //所谓删除其实是后面的数据把前面的数据覆盖掉 abs-&gt;personArray[i] = abs-&gt;personArray[i + 1]; //将数据前移 } abs-&gt;m_Size--; cout &lt;&lt; \"delete success!\" &lt;&lt; endl; } else { cout &lt;&lt; \"There is no such person!\" &lt;&lt; endl; //没有这个人 } system(\"pause\"); //按任意键继续 system(\"cls\"); //清屏 } void findPerson(Addressbooks *abs) //查找联系人 { cout &lt;&lt; \"find name:\" &lt;&lt; endl; //请输入要查找的联系人的名字 string name; cin &gt;&gt; name; int ret = isExist(abs, name); //检查联系人是否存在 if (ret != -1) //找到了 { cout &lt;&lt; \"name: \" &lt;&lt; abs-&gt;personArray[ret].m_Name &lt;&lt; \"\\t\"; //姓名 cout &lt;&lt; \"sex: \" &lt;&lt; (abs-&gt;personArray[ret].m_Sex == 1 ? \"man\" : \"woman\") &lt;&lt; \"\\t\"; //性别 cout &lt;&lt; \"age: \" &lt;&lt; abs-&gt;personArray[ret].m_Age &lt;&lt; \"\\t\"; //年龄 cout &lt;&lt; \"phone: \" &lt;&lt; abs-&gt;personArray[ret].m_Phone &lt;&lt; \"\\t\"; //电话 cout &lt;&lt; \"Addr: \" &lt;&lt; abs-&gt;personArray[ret].m_Addr &lt;&lt; endl; //地址 } else //没找到 { cout &lt;&lt; \"There is no such person!\" &lt;&lt; endl; //没有这个人 } system(\"pause\"); //按任意键继续 system(\"cls\"); //清屏 } void modifyPerson(Addressbooks *abs) //修改指定联系人信息 { cout &lt;&lt; \"modify name:\" &lt;&lt; endl; string name; cin &gt;&gt; name; int ret = isExist(abs, name); if (ret != -1) { string name; cout &lt;&lt; \"alert name:\" &lt;&lt; endl; //请输入要修改的姓名 cin &gt;&gt; name; abs-&gt;personArray[ret].m_Name = name; //重新赋值 cout &lt;&lt; \"alert sex:\" &lt;&lt; endl; //请输入要修改的性别 cout &lt;&lt; \"1 --- man\" &lt;&lt; endl; cout &lt;&lt; \"2 --- woman\" &lt;&lt; endl; int sex = 0; while (true) //输入对了就退出，错了就循环重新输入 { cin &gt;&gt; sex; if (sex == 1 || sex == 2) { abs-&gt;personArray[ret].m_Sex = sex; break; } cout &lt;&lt; \"alert error\" &lt;&lt; endl; } cout &lt;&lt; \"alert age:\" &lt;&lt; endl; //请输入要修改的年龄 int age = 0; while (true) { cin &gt;&gt; age; if (age &gt; 0 &amp;&amp; age &lt;= 150) { abs-&gt;personArray[ret].m_Age = age; break; } cout &lt;&lt; \"alert error\" &lt;&lt; endl; } cout &lt;&lt; \"alert phone\" &lt;&lt; endl; //请输入要修改的电话 string phone; cin &gt;&gt; phone; abs-&gt;personArray[ret].m_Phone = phone; cout &lt;&lt; \"alert Addr\" &lt;&lt; endl; //请输入要修改的住址 string address; cin &gt;&gt; address; abs-&gt;personArray[ret].m_Addr = address; cout &lt;&lt; \"alert success!\" &lt;&lt; endl; } else { cout &lt;&lt; \"There is no such person!\" &lt;&lt; endl; //没有这个人 } system(\"pause\"); //按任意键继续 system(\"cls\"); //清屏 } void cleanPerson(Addressbooks *abs) { cout &lt;&lt; \"Really want to empty?\" &lt;&lt; endl; cout &lt;&lt; \"1 --- yes\" &lt;&lt; endl; cout &lt;&lt; \"2 --- no\" &lt;&lt; endl; int ret = 0; cin &gt;&gt; ret; if (ret == 1) { abs-&gt;m_Size = 0; //将当前记录联系人数量置为0，做逻辑上的清空 cout &lt;&lt; \"Address book cleared NULL!\" &lt;&lt; endl; } system(\"pause\"); //按任意键继续 system(\"cls\"); //清屏 } void showMenu() //初始界面 { cout &lt;&lt; \"**********************\" &lt;&lt; endl; cout &lt;&lt; \"***** 1.add *****\" &lt;&lt; endl; //添加 cout &lt;&lt; \"***** 2.show *****\" &lt;&lt; endl; //显示 cout &lt;&lt; \"***** 3.delete *****\" &lt;&lt; endl; //删除 cout &lt;&lt; \"***** 4.find *****\" &lt;&lt; endl; //查找 cout &lt;&lt; \"***** 5.alter *****\" &lt;&lt; endl; //修改 cout &lt;&lt; \"***** 6.empty *****\" &lt;&lt; endl; //清空 cout &lt;&lt; \"***** 0.exit *****\" &lt;&lt; endl; //退出 cout &lt;&lt; \"**********************\" &lt;&lt; endl; } int main() { Addressbooks abs; //创建通讯录结构体 abs.m_Size = 0; //一开始通讯录人数为0 int select = 0; while (true) { showMenu(); cin &gt;&gt; select; switch (select) { case 1: //添加 addPerson(&amp;abs); //利用地址传递修饰实参 break; case 2: //显示 showPerson(&amp;abs); break; case 3: //删除 // {//如果要在switch输入多行需要括号 // cout &lt;&lt; \"delete name:\" &lt;&lt; endl; //请输入要删除联系人的名字 // string name; // cin &gt;&gt; name; // if (isExist(&amp;abs, name) == -1) // { // cout &lt;&lt; \"There is no such person!\" &lt;&lt; endl; //没有这个人 // } // else // { // cout &lt;&lt; \"found it!\" &lt;&lt; endl; //找到了 // } // } deletePerson(&amp;abs); break; case 4: //查找 findPerson(&amp;abs); break; case 5: //修改 modifyPerson(&amp;abs); break; case 6: //清空 cleanPerson(&amp;abs); break; case 0: //退出 cout &lt;&lt; \"Welcome to use next time\" &lt;&lt; endl; system(\"pause\"); return 0; break; default: break; } } return 0; } 内存四区： 代码区：在程序运行前执行的区 存放cpu执行的机器指令，其实就是你写的代码存放的exe文件，代码区是共享的，只读的，不可修改的 全局区：在程序运行前执行的区 存放全局变量和静态变量,字符串,常量，该区域的数据在程序结束后由操作系统释放，注意局部的变量不存在全局区中,main()里面的也是局部变量。 静态变量是 static int s=10;在变量前面加static就是静态变量。 cout&lt;&lt;(int)&amp;s;//查看地址,\"hello,world\",此字符串存在全局区中，const修饰的常量才在全局区，const修饰的变量不在全局区。 栈区： 存放函数的参数和局部变量，如： void fun(int b)//这个b是形参也是放在栈上 { int a=10;//这个就是存放在栈区的局部变量 return &amp;a;//这条是错误的,函数在执行完后会自动释放，地址不会存在，无法返回地址 } 堆区：由程序员分配释放，主要利用new在堆区开辟内存，程序结束时由操作系统回收，如： int *fun() { int *p=new int(10);//这就是用new开辟了一块int类型大小为10的空间，用指针接收这块内存的地址 return p;//这条是正确的，堆区的内存不会自动释放,可以返回，指针本质也是局部变量，保存在栈上 } int *test01() { int *arr=new int[10];//利用new关键字在堆区创建数组，返回的是数组的首地址，可以用指针接收 for(int i=0;i&lt;10;i++) { arr[i]=i+100;//给10个元素赋值 } return arr;//返回数组的首地址 delete[ ] arr;//释放数组 } int *p=fun();//用指针接收返回回来的堆区内存 如果要释放就利用delete操作符，如： int *fun() { int *p=new int(10); return p; } void test() { int *p=fun(); cout&lt;&lt;*p&lt;&lt;endl;//10,因为内存大小是10 delete p;//这就是释放堆区的内存 cout&lt;&lt;*p&lt;&lt;endl;//这条会报错，因为内存已经被释放了。 delete[ ] arr;//释放数组 } 总结：程序运行前分为全局区和代码区，程序运行后分为栈区和堆区 完整代码: //程序运行前分为全局区和代码区，程序运行后分为栈区和堆区 #include &lt;iostream&gt; using namespace std; int *fun() { //这就是用new开辟了一块int类型大小为10的空间，用指针接收这块内存的地址 int *p = new int(10); //这条是正确的，堆区的内存不会自动释放,可以返回，指针本质也是局部变量，保存在栈上 return p; } int *test() { //利用new关键字在堆区创建数组，返回的是数组的首地址，可以用指针接收 int *arr = new int[10]; for (int i = 0; i &lt; 10; i++) { //给10个元素赋值 arr[i] = i + 100; } //返回数组的首地址 return arr; } int main() { //用指针接收返回回来的堆区内存 //如果要释放就利用delete操作符 int *p = fun(); // 10,因为内存大小是10 cout &lt;&lt; *p &lt;&lt; endl; int *arr = test(); for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; arr[i] &lt;&lt; endl; } //这就是释放堆区的内存 delete p; //这条会报错，因为内存已经被释放了。 // cout &lt;&lt; *p &lt;&lt; endl; //释放数组 delete[] arr; return 0; } 引用： 给一个变量起别名，如： int a=10; int &amp;b=a;//这就是起别名,将a的内存赋值给b，b就等于a,a也等于b b=20; cout&lt;&lt;a&lt;&lt;endl;//这时a是20,因为b和a操作的是同一块内存,b变了a也跟着变 int &amp;c;//这条是错误的,引用必须初始化,不能光定义 int d=30; &amp;b=d;//这条是错误的,引用一旦初始化后就不能改变了,&amp;b在上面已经指向了a那块内存，不能再重新指向d的内存了。 b=d;//这条是赋值操作,正确的,相当于把b原来那块内存变成c那块内存,那么a,b,c都会变成30 引用做函数参数： 可以用形参修饰实参，弱化指针的用途，如： void mySwap(int &amp;a,int &amp;b)//利用引用改变两个变量的值 { int temp = a; a = b; b = temp; } int a=10,b=20; mySwap(a,b); 引用做函数返回值： int &amp;test01()//创建了一个引用函数 { int a=10; return a; } int &amp;ref=test01();//这条是错误的,引用返回的变量不能用引用接收，因为变量已经释放 int &amp;test2() { static int b=10;//静态变量存放在全局区,不会释放 return b; } int &amp;ref2=test2();//这条是正确的,因为b不会被栈释放 test2()=1000;//这条是正确的,返回的是b的引用,如果函数是左值那么必须返回引用，这时输出ref2的话都是1000。 引用的本质： 其实底层是指针常量，指针常量是指针的指向不可变，指针指向的值可变，如： int &amp;ref=a;//底层是：int *const ref=&amp;a; ref=20;//底层是：*ref=20; 常量引用： int &amp;ref=10;//这条是错误的，10是常量，不可以引用 const int &amp;res=10;//这条是正确的,编译器在底层帮写了：int temp=10;const int &amp;res=temp; res=20;//这条是错误的,加入const之后变为只读,不可修改。 void showValue(const int &amp;a) { a=1000;//这条是错误的,const不可修改 cout&lt;&lt;a&lt;&lt;endl;//100 } int a=100 showValue(a); cout&lt;&lt;a&lt;&lt;endl;//100,因为函数内部没有改变实参 完整代码: #include &lt;iostream&gt; using namespace std; void fun(int &amp;a, int &amp;b) //利用引用改变两个变量的值 { int temp = a; a = b; b = temp; } int &amp;test1() //创建了一个引用函数 { static int aq = 200; //静态变量存放在全局区,不会被栈释放 return aq; } void showValue(const int &amp;a) { // a = 1000; //这条是错误的,const不可修改 cout &lt;&lt; a &lt;&lt; endl; // 100 } int main() { int a = 10; int &amp;b = a; //这就是起别名,将a的内存赋值给b，b就等于a,a也等于b b = 20; cout &lt;&lt; a &lt;&lt; endl; //这时a是20,因为b和a操作的是同一块内存,b变了a也跟着变 // int &amp;c; //这条是错误的,引用必须初始化,不能光定义 int d = 30; //&amp;b = d; 这条是错误的,引用一旦初始化后就不能改变了, // &amp;b在上面已经指向了a那块内存，不能再重新指向d的内存了。 b = d; //这条是赋值操作,正确的, //相当于把b原来那块内存变成c那块内存,那么a,b,c都会变成30 cout &lt;&lt; a &lt;&lt; endl; int a1 = 10, b1 = 20; fun(a1, b1); //利用引用改变两个变量的值 cout &lt;&lt; a1 &lt;&lt; endl; cout &lt;&lt; b1 &lt;&lt; endl; int &amp;res = test1(); //这条是正确的,因为aq不会被栈释放所以可以赋值 cout &lt;&lt; res &lt;&lt; endl; // 200 test1() = 1000; //这条是正确的,返回的是b的引用,如果函数是左值那么必须返回引用 cout &lt;&lt; res &lt;&lt; endl; // 1000 // int &amp;ref = 10; //这条是错误的，10是常量，不可以引用 const int &amp;ress = 10; //这条是正确的,编译器在底层帮写了：int temp=10;const int &amp;res=temp; // ress = 20; //这条是错误的,加入const之后变为只读,不可修改。 return 0; } 函数提高： 函数的形参是可以有默认值的，如： int func(int a, int b = 20, int c = 30) //函数的形参是可以有默认值的 { return a + b + c; } func(10);//因为在函数里定义了参数所以可以少传参数,如果传入了就用传入的数据,如果没有才用默认值。 int func2(int a, int b = 10, int c, int d)//这里是错误的,如果左边已经有默认值了那么右边也必须得有,从左往右 { return a+b+c+d; } 如果函数声明有默认参数,函数实现就不能有默认参数，如： int fun(int a=10,int b=20);//函数声明 int fun(int a=10;int b=20)//此条是错误的,声明和函数定义只能有一个有默认值 { return a+b; } 函数占位参数： void func(int a,int)//正确的,可以只写一个数据类型来占位 { cout&lt;&lt;a&lt;&lt;endl; } func(10,10);//函数调用的时候必须传两个值才行,因为有个数据类型占位了 void func(int a,int = 10)//占位参数也可以有默认值 函数重载： 函数名可以相同,提高复用性,需要满足条件： 同一个作用域下，函数名称相同，函数参数类型不同或者个数不同或者顺序不同 void func() { cout&lt;&lt;\"\"hello,world&lt;&lt;endl; } void func(int a)//正确的,只要参数有改变则可以定义名称一样的函数 { cout&lt;&lt;a&lt;&lt;endl; } void func(double a)//数据类型不一样也可以重复定义 { cout&lt;&lt;a&lt;&lt;endl;//正确的 } void func(double a,int b);//正确的,数量不一样 void func(int a,double b);//正确的,顺序不一样 func();//默认是调第一个 func(10);//有参数则调用第二个整形的 func(3.14);//调用第三个浮点数 这些函数都放在全局作用域内,所以是同一作用域 注意：函数重载不可以有返回值,如： void func(double a,int b); int func(double a,int b);//错误,函数重载返回值必须是void。 引用作为重载的条件： void fun(int &amp;a); void fun(const int &amp;a);//正确的,引用类型不同 //调用: int a=10; fun(a);//默认是传第一个 fun(10);//直接传常量就会走第二个,因为const int &amp;a=10是合法的,而int &amp;a=10;是不合法的 函数重载碰到默认参数： void fun(int a,int b=10); void fun(int a); fun(10);//错误，两个都能调会出现二义性 完整代码： #include &lt;iostream&gt; using namespace std; int func(int a, int b = 20, int c = 30) //函数的形参是可以有默认值的 { return a + b + c; } // int func2(int a, int b = 10, int c, int d)//这里是错误的,如果左边已经有默认值了那么右边也必须得有 // { // return a + b + c + d; // } int fun3(int a = 10, int b = 10); //函数声明 //如果函数声明有默认参数, 函数实现就不能有默认参数,声明和实现只能一个有默认参数 void func3(int a, int = 10) //占位参数也可以传默认值 { cout &lt;&lt; a &lt;&lt; endl; } void fun(int a); //正确的,函数重载只要参数有改变则可以定义名称一样的函数 void fun(double a); //函数重载数据类型不一样也可以重复定义 void fun(int a, double b); //函数重载正确的,数量不一样 void fun(double a, int b); //函数重载正确的,顺序不一样 // int fun(double a, int b); //错误,函数重载返回值必须是void void funw(int &amp;a); void funw(const int &amp;a); //正确的,引用类型不同 void funa(int a, int b = 10); //错误,函数重载尽量不要用默认值 void funa(int a); int main() { cout &lt;&lt; func(10) &lt;&lt; endl; //因为在函数里定义了参数所以可以少传参数 //注意：如果传入了就用传入的数据,如果没有才用默认值 // cout &lt;&lt; func2(10) &lt;&lt; endl; func3(10, 10); //函数调用的时候必须传两个值才行,因为有个数据类型占位了 int a = 10; funw(a); //默认是传第一个 funw(10); //直接传常量就会走第二个,因为const int &amp;a=10是合法的 //而int &amp;a=10;是不合法的 // funa(10); //错误，两个都能调会出现二意性 return 0; } // int fun3(int a = 10, int b = 10) //错误,如果函数声明有默认参数,函数实现就不能有默认参数 // { //声明和实现只能一个有默认参数 // return a + b; // } 类和对象： 面向对象三大特性为：封装、继承、多态 对象拥有属性和行为。 案例1：设计一个圆类，求圆的周长: 公式：2 * PI * 半径 const double PI=3.14; class Circle//class代表一个类,类后面紧跟着类名称 { public: int m_r;//半径,属性 double calculateZC()//求圆的一个行为 { return 2 *PI *m_r; } }; Circle c1;//通过类创建一个对象 c1.m_r = 10;//给圆的对象的属性进行赋值 cout&lt;&lt;c1.calculateZC()&lt;&lt;endl;//求周长 案例2：设计一个学生类,属性有姓名和学号,可以给姓名和学号赋值,可以显示学生的姓名和学号 class Student { public://访问权限 string m_Name;//姓名 int m_Id;//学号 void showStudent() { cout&lt;&lt;m_Name&lt;&lt;\" \"&lt;&lt;m_Id&lt;&lt;endl; } void setName(string name) { m_Name=name; } void setId(int id) { m_Id=id; } }; Student s1; s1.m_Name=\"张三\";//给s1对象属性进行赋值操作 s1.m_Id=1; s1.showStudent();//显示学生信息 Student s2; s2.m_Name=\"李四\"; s2.m_Id=2; s2.showStudent(); 案例3：设计一个通讯录 访问权限： 公告权限：public 成员 类内可以访问 类外可以访问 保护权限：protected 成员 类内可以访问 类外不可以访问 儿子可以访问父亲的保护内容 私有权限：private 成员 类内可以访问 类外不可以访问 儿子不可以访问父亲的私有内容 //访问权限 #include &lt;iostream&gt; using namespace std; class Student //如果class里面什么都不写那么它默认是私有权限 { public: //公共权限,类内类外都可以访问 string m_Name; //姓名 protected: //保护权限,类内可以访问,类外不可以访问 string m_Car; //汽车 private: //私有权限,类内可以访问,类外不可以访问 int m_Password; //密码 // protected与private的区别在于继承方面,儿子可以访问protected不可以访问private public: void func() { m_Name = \"zs\"; m_Car = \"tlj\"; //类内可以访问 m_Password = 123456; //类内可以访问 } }; struct C1 //如果struct里面什么都不写那么它是公共权限 { int m_A; }; // class和struct的区别就是一个权限的私有,一个权限是公共,如果是私有那么需要用public来变成公共 int main() { Student s1; s1.m_Name = 'lisi'; //公共权限类外可以访问 // s1.m_Car=\"bm\";//保护权限在类外是不可以访问的 // s1.m_Password=1267;//私有权限在类外也是不可以访问的 C1 s2; s2.m_A = 100; //在struct默认的权限的公共,所以可以访问 return 0; } 将成员属性设置为私有 //将成员属性设置为私有 #include &lt;iostream&gt; using namespace std; class Person //设计人类 { public: //在外面设置公共可以给私有权限可读可写 void setName(string name) //设置姓名 { m_Name = name; } string getName() //读取姓名 { return m_Name; } int getAge() //获取年龄 { // m_Age = 0; //初始化为0岁 return m_Age; } void setAge(int age) //设置年龄 将年龄变为可读可写 { if (age &lt; 0 || age &gt; 150) //判断年龄范围 { age = 0; return; } m_Age = age; } void setLover(string lover) //设置情人 只写 { m_Lover = lover; } private: //设置私有化 //优点：可以自己控制读写权限 //可以防止超出访问范围 string m_Name; //姓名 可读可写 int m_Age; //年龄 只读 string m_Lover; //情人 只写 }; int main() { Person p1; p1.setName(\"zs\"); //设置姓名 cout &lt;&lt; p1.getName() &lt;&lt; endl; //读取姓名 p1.setAge(18); //设置年龄 cout &lt;&lt; p1.getAge() &lt;&lt; endl; //读取年龄 p1.setLover(\"xh\"); //设置情人 return 0; } 案例：设计立方体 //案例：设计立方体 #include &lt;iostream&gt; using namespace std; class Cube { public: void setL(int l) //设置长 { m_L = l; } int getL() //获取长 { return m_L; } void setW(int w) //设置宽 { m_W = w; } int getW() //获取宽 { return m_W; } void setH(int h) //设置高 { m_H = h; } int getH() //获取高 { return m_H; } int calculateS() //获取立方体面积 { //长乘宽+宽乘高+长乘高 return 2 * m_L * m_W + 2 * m_W * m_H + 2 * m_L * m_H; } int calculateV() //获取立方体体积 { //长乘宽乘高 return m_L * m_W * m_H; } //使用内部类判断两个立方体是否相同 bool isSameByClass(Cube &amp;c) //因为是内部类所以只需要传一份参数 { if (m_L == c.getL() &amp;&amp; m_W == c.getW() &amp;&amp; m_H == c.getH()) { return true; } return false; } private: //属性 int m_L; //长 int m_W; //宽 int m_H; //高 }; //判断两个立方体是否相等 bool isSame(Cube &amp;box1, Cube &amp;box2) //通过引用的方式传递可以防止拷贝数据 { if (box1.getL() == box2.getL() &amp;&amp; box1.getW() == box2.getW() &amp;&amp; box1.getH() == box2.getH()) { return true; } return false; } int main() { Cube box1; box1.setL(10); //设置长 box1.setW(10); //设置宽 box1.setH(10); //设置高 cout &lt;&lt; box1.calculateS() &lt;&lt; endl; //输出面积 cout &lt;&lt; box1.calculateV() &lt;&lt; endl; //输出体积 Cube box2; box2.setL(10); box2.setW(10); box2.setH(11); bool ret = isSame(box1, box2); if (ret) //判断是否相等 { cout &lt;&lt; \"Yes\" &lt;&lt; endl; } else cout &lt;&lt; \"No\" &lt;&lt; endl; ret = box1.isSameByClass(box2); // box1调用box2与它对比 if (ret) //利用成员函数判断是否相等 { cout &lt;&lt; \"Yes\" &lt;&lt; endl; } else cout &lt;&lt; \"No\" &lt;&lt; endl; return 0; } 案例：点和圆的关系(分文件编写): 主文件圆类圆类具体实现点类点类具体实现主.cpp文件: //案例：点和圆的关系 #include &lt;iostream&gt; using namespace std; #include \"day21_point.cpp\" //把点类和圆类都放到另一个文件中再引用 #include \"day21_circle.cpp\" // class Point //点类 // { // public: // void setX(int x) //设置X // { // m_X = x; // } // int getX() //获取X // { // return m_X; // } // void setY(int y) //设置y // { // m_Y = y; // } // int getY() //获取y // { // return m_Y; // } // private: //点的属性 // int m_X; // int m_Y; // }; // class Circle //圆类 // { // public: // void setR(int r) //设置半径 // { // m_R = r; // } // int getR() //获取半径 // { // return m_R; // } // void setCenter(Point center) //设置圆心 // { // m_Center = center; // } // Point getCenter() //获取圆心 // { // return m_Center; // } // private: //圆的属性 // int m_R; //半径 // //在一个类中可以让另一个类作为本类的核心成员 // Point m_Center; //圆心 // }; //判断点和圆的关系 void isInCircle(Circle &amp;c, Point &amp;p) { //计算两点之间的平方 int distance = //公式:(x1-x2)^2+(y1-y2)^2 (c.getCenter().getX() - p.getX()) * (c.getCenter().getX() - p.getX()) + (c.getCenter().getY() - p.getY()) * (c.getCenter().getY() - p.getY()); //计算半径的平方 int rDistance = c.getR() * c.getR(); //半径乘半径 公式:m_R^2 //判断关系 if (distance == rDistance) { cout &lt;&lt; \"Point == Circle\" &lt;&lt; endl; //点在圆上 } else if (distance &gt; rDistance) { cout &lt;&lt; \"Point &gt; Circle\" &lt;&lt; endl; //点在圆外 } else cout &lt;&lt; \"Point &lt; Circle\" &lt;&lt; endl; //点在圆内 } int main() { Circle c; //创建圆 c.setR(10); Point center; //创建圆内的点 center.setX(10); center.setY(0); c.setCenter(center); Point p; //创建点 p.setX(10); p.setY(10); //判断关系 isInCircle(c, p); return 0; }分circle.h文件: #pragma once //防止头文件重复包含 #include &lt;iostream&gt; using namespace std; #include \"day21_point.h\" //因为引用了point类所以要包含 class Circle //圆类 { public: void setR(int r); //设置半径 int getR(); //获取半径 void setCenter(Point center); //设置圆心 Point getCenter(); //获取圆心 private: //圆的属性 int m_R; //半径 //在一个类中可以让另一个类作为本类的核心成员 Point m_Center; //圆心 };分circle.cpp文件: #include \"day21_circle.h\" void Circle::setR(int r) //设置半径 { m_R = r; } int Circle::getR() //获取半径 { return m_R; } void Circle::setCenter(Point center) //设置圆心 { m_Center = center; } Point Circle::getCenter() //获取圆心 { return m_Center; }分point.h文件: #pragma once //防止头文件重复包含 #include &lt;iostream&gt; using namespace std; class Point //点类 { public: //只需要加声明,不需要写具体实现 void setX(int x); //设置X int getX(); //获取X void setY(int y); //设置y int getY(); //获取y private: //点的属性 int m_X; int m_Y; };分point.cpp文件: #include \"day21_point.h\" //需要告诉它是Point作用域下的函数 void Point::setX(int x) //设置X { m_X = x; } int Point::getX() //获取X { return m_X; } void Point::setY(int y) //设置y { m_Y = y; } int Point::getY() //获取y { return m_Y; } 构造函数 初始化和清理分类和调用调用时机调用规则深拷贝与浅拷贝初始化列表对象的初始化和清理 //对象的初始化和清理 #include &lt;iostream&gt; using namespace std; class Person { public: //构造函数： Person() //这就是构造函数,构造函数可以有参数也可以发生重载,但是不能有返回值也没有返回类型 { //创建对象的时候构造函数会被编译器自动调用一次不过里面语句为空 cout &lt;&lt; \"Hello,Person\" &lt;&lt; endl; } //析构函数,用来进行清理操作 ~Person() //这就是析构函数,函数名和类型名相同,在名称前面加~号 { //析构函数不可以有参数,不可以发生重载,在对象销毁前会自动调用一次析构函数 cout &lt;&lt; \"end ~Person\" &lt;&lt; endl; } }; void test01() { Person p; //这里是自动调用了构造函数,明明只是创建了一个对象而已却执行了输出语句 //因为p是在栈上的对象,函数调用完就自动释放了,所以会执行析构函数 } int main() { test01(); Person p; //因为有断点所以析构不会执行析构函数,断点执行完了后才会执行 return 0; }构造函数的分类和调用 //构造函数的分类和调用 #include &lt;iostream&gt; using namespace std; class Person { public: Person() //无参构造,默认构造 { cout &lt;&lt; \"Hello,Person\" &lt;&lt; endl; } Person(int a) //有参构造 { //这里的age不是没有数据类型，而是在第33行已经定义好了, //后定义age变量实际类内执行起来是先执行构造函数外的，所以写下面实际也是先定义。 age = a; cout &lt;&lt; \"Hello,Person:\" &lt;&lt; a &lt;&lt; endl; if (typeid(age) == typeid(int)) { cout &lt;&lt; \"age is int\" &lt;&lt; endl; } else { cout &lt;&lt; \"age is not type\" &lt;&lt; endl; } } //拷贝构造函数 Person(const Person &amp;p) //将参数拷贝到构造函数里,也就是将右边的属性传给左边 { //将传入的人身上所有的属性拷贝到 Person上 age = p.age; cout &lt;&lt; age &lt;&lt; endl; } int age; ~Person() //析构函数 { cout &lt;&lt; \"end ~Person\" &lt;&lt; endl; } }; void test01() { // 1.括号法: Person p1; //默认构造函数的调用,没有参数,不用加括号 Person p2(10); //有参构造函数的调用 Person p3(p2); //拷贝函数的调用 //注意：Person p1();//如果无参构造加了括号编译器会认为是一个函数声明 // 2.显示法： Person p4; Person p5 = Person(10); //有参构造 Person p6 = Person(p5); //拷贝构造 // Person(10) //匿名对象,当前行执行结束就会销毁 // Person (p3);//不要利用拷贝构造函数 初始化匿名对象 编译器会认为 Person(p3)===Person p3; //而p3在上面就已经被定义了，所以会重名 // 3.隐式转换法: Person p7 = 10; //等价于 Person p7=Person(10)有参构造 Person p8 = p7; //拷贝构造 //注意：Person (p8);//不能用拷贝构造函数初始化匿名对象,编译器会认为是对象声明，和51行同理 } int main() { test01(); return 0; }构造函数的调用时机 //构造函数的调用时机 #include &lt;iostream&gt; using namespace std; // 1、使用一个已经创建完毕的对象来初始化一个新对象 // 2、值传递的方式给函数参数传值 // 3、值方式返回局部对象 class Person { public: Person() //无参构造 { cout &lt;&lt; \"Hello,Person\" &lt;&lt; endl; } Person(int age) //有参构造 { m_Age = age; cout &lt;&lt; \"Hello \" &lt;&lt; age &lt;&lt; endl; } Person(const Person &amp;p) //拷贝构造 { m_Age = p.m_Age; cout &lt;&lt; m_Age &lt;&lt; endl; } int m_Age; ~Person() //析构 { cout &lt;&lt; \"end ~Person\" &lt;&lt; endl; } }; // 2.值传递的方式给函数参数传值 void doWork(Person p) { } void test02() { Person p; doWork(p); //当作为值传递给另一个函数的时候其实也执行了一次拷贝 } // 3.值方式返回局部对象 Person doWork2() { Person p1; //这里拷贝出来的地址和返回给调用函数的地址是不一样的 cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl; return p1; } void test03() { Person p = doWork2(); //函数执行完就释放掉了,而拷贝的值会返回回来,但是地址不一样 cout &lt;&lt; (int *)&amp;p &lt;&lt; endl; } void test01() { // 1.将一个已经创建的对象属性拷贝到另一个对象 Person p1(20); Person p2(p1); cout &lt;&lt; \"P2 age:\" &lt;&lt; p2.m_Age &lt;&lt; endl; } int main() { // test01(); // test02(); test03(); return 0; }构造函数的调用规则 //构造函数的调用规则 //默认情况下如果创建一个类那么C++就会至少给一个类添加三个函数 // 1、默认构造函数(无参,函数体为空) // 2、默认析构函数(无参,函数体为空) // 3、默认拷贝构造函数,(对属性进行值拷贝) #include &lt;iostream&gt; using namespace std; //如果用户定义有参构造函数,那么C++就不再提供默认无参构造,但是会提供默认拷贝构造 //如果用户定义拷贝构造函数,那么C++就不再提供其他构造函数 class Person { public: //自己写的高级构造函数会屏蔽编译器提供的低级构造函数 //如果这里注释掉了而下面定义了有参构造函数那么C++就不再提供默认构造函数,那么创建对象时就会报错 // Person() // Person的默认构造函数调用 // { // cout &lt;&lt; \"Person moren\" &lt;&lt; endl; // } //有参构造函数 //当用户定义了一个拷贝构造函数,那么C++就不会再提供其他构造函数 // Person(int age) // { // cout &lt;&lt; \"Person+age\" &lt;&lt; endl; // m_Age = age; // } //就算把拷贝构造函数注释掉,C++也会默认提供一个拷贝构造函数 Person(const Person &amp;p) { // Person的拷贝构造函数调用 cout &lt;&lt; \"Person+copy\" &lt;&lt; endl; m_Age = p.m_Age; } ~Person() // Person的析构函数调用 { cout &lt;&lt; \"end ~Person\" &lt;&lt; endl; } int m_Age; }; // void test01() // { // //一开始的时候Person p 会执行一次默认构造函数,然后在Person p2(p)的时候会执行一次拷贝构造函数 // //然后输出p2的年龄,然后默认会先销毁Person p,然后再销毁Person p2,所以会执行两次析构函数的调用 // Person p; // p.m_Age = 18; // Person p2(p); // //因为C++提供了默认拷贝函数,所以这里p2的值也是18,不会是乱码 // cout &lt;&lt; \"p2.age:\" &lt;&lt; p2.m_Age &lt;&lt; endl; // } void test02() { //这里会报错,因为如果用户定义了有参构造函数那么C++就不再提供默认构造函数了,而创建一个对象必须 //要调用默认构造函数 // Person p; // Person p(28); //虽然C++不再提供默认构造函数,但是会提供拷贝构造函数,所以拷贝依旧是生效的 // Person p2(p); // cout &lt;&lt; \"p2.age:\" &lt;&lt; p2.m_Age &lt;&lt; endl; //当用户定义了一个拷贝构造函数,那么C++就不会再提供其他构造函数 //所以这时再调用默认构造函数或者有参构造函数都会报错 // Person p; } int main() { // test01(); test02(); return 0; }深拷贝与浅拷贝 //深拷贝与浅拷贝 //浅拷贝：简单的赋值拷贝操作 //深拷贝：在堆区重新申请空间，进行拷贝操作 #include &lt;iostream&gt; using namespace std; class Person { public: Person() //默认构造函数 { cout &lt;&lt; \"Person moren\" &lt;&lt; endl; } //有参构造函数 Person(int age, int height) { //这是浅拷贝,只是接收赋值操作 m_Age = age; // new一个int,把身高创建在堆区,用一个指针去接收返回回来的数据 //这就是深拷贝需要在函数执行完,在对象销毁前提前在析构函数里释放,避免造成内存泄漏 m_Height = new int(height); cout &lt;&lt; \"Person youcan\" &lt;&lt; endl; } ~Person() { //当有参构造函数里使用深拷贝new了一个参数的时候可以在析构函数里释放掉 //判断是否为空是因为,如果new成功了那么指针的指向就不为空 if (m_Height != NULL) { //利用delete释放堆区的内存 delete m_Height; //将指针置为空以避免野指针的出现 m_Height = NULL; } cout &lt;&lt; \"end ~Person\" &lt;&lt; endl; //注意:如果只是像上面这样写会出现异常,因为构造和拷贝构造会分别执行一次,也就是执行两次 //那么就会调用两次析构函数,那么就会重复释放两次内存,所以会出现异常 //当第一次释放的时候释放的是p2的内存,所以p1释放的时候依旧会判断不为空,而p1和p2的指针是指向的 //同一块内存,所以同一块内存会经过两次释放,所以会出现异常 } //解决方法:自己实现拷贝构造函数,解决浅拷贝带来的问题 Person(const Person &amp;p) { cout &lt;&lt; \"Person copy\" &lt;&lt; endl; m_Age = p.m_Age; //编译器默认实现就是这行代码,这是浅拷贝的代码 // m_Height = p.m_Height; //我们要解决浅拷贝带来的问题,那么就要用深拷贝在重新在堆区开辟一块内存 //这样的话p2和p1指向的就不是同一块内存了,各自释放自己的就不会出现异常 m_Height = new int(*p.m_Height); } //年龄 int m_Age; //指针指向的是身高 int *m_Height; }; void test01() { //调用有参构造函数,输出p1的年龄,当函数执行完时会释放p1,也就会执行析构函数 Person p1(18, 160); cout &lt;&lt; \"p1 age:\" &lt;&lt; p1.m_Age &lt;&lt; \" ,p1 height:\" &lt;&lt; *p1.m_Height &lt;&lt; endl; //调用默认拷贝构造函数,就算没写拷贝构造函数,编译器也会提供默认的拷贝构造函数 Person p2(p1); cout &lt;&lt; \"p2 age:\" &lt;&lt; p2.m_Age &lt;&lt; \" ,p2 height:\" &lt;&lt; *p2.m_Height &lt;&lt; endl; } int main() { test01(); return 0; }初始化列表 //初始化列表 #include &lt;iostream&gt; using namespace std; class Person { public: //传统的初始化操作 // Person(int a, int b, int c) // { // //在有参构造时就把所有的属性赋初值了 // m_A = a; // m_B = b; // m_C = c; // } //用列表初始化属性,在构造函数创建时就自动赋值 Person(int a, int b, int c) : m_A(a), m_B(b), m_C(c) { } //这样写也可以,即使没有参数也能赋初值 // Person() : m_A(10), m_B(20), m_C(30) // { // } int m_A; int m_B; int m_C; }; void test01() { // Person p(10, 20, 30); Person p(30, 20, 10); // Person p; cout &lt;&lt; \"m_A=\" &lt;&lt; p.m_A &lt;&lt; \"\\n\" &lt;&lt; \"m_B=\" &lt;&lt; p.m_B &lt;&lt; \"\\n\" &lt;&lt; \"m_C=\" &lt;&lt; p.m_C &lt;&lt; endl; } int main() { test01(); return 0; } 成员变量 类成员静态成员变量静态成员函数分开存储类对象作为类成员 //类对象作为类成员 //其实也就是一个对象里面嵌套另一个对象 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //手机类 class Phone { public: Phone(string pName) { cout &lt;&lt; \"Phone\" &lt;&lt; endl; m_PName = pName; } ~Phone() { cout &lt;&lt; \"end ~Phone\" &lt;&lt; endl; } string m_PName; }; //人的类 class Person { public: //这里的赋值操作可以理解为：Phone m_Phone = pName 相当于隐式转换法 Person(string name, string pName) : m_Name(name), m_Phone(pName) { cout &lt;&lt; \"Person\" &lt;&lt; endl; } ~Person() { cout &lt;&lt; \"end ~Person\" &lt;&lt; endl; } //姓名 string m_Name; //手机 Phone m_Phone; }; //当其他类对象作为本类成员,构造时会先构造类对象,再构造自身,也就是先构造手机再构造人 //析构函数的执行顺序是和构造的顺序是相反的,也就是先析构人,再析构手机 void test01() { Person p(\"zs\", \"appleMAX\"); cout &lt;&lt; p.m_Name &lt;&lt; \" need: \" &lt;&lt; p.m_Phone.m_PName &lt;&lt; endl; } int main() { test01(); return 0; }静态成员变量 //静态成员变量 #include &lt;iostream&gt; using namespace std; class Person { public: //非静态成员变量 int m_A; //静态成员变量 //所有对象都共享同一份数据 //编译阶段就分配内存 //类内声明,类外要进行初始化操作 static int m_B; //静态成员变量也是有访问权限的 private: static int m_C; }; //类外初始化 int Person::m_B = 100; int Person::m_C = 200; void test01() { Person p; cout &lt;&lt; p.m_B &lt;&lt; endl; Person p2; p2.m_B = 200; //因为静态成员变量的数据是共享的,所以在这里p2将数据改成200,那么p再去访问时就变成了200 cout &lt;&lt; p.m_B &lt;&lt; endl; } void test02() { //静态成员变量 不属于某个对象上,所有对象都共享同一份数据 //因此静态成员变量有两种访问方式: // 1、通过对象进行访问 Person p; cout &lt;&lt; p.m_B &lt;&lt; endl; // 2、通过类名进行访问 // using namespace std就是起这个作用，否则要写成std::cout &lt;&lt; std:: endl cout &lt;&lt; Person::m_B &lt;&lt; endl; //这里报错是因为,m_C是在私有作用域的权限下,私有作用域是只有在类内才可以访问,类内不可以访问 // cout &lt;&lt; Person::m_C &lt;&lt; endl; } int main() { // test01(); test02(); return 0; }静态成员函数 //静态成员函数 #include &lt;iostream&gt; using namespace std; //所有对象共享一个函数 //静态成员函数只能访问静态成员变量 class Person { public: //静态成员函数 static void func() { //静态的成员函数是可以访问静态的成员变量 m_A = 100; //这里报错是因为m_B是非静态的成员变量,而静态成员函数只能访问静态成员变量 //无法区分到底是哪个对象的m_B属性,因为静态成员函数所有对象都可以访问 // m_B = 200; cout &lt;&lt; \"static void func\" &lt;&lt; endl; } //静态成员变量 static int m_A; //非静态的成员变量 int m_B; //静态成员函数也是有访问权限的 private: static void func2() { cout &lt;&lt; \"static void func2()\" &lt;&lt; endl; } }; int Person::m_A = 0; void test01() { //静态成员函数有两种访问方式 // 1、通过对象访问 Person p; p.func(); // 2、通过类名访问 Person::func(); //这里报错是因为私有作用域类内可以访问,类外不可以访问,类外访问不到私有的静态成员函数 // Person::func2(); } int main() { test01(); return 0; }成员变量和成员函数的分开存储 //成员变量和成员函数的分开存储 #include &lt;iostream&gt; using namespace std; class Person { public: //只有非静态成员变量属于静态上，剩下的都不属于对象上 //非静态的成员变量 int m_A; //静态成员变量 //静态成员变量不属于类的对象上,所以在分配内存时不会算上 static int m_B; //非静态成员函数,也不属于类的对象上,在分配内存时也不会算上,除非根据this指针调用 void func() { } //静态的成员函数,也不属于类的对象上,在分配内存时也不会算上 //不管是静态的还是非静态的成员,共享的都是同一块内存 static void func2() { } }; //静态成员变量需要声明 int Person::m_B = 0; void test01() { Person p; //空对象的占用内存空间为: 1 // C++编译器会给每个空对象也分配一个字节空间,是为了区分空对象占内存的位置 //每个空对象都会有一个独一无二的内存地址 cout &lt;&lt; \"size of p = \" &lt;&lt; sizeof(p) &lt;&lt; endl; } void test02() { Person p; //如果对象不是空的,那么就会根据对象里面的值来分配内存 cout &lt;&lt; \"size of p = \" &lt;&lt; sizeof(p) &lt;&lt; endl; } int main() { // test01(); test02(); return 0; } this指针 this指针概念空指针访问常函数和常对象this指针概念 // this指针概念 // this指针指向被调用的成员函数所属对象 // this指针是隐含每一个非静态成员函数内的一种指针 #include &lt;iostream&gt; using namespace std; // this指针指向的就是对象，通过*this解引用可以访问该对象本身 //静态函数没有this指针，因为静态函数不属于某个对象 class Person { public: Person(int age) { //这里赋值不会成功,因为变量名重名了,和类里面的成员变量age没有任何关联 // age = age; //加入this指针就可以解决这个命名冲突的问题 // this指针指向的是被调用的成员函数所属的对象,也就是说p1在调用这个有参构造函数时 // this所指向的就是p1,谁调用的这个函数,this就指向谁 this-&gt;age = age; } void PersonAddAge(Person &amp;p) { //将p1的年龄加到p2身上 this-&gt;age += p.age; } //如果想要返回p2对象的本体,那么就需要在函数名前加&amp;符号,如果不加&amp;符号返回的就是其他Person对象 //注意如果这里不加&amp;符号,那么每次函数都在拷贝，最后拷贝的匿名函数不管执行操作多少次都变为20 //也就是以值的方式返回,每次都返回一个新的数据,跟原来的数据没有关联 Person &amp;PersonAddAge2(Person &amp;p) { this-&gt;age += p.age; //通过指针解引用的方式就可以返回当前这个对象 // this指向p2的指针,而*this指向的就是p2这个对象的本体 return *this; } int age; }; void test01() { Person p1(18); cout &lt;&lt; \"p1 age:\" &lt;&lt; p1.age &lt;&lt; endl; } void test02() { Person p1(10); Person p2(10); //这里通过this指针指向p2,然后将p1的值传过去,再把p1的值加到p2身上 // p2.PersonAddAge(p1); //链式编程,当p2调用了一次函数后,返回的*this是加完p1的值的p2,那么就可以再调用很多次 //当第一次调用加10,第二次调用时返回的是p2加了10后的本体也就是20,再加10也就是20+10=30, //然后30再调用加10变成40 p2.PersonAddAge2(p1).PersonAddAge2(p1).PersonAddAge2(p1); // cout这个函数本质也是像上面一样的链式编程思想,可以不停的在后面追加 cout &lt;&lt; \"p2 age:\" &lt;&lt; p2.age &lt;&lt; endl; } int main() { // test01(); test02(); return 0; }空指针访问成员函数 //空指针访问成员函数 #include &lt;iostream&gt; using namespace std; class Person { public: //成员函数 void showClassName() { cout &lt;&lt; \"this is Person class\" &lt;&lt; endl; } void showPersonAge() { //解决空指针报错的问题: //传入空指针就会报错,所以要判断this指向的是不是空指针,如果是则直接终止函数 if (this == NULL) { return; } //其实这里输出m_Age可以看作为:this-&gt;m_Age cout &lt;&lt; \"age = \" &lt;&lt; m_Age &lt;&lt; endl; } int m_Age; }; void test01() { //创建一个空指针对象, Person *p = NULL; //这里不会报错,因为空指针没有访问成员变量 p-&gt;showClassName(); //这里会报错因为在函数内部使用了this-&gt;m_Age,而this指向的不是对象而是一个空指针,所以会报错 p-&gt;showPersonAge(); } int main() { test01(); return 0; }常函数和常对象 //常函数和常对象 #include &lt;iostream&gt; using namespace std; class Person { public: Person() { } // this指针的本质是指针常量 指针的指向是不可以修改的 指针指向的值可以修改 void showPerson() const { //这里会报错,因为在成员函数后面加上const后就变成了常函数,就不允许修改属性的值了 //因为下面可以看作是 this-&gt;m_A=100,而在函数后面加上const后,也就是在this前面 //加上了const,变成了const Person * const this, 值和指向都不可以修改了 // m_A = 100; this-&gt;m_B = 100; } void func() { m_A = 100; cout &lt;&lt; m_A &lt;&lt; endl; } int m_A; //如果加了mutable这个关键字之后就可以把普通成员变量变成常函数里可修改的变量 mutable int m_B; //注意:常对象可以修改静态变量的值 }; void test01() { Person p; p.showPerson(); } void test02() { //在创建对象前加上const,就可以变为常对象 const Person p; //这里会报错,因为常对象中的普通成员变量不可直接修改 // p.m_A = 100; //这里不会报错,因为m_B加上了mutable关键字变成了可修改的变量,在常对象上也可以修改 p.m_B = 200; //这里会报错,因为常对象只能调用常函数,不可以调用普通成员函数 // p.func(); } int main() { test01(); return 0; } 友元 友元函数友元类成员函数做友元友元函数 //友元函数 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //建筑物类 class Building { //当在一个全局函数声明前面加上friend关键字,那么这个全局函数就可以访问这个对象的 //所有私有属性,就像是goodGay这个函数是Building这个对象的好朋友一样,也就是友元函数 friend void goodGay(Building *building); public: Building() { m_SittingRoom = \"keting\"; m_BedRoom = \"woshi\"; } //客厅 string m_SittingRoom; private: //卧室 string m_BedRoom; }; //全局函数 void goodGay(Building *building) { //对象是指针型时访问用箭头，对象是变量型时访问用点。 //类比数据结构中结构体变量和结构体指针访问成员的区别 cout &lt;&lt; \"firend :\" &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; //这里会报错,因为私有属性不可以访问 // cout &lt;&lt; \"firend :\" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; //当在函数声明前加上friend变成友元函数的时候,这个函数就可以访问对象里的私有属性了 cout &lt;&lt; \"firend :\" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; } void test01() { Building building; goodGay(&amp;building); } int main() { test01(); return 0; }友元类 //友元类 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //声明一个类,暂时还实现不了这个类又需要在其他类中使用到它的时候可以先声明 //其实就是类内声明，然后在类外实现函数 class Building; class GoodGay { public: //也写一个公开的构造函数 GoodGay(); //普通成员函数,通过这个函数来访问Building中的属性 void visit(); Building *building; }; class Building { //这样就把GoodGay这个类作为了友元类 friend class GoodGay; public: //写一个公开的构造函数 Building(); public: //客厅 string m_SittingRoom; private: //卧室 string m_BedRoom; }; //类外写成员函数 //为了体现封装的思想，一般把类声明写在头文件中，将类成员函数的实现写在c文件中 Building::Building() { m_SittingRoom = \"keting\"; m_BedRoom = \"woshi\"; } GoodGay::GoodGay() { //创建一个建筑物对象 //用new来创建building的话，灵活度就增大了，开发者随时用完这个变量，随时就可以将这块内存释放。 //如果不用new，单纯只用Building building ；则在 goodGay gg ; 之后building将被释放 //之后再调用building里的属性就会访问到空指针然后出错，所以要用new开辟堆区数据 //其实也可以理解为:new什么类型就返回什么类型的指针 //用类里面本来就定义好的building指针来接收维护这块内存 building = new Building; } void GoodGay::visit() { //访问客厅 cout &lt;&lt; \"friend:\" &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; //访问卧室,这里如果不把GoodGay类作为友元就会报错 //也就是在Building类中将GoodGay类前面写上friend关键字 // cout &lt;&lt; \"friend\" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; //加了友元后,可以正常访问了 cout &lt;&lt; \"friend:\" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; } //其实可以将上面理解为,在类内声明了一个构造函数之后,就可以在类外通过::的方式控制这个函数 //并在里面写具体实现的方法,这和在类内成员函数里写是一样的 void test01() { //创建一个好朋友对象 GoodGay gg; //调用函数访问Building类中的属性 //一个类的指针指向另一个类，另一个类含有这个类的友元就能访问了 gg.visit(); } int main() { test01(); return 0; }成员函数做友元 //成员函数做友元 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Building; class GoodGay { public: GoodGay(); //让visit函数访问Building中私有成员 void visit(); //让visit2函数不可以访问Building中的私有成员 void visit2(); Building *building; }; class Building { //将visit函数声明为Building的友元,也就是将GoodGay下的visit函数作为Building的友元 //之后visit就可以访问Building中的私有属性 friend void GoodGay::visit(); public: //声明公开构造函数 Building(); public: //客厅 string m_SittingRoom; private: //卧室 string m_BedRoom; }; //类外实现成员函数 //给Building里的属性赋值 Building::Building() { m_SittingRoom = \"keting\"; m_BedRoom = \"woshi\"; } GoodGay::GoodGay() { //创建一个Building对象在堆区,用指针维护这个对象 building = new Building; } void GoodGay::visit() { //访问客厅 cout &lt;&lt; \"visit:\" &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; //访问卧室 cout &lt;&lt; \"visit:\" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; } void GoodGay::visit2() { //访问客厅 cout &lt;&lt; \"visit2:\" &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; //访问卧室,注意:如果不声明为友元那么就不可以访问 // cout &lt;&lt; \"visit2:\" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; } void test01() { GoodGay gg; gg.visit(); gg.visit2(); } int main() { test01(); return 0; } 运算符重载 加号左移递增赋值关系函数加号运算符重载 //加号运算符重载 #include &lt;iostream&gt; using namespace std; //注意:对于内置的数据类型的表达式的运算符是不可能改变的 class Person { public: // 1、成员函数重载+号 // operator是C++内置的自带函数重载运算 // Person operator+(Person &amp;p) // { // Person temp; // //这里this指向的是调用改函数的对象 // temp.m_A = this-&gt;m_A + p.m_A; // temp.m_B = this-&gt;m_B + p.m_B; // //将运算后的对象返回 // return temp; // } int m_A; int m_B; }; // 2、全局函数重载+号 Person operator+(Person &amp;p1, Person &amp;p2) { Person temp; temp.m_A = p1.m_A + p2.m_A; temp.m_B = p1.m_B + p2.m_B; return temp; } //函数重载的版本 Person operator+(Person &amp;p1, int num) { Person temp; temp.m_A = p1.m_A + num; temp.m_B = p1.m_B + num; return temp; } void test01() { Person p1; p1.m_A = 10; p1.m_B = 10; Person p2; p2.m_A = 10; p2.m_B = 10; //这里会报错,因为还没有写运算符重载 // Person p3 = p1 + p2; //当定义了函数重载之后就不会报错了 // Person p3 = p1 + p2; //上面其实是下面的简化,成员函数重载的本质其实是: /// Person p3 = p1.operator+(p2); //全局函数重载的本质其实是: Person p3 = operator+(p1, p2); //运算符重载 也可以发生函数重载 // Person类型+int类型 Person p4 = p1 + 100; cout &lt;&lt; \"p3.m_A = \" &lt;&lt; p3.m_A &lt;&lt; endl; cout &lt;&lt; \"p3.m_B = \" &lt;&lt; p3.m_B &lt;&lt; endl; cout &lt;&lt; \"p4.m_A = \" &lt;&lt; p4.m_A &lt;&lt; endl; cout &lt;&lt; \"p4.m_B = \" &lt;&lt; p4.m_B &lt;&lt; endl; } int main() { test01(); return 0; }左移运算符重载 //左移运算符重载 #include &lt;iostream&gt; using namespace std; //重载左移运算符配合友元可以实现输出自定义数据类型 class Person { //将全局函数重载变成友元访问私有属性 friend ostream &amp;operator&lt;&lt;(ostream &amp;out, Person &amp;p); public: Person(int a, int b) { m_A = a; m_B = b; } private: //利用成员函数重载左移运算符 //一般不会利用成员函数重载左移运算符,因为调用时会变成p.operator&lt;&lt;(cout)或者p&lt;&lt;cout //无法实现cout在左侧 // void operator&lt;&lt;(cout) // { // } int m_A; int m_B; }; //只能利用全局函数重载左移运算符 //本质其实是 operator&lt;&lt;(cout,p) 简化 cout&lt;&lt;p // cout其实是ostream的对象,且这个对象全局只能有一个 // cout可以起别名为out,因为引用的本身就是起别名,因为cout是实参,而out是形参 // out和cout指向的都是同一块内存空间 ostream &amp;operator&lt;&lt;(ostream &amp;out, Person &amp;p) { out &lt;&lt; \"m_A= \" &lt;&lt; p.m_A &lt;&lt; \" m_B= \" &lt;&lt; p.m_B &lt;&lt; endl; return out; } void test01() { Person p(10, 10); //当运行到这句时,系统会自动去调用与cout&lt;&lt;p相关的函数重载左移运算符 //只有在函数重载左移运算符里返回了cout后才能够继续链式调用&lt;&lt;endl; cout &lt;&lt; p &lt;&lt; \"Hello,World\" &lt;&lt; endl; } int main() { test01(); return 0; }递增运算符重载 //递增运算符重载 #include &lt;iostream&gt; using namespace std; //自定义整形 class MyInteger { //重载左移运算符做友元,这样的话左移运算函数就可以访问私有属性 friend ostream &amp;operator&lt;&lt;(ostream &amp;cout, MyInteger myint); public: //在构造函数中初始化私有成员变量m_Num为0 MyInteger() { m_Num = 0; } //重载前置++运算符 //如果不返回加了&amp;的对象,就会一直对新的对象使用自增,那么就无法一直对原来的对象使用自增 //无法实现链式编程 MyInteger &amp;operator++() { //先进行++运算 m_Num++; //再将自身做返回 return *this; } //重载后置++运算符 // int 代表占位参数,可以用于区分前置和后置递增,也就是通过占位参数不同来区分函数重载 //这里只返回值不返回引用&amp;的原因是temp是一个局部的对象,局部的对象在函数执行完后就释放掉了 //如果返回引用的话就会报错,所以后置递增一定是返回值不是引用 MyInteger operator++(int) { //先记录当时的结果 //*this指向的是调用这个函数的对象本身的值 MyInteger temp = *this; //后递增 m_Num++; //最后将记录结果做返回 return temp; } private: int m_Num; }; //重载左移运算符 ostream &amp;operator&lt;&lt;(ostream &amp;cout, MyInteger myint) { cout &lt;&lt; myint.m_Num; return cout; } void test01() { MyInteger myint; //这里如果不写重载左移运算符就会报错 //其实可以理解为当程序执行到这句的时候就会找和&lt;&lt;有关的函数,然后控制这个函数, //执行函数里面的内容作为输出,因为operator可以省略,所以才能够用&lt;&lt;代替 cout &lt;&lt; ++myint &lt;&lt; endl; cout &lt;&lt; myint &lt;&lt; endl; } void test02() { MyInteger myint; cout &lt;&lt; myint++ &lt;&lt; endl; cout &lt;&lt; myint &lt;&lt; endl; } int main() { // test01(); test02(); //普通的链式自增实现 int a; // cout &lt;&lt; ++(++a) &lt;&lt; endl; //注意:c++本身不支持链式的后置递增 return 0; }赋值运算符重载 //赋值运算符重载 #include &lt;iostream&gt; using namespace std; // C++编译器会至少给一个类添加4个函数 // 1、默认构造函数(无参,函数体为空) // 2、默认析构函数(无参,函数体为空) // 3、默认拷贝构造函数,对属性进行值拷贝 // 4、赋值运算符 operator=,对属性进行值拷贝 //注意，对象与对象之间做赋值操作的时候就会用到它默认提供的赋值运算符操作 class Person { public: //有参构造 Person(int age) { //创建一个数据在堆区,并且用指针来维护这个数据 m_Age = new int(age); } ~Person() { if (m_Age != NULL) { delete m_Age; m_Age = NULL; } } //如果不自己定义拷贝构造函数就会出现内存重复释放的问题 //释放过后就没有操作权限，容易引起非法操作，第二次释放就是危险操作 //另一种办法就是重新定义重载赋值运算符操作 // 1.注意:这里的重载函数的参数一定要以引用或者指针的形式传入!! // 2.不然在传入的时候进行了一次拷贝将赋值右边p2的值传入的时候临时变量记录的p2的属性m_Age的地址 // 3.而出了赋值运算符重载函数会进行一次析构 这时p2的属性new出来的空间已经被释放了 // 4.最后结束调用虽然你深拷贝了但是程序还是会崩 Person &amp;operator=(Person &amp;p) { //编译器默认提供的是浅拷贝代码 // m_Age = p.m_Age; //应该先判断是否有属性在堆区,如果有先释放干净,然后再深拷贝 if (m_Age != NULL) { //必须要释放，因为此时是赋值，不是之前的拷贝构造了,所以只有清空了指针的内容 //才可以赋值新的内容进去 delete m_Age; m_Age = NULL; } //自己写深拷贝代码 //通过解引用解出来对象原本传入的那个值(18) m_Age = new int(*p.m_Age); //如果要实现链式赋值的话就要返回这个对象的本身 return *this; //实际上还是深拷贝，只不过之前的深拷贝是在拷贝构造函数中，这次是在赋值运算符重载函数中 } //年龄的指针 int *m_Age; }; void test01() { Person p1(18); Person p2(20); Person p3(30); //赋值运算的操作 p3 = p2 = p1; //通过指针解引用的方式拿到堆区的数据 cout &lt;&lt; \"p1 age:\" &lt;&lt; *p1.m_Age &lt;&lt; endl; cout &lt;&lt; \"p2 age:\" &lt;&lt; *p2.m_Age &lt;&lt; endl; cout &lt;&lt; \"p3 age:\" &lt;&lt; *p3.m_Age &lt;&lt; endl; } int main() { test01(); //普通的链式赋值操作 int a = 10; int b = 20; int c = 30; //赋值运算符的运算顺序是从右往左。 c = b = a; // cout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; \"\\nb=\" &lt;&lt; b &lt;&lt; \"\\nc=\" &lt;&lt; c &lt;&lt; endl; return 0; }关系运算符重载 //关系运算符重载 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Person { public: //有参构造函数 Person(string name, int age) { m_Name = name; m_Age = age; } //重载==号 bool operator==(Person &amp;p) { //如果传进来的m_Name==原本的m_Name,并且年龄也相等,那么这两个对象就是相等的 if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) { return true; } return false; } //重载!=号 bool operator!=(Person &amp;p) { if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) { return false; } return true; } string m_Name; int m_Age; }; void test01() { //有参构造 Person p1(\"Tom\", 18); Person p2(\"Tom\", 18); //重载==号,使其判断两个对象是否相等 if (p1 == p2) { cout &lt;&lt; \"p1==p2\" &lt;&lt; endl; } else { cout &lt;&lt; \"p1!=p2\" &lt;&lt; endl; } //重载!=号,使其判断两个对象是否不相等 if (p1 != p2) { cout &lt;&lt; \"p1!=p2\" &lt;&lt; endl; } else { cout &lt;&lt; \"p1==p2\" &lt;&lt; endl; } } int main() { test01(); return 0; }函数调用运算符重载 //函数调用运算符重载 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //打印输出的类 class MyPrint { public: //重载函数调用运算符,第一个小括号代表重载函数符号,第二个小括号代表形参列表 //也可以将返回值返回MyPrint&amp;（*this），可以链式调用myPrint(\"1\")(\"2\") void operator()(string test) { cout &lt;&lt; test &lt;&lt; endl; } }; void MyPrint02(string test) { cout &lt;&lt; test &lt;&lt; endl; } void test01() { MyPrint myPrint; //这就是函数运算符重载,调用的是类里面的重载函数,也可以称为仿函数 myPrint(\"Hello,World\"); //这是普通输出函数的写法 MyPrint02(\"Hello,World\"); } //加法类 class MyAdd { public: //函数重载本身非常灵活,可以进行各种运算 int operator()(int num1, int num2) { return num1 + num2; } }; void test02() { MyAdd myadd; int ret = myadd(100, 100); cout &lt;&lt; \"ret = \" &lt;&lt; ret &lt;&lt; endl; //匿名函数对象,不需要创建对象也能调用类里面的函数重载,注意名字要与类名相同 //其实也就是使用了函数里面的重载运算符,匿名对象运行完就会立即释放 cout &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl; } int main() { test01(); test02(); return 0; } 继承 继承概念实现方式对象模型构造和析构顺序同名成员处理同名静态成员处理多继承菱形继承继承的概念 //继承 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //编写一个java类 // class Java // { // public: // void header() // { // cout &lt;&lt; \"home,public,sogin,zc\" &lt;&lt; endl; // } // void footer() // { // cout &lt;&lt; \"help,bobom,dt\" &lt;&lt; endl; // } // void left() // { // cout &lt;&lt; \"Java,python,C++,...list\" &lt;&lt; endl; // } // void content() // { // cout &lt;&lt; \"Java video\" &lt;&lt; endl; // } // }; // // python // class Python // { // public: // void header() // { // cout &lt;&lt; \"home,public,sogin,zc\" &lt;&lt; endl; // } // void footer() // { // cout &lt;&lt; \"help,bobom,dt\" &lt;&lt; endl; // } // void left() // { // cout &lt;&lt; \"Java,python,C++,...list\" &lt;&lt; endl; // } // void content() // { // cout &lt;&lt; \"Python video\" &lt;&lt; endl; // } // }; // // C++ // class CPP // { // public: // void header() // { // cout &lt;&lt; \"home,public,sogin,zc\" &lt;&lt; endl; // } // void footer() // { // cout &lt;&lt; \"help,bobom,dt\" &lt;&lt; endl; // } // void left() // { // cout &lt;&lt; \"Java,python,C++,...list\" &lt;&lt; endl; // } // void content() // { // cout &lt;&lt; \"C++ video\" &lt;&lt; endl; // } // }; //继承实现 //公共页面类 class BasePage { public: void header() { cout &lt;&lt; \"home,public,sogin,zc\" &lt;&lt; endl; } void footer() { cout &lt;&lt; \"help,bobom,dt\" &lt;&lt; endl; } void left() { cout &lt;&lt; \"Java,python,C++,...list\" &lt;&lt; endl; } }; //继承的好处:减少重复代码 //语法:class子类:继承方式 父类 //子类也称为派生类 //父类也称为基类 //继承Java页面 class Java : public BasePage { public: void content() { cout &lt;&lt; \"Java video\" &lt;&lt; endl; } }; //继承python页面 class Python : public BasePage { public: void content() { cout &lt;&lt; \"Python video\" &lt;&lt; endl; } }; //继承c++页面 class CPP : public BasePage { public: void content() { cout &lt;&lt; \"CPP video\" &lt;&lt; endl; } }; void test01() { cout &lt;&lt; \"java domdown\" &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; \"------------------\" &lt;&lt; endl; cout &lt;&lt; \"python domdown\" &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; \"------------------\" &lt;&lt; endl; cout &lt;&lt; \"c++ domdown\" &lt;&lt; endl; CPP cpp; cpp.header(); cpp.footer(); cpp.left(); cpp.content(); } int main() { test01(); return 0; }继承的实现方式 //继承的实现方式 //注意:如果一个父类把属性设置为私密,那么无论什么子类都访问不到它(友元可以访问) //如果父类中有保护权限protected和公开权限(public),那么保护权限的子类继承过来会把公开权限也变成保护权限 //如果父类中有保护权限和公开权限,那么私有权限的子类继承过来会把公开权限和保护权限都变成私有权限 // protected与private的区别在于继承方面,儿子可以访问protected不可以访问private #include &lt;iostream&gt; using namespace std; //公共继承 //父类 class Base1 { public: int m_A; protected: int m_B; private: int m_C; }; //子类1,公共继承 class Son1 : public Base1 { public: void func() { //父类中的公共成员变量,到子类中依然是公共权限 m_A = 10; //父类中的保护权限成员,到子类中依然是保护权限 m_B = 10; //这里会报错,因为父类中的私有权限成员,不可以被子类访问 // m_C = 10; } //函数外只能定义全局变量或者对象 ，而不能执行语句及调用函数， 这句话一定要谨记 }; //父类2,保护继承 class Base2 { public: int m_A; protected: int m_B; private: int m_C; }; //子类2,保护继承 class Son2 : protected Base2 { public: //如果没有void func() 成员函数， //编译器会自动认为m_A,m_B是子类成员，就继承不过来 void func() { //父类中公共成员,到子类在变为保护权限 m_A = 100; //父类中保护成员,到子类中变为保护权限 m_B = 100; //这里会报错,因为父类中的私有权限成员,不可以被子类访问 // m_C = 100; } }; class Base3 { public: int m_A; protected: int m_B; private: int m_C; }; //子类3,私有继承 class Son3 : private Base3 { public: void func() { //父类中公共和保护的成员到子类中会变为私有成员 m_A = 100; m_B = 100; ////这里会报错,因为父类中的私有权限成员,不可以被子类访问 // m_C = 100; } }; //孙子类,孙子继承私有的子类 class GrandSon3 : public Son3 { public: void func() { //这里依旧会报错,到了子类中属性变为私有,即使是孙子类也访问不到 // m_A = 1000; // m_B = 1000; } }; void test03() { Son3 s1; //这里会报错,因为到子类中变为了私有的成员,类外访问不到 // s1.m_A = 200; } void test02() { Son2 s1; //这里不可以访问,因为到子类中m_A变为了保护权限,类外访问不到 // s1.m_A = 1000; //这里不可以访问,因为到子类中m_B变为了保护权限,类外访问不到 // s1.m_B = 1000; } void test01() { Son1 s1; //这里可以访问是因为,m_A到子类后是公共权限,公共权限类内和类外都可以访问 s1.m_A = 100; //这里会报错是因为m_B到子类后是保护权限,保护权限类内可以访问,类外不可以访问 // s1.m_B = 100; } int main() { test01(); return 0; }继承当中的对象模型 //继承当中的对象模型 #include &lt;iostream&gt; using namespace std; //父类 class Base { public: int m_A; protected: int m_B; private: int m_C; }; //子类 class Son : public Base { public: int m_D; }; void test01() { // 16 子类会继承父类的所有成员的属性的内存,并且加上自身的 //父类中所有的非静态成员属性都会被子类继承下去 //父类中私有成员属性 是被编译器给隐藏了,因此是访问不到,但是确实是被继承下去了 cout &lt;&lt; \"size of Son = \" &lt;&lt; sizeof(Son) &lt;&lt; endl; } int main() { test01(); return 0; }继承中的构造和析构顺序 //继承中的构造和析构顺序 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //父类 class Base { public: //构造函数 Base() { cout &lt;&lt; \"Base\" &lt;&lt; endl; } //析构函数 ~Base() { cout &lt;&lt; \"end Base\" &lt;&lt; endl; } }; //子类,通过公共方式继承父类 class Son : public Base { public: //构造函数 Son() { cout &lt;&lt; \"Son\" &lt;&lt; endl; } //析构函数 ~Son() { cout &lt;&lt; \"end Son\" &lt;&lt; endl; } }; void test01() { //当对象创建时会自动调用构造和析构函数 // Base b; //当创建一个子类对象时会先创建一个父类对象,同时调用父类的构造函数 //当函数要销毁时是先销毁子类的析构函数,再销毁父类的析构函数,析构的顺序和构造的顺序是相反的 Son s; } int main() { test01(); return 0; }继承中同名成员的处理方式 //继承中同名成员的处理方式 //访问子类的同名成员,直接访问即可 //访问父类的同名成员,需要加作用域 #include &lt;iostream&gt; using namespace std; //父类 class Base { public: Base() { //在构造函数中给m_A属性赋初值 m_A = 100; } void func() { cout &lt;&lt; \"Base-func()\" &lt;&lt; endl; } //函数重载 //函数重载的条件是要在同一作用域下 void func(int a) { cout &lt;&lt; \"Base-func(int a)\" &lt;&lt; endl; } int m_A; }; //子类 class Son : public Base { public: //在子类构造函数中给m_A属性赋初值 Son() { m_A = 200; } //同名函数 void func() { cout &lt;&lt; \"Son-func()\" &lt;&lt; endl; } //同名成员 int m_A; }; void test01() { Son s; //此时输出是200，因为是子类调用自己的函数 cout &lt;&lt; \"m_A=\" &lt;&lt; s.m_A &lt;&lt; endl; //如果要通过子类对象访问父类中的同名成员,需要加作用域 cout &lt;&lt; \"Base = \" &lt;&lt; s.Base::m_A &lt;&lt; endl; } //同名成员函数的处理方式 void test02() { Son s; //如果子类中没有写同名的成员函数,那么子类访问函数时就可以直接访问父类的函数 //否则调用的就是子类中的函数,当直接调用会优先访问子类的成员 s.func(); //通过加作用域的方式调用父类中的函数 s.Base::func(); //包括调用父类中的函数重载也是一样的需要加作用域 //当子类出现和父类一样的同名成员时,子类中的成员会隐藏掉父类中所有的成员 函数 s.Base::func(10); } int main() { // test01(); test02(); return 0; }继承中的同名静态成员处理方式 //继承中的同名静态成员处理方式 #include &lt;iostream&gt; using namespace std; //父类 class Base { public: //将变量变成静态成员变量 //在对象创建前就分配内存,所有对象共享一份数据,类内声明,类外初始化 static int m_A; //定义一个静态成员函数 static void func() { cout &lt;&lt; \"Base - static void func()\" &lt;&lt; endl; } }; //类外初始化 int Base::m_A = 100; //子类 class Son : public Base { public: //同名静态成员属性 static int m_A; //同名的静态成员函数 static void func() { cout &lt;&lt; \"Son - static void func()\" &lt;&lt; endl; } }; //类外初始化 int Son::m_A = 200; //同名静态成员属性 void test01() { // 1:通过对象访问 Son s; //访问子类下的静态成员变量 cout &lt;&lt; \"m_A = \" &lt;&lt; s.m_A &lt;&lt; endl; //访问父类下的静态成员变量 cout &lt;&lt; \"Base m_A = \" &lt;&lt; s.Base::m_A &lt;&lt; endl; // 2:通过类名访问 cout &lt;&lt; \"Son m_A = \" &lt;&lt; Son::m_A &lt;&lt; endl; //通过类名的方式访问子类作用域下的父类的静态成员属性 cout &lt;&lt; \"Base m_A = \" &lt;&lt; Son::Base::m_A &lt;&lt; endl; } void test02() { Son s; // 1.通过对象的方式访问 //调用子类的函数 s.func(); //调用父类的函数 s.Base::func(); // 2.通过类名的方式访问 Son::func(); //静态成员函数只能访问静态成员变量,但因为是静态，再全局区， //所以可以通过类来访问，而非静态是栈区，运行完就直接释放 Son::Base::func(); } //同名静态成员函数 int main() { // test01(); test02(); return 0; }多继承语法 //多继承语法 #include &lt;iostream&gt; using namespace std; //第一个父类 class Base1 { public: //构造函数 Base1() { m_A = 100; } int m_A; }; //第二个父类 class Base2 { public: Base2() { m_A = 200; } //同名变量 int m_A; }; //子类,多继承,先继承Base1,再继承Base2 class Son : public Base1, public Base2 { public: Son() { m_C = 300; m_D = 400; } int m_C; int m_D; }; void test01() { Son s; // 16个字节,因为继承了两个父亲的4个属性 cout &lt;&lt; \"sizeof Son = \" &lt;&lt; sizeof(s) &lt;&lt; endl; //如果这里的父类里有两个同名的成员,需要加作用域区分,不然就会报错 cout &lt;&lt; s.Base1::m_A &lt;&lt; endl; cout &lt;&lt; s.Base2::m_A &lt;&lt; endl; } int main() { test01(); return 0; }菱形继承 //菱形继承,也叫钻石继承 #include &lt;iostream&gt; using namespace std; //动物类 class Animal { public: int m_Age; }; //羊类,继承了动物类,利用虚继承,解决菱形继承的问题 //加上关键字virtual就会使继承变成虚继承,加了虚继承之后原本的最大的父类就变成了虚基类 class Sheep : virtual public Animal { }; //驼类,继承了动物类,使其变成虚继承 //相当于开辟一个父类的变量名的类型空间存储，而子类继承的不是拷贝父类的内存空间， //而是直接继承一个指针指向那块数据的存储空间 class Tuo : virtual public Animal { }; //羊驼类,既继承了羊类又继承了驼类 class SheepTuo : public Sheep, public Tuo { }; void test01() { SheepTuo st; //这里会报错,因为这样的菱形继承会使SheepTuo类继承两份m_Age数据,系统不知道给哪一个赋值 //出现这种情况可以用虚继承,也可以用作用域区分 // st.m_Age = 18; st.Sheep::m_Age = 18; st.Tuo::m_Age = 28; //当两个父类有相同的数据,需要加以作用域区分 cout &lt;&lt; \"Sheep::m_Age = \" &lt;&lt; st.Sheep::m_Age &lt;&lt; endl; cout &lt;&lt; \"Tuo::m_Age = \" &lt;&lt; st.Tuo::m_Age &lt;&lt; endl; //如果要拿到SheepTuo的年龄就要利用虚继承 //当加了虚继承之后再直接访问SheepTuo的年龄就不会出现二义性了 //因为加了虚继承之后数据就只有一份,不管怎么继承都只有一个数据可以输出 //其实也可以理解为加了一个指针指向最开始的那个变量,当有赋值时全部的变量就都改变了 //如上面一开始赋值为18,后面又重新赋值为28,因为指针赋值的关系把所有的数据都变成了28 cout &lt;&lt; \"st.m_Age = \" &lt;&lt; st.m_Age &lt;&lt; endl; } int main() { test01(); return 0; } 多态 多态概念计算器纯虚函数制作饮品虚析构和纯虚析构电脑组装多态概念 //多态 #include &lt;iostream&gt; using namespace std; //动态多态的满足条件: // 1、重写子类的虚函数 // 2、有继承关系 // 3、子类重写父类的虚函数 //动态多态的使用: //父类的指针或者引用 指向子类对象 //动物类 class Animal { public: //虚函数 virtual void speak() { cout &lt;&lt; \"Animal speak\" &lt;&lt; endl; } }; //猫类 class Cat : public Animal { public: //同名的成员函数 //重写要满足： 函数返回值类型 函数名 参数列表 完全相同 void speak() { cout &lt;&lt; \"cat speak\" &lt;&lt; endl; } }; //狗类 //必须有继承关系，才能保证传入的的类被引用。 //一个对父类执行操作的函数一定也可以对子类操作(子类继承了父类，所以父类有的子类肯定也有) class Dog : public Animal { public: //同名的成员函数 // c++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。 //因此，在子类重新声明该虚函数时，可以加virtual，也可以不加virtual void speak() { cout &lt;&lt; \"Dog speak\" &lt;&lt; endl; } }; //执行说话的函数 //父类引用接收子类对象 //父子之间允许类型转换 //因为父类与子类的函数同名,地址早绑定,在编译阶段就确定了函数地址, //所以不管传入的子类是什么,都会执行父类的函数 //如果想执行子类的同名函数那么这个函数地址就不能提前绑定,需要在运行阶段进行绑定,也就是地址晚绑定 //其实也就是在父类的同名函数前加上virtual变成虚函数,加了之后就可以实现地址晚绑定 //注意:只能传入父类的指针/引用 才能实现多态！ 值传递是不可以滴 void doSpeak(Animal &amp;animal) // Animal &amp; animal = cat; { animal.speak(); } void test01() { //创建一个猫类 Cat cat; //把猫传进去 doSpeak(cat); //创建一个狗类 Dog dog; //把狗传进去 doSpeak(dog); } void test02() { //这里输出的4个字节,因为加了virtual虚函数指针 //其实可以理解多态为:当子类继承父类时,子类会拷贝父类身上的所有数据和属性 //那么当子类重写父类的函数时会被继承后的父类的函数给替换 //所以访问子类的同名函数时会调用父类函数 //解决办法就是加了虚指针virtual后子类重写的就是父类的虚函数 //子类中的虚函数表 内部 会替换成 子类的虚函数地址,通过虚函数地址就可以找到子类的函数 //就是说，子类从父类中继承了虚函数指针和虚函数表，当子类中发生重写时，虚函数表会发生变化 cout &lt;&lt; \"sizeof Animal = \" &lt;&lt; sizeof(Animal) &lt;&lt; endl; } int main() { test01(); test02(); return 0; }分别利用普通写法和多态技术实现计算器 //分别利用普通写法和多态技术实现计算器 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //普通写法 class Calculator { public: int getResult(string oper) { if (oper == \"+\") { return m_Num1 + m_Num2; } else if (oper == \"-\") { return m_Num1 - m_Num2; } else if (oper == \"*\") { return m_Num1 * m_Num2; } else if (oper == \"/\") { return (m_Num1 * 1.0) / (m_Num2 * 1.0); } } //操作数1 int m_Num1; //操作数2 int m_Num2; }; void test01() { //创建计算器对象 Calculator c; c.m_Num1 = 10; c.m_Num2 = 10; cout &lt;&lt; c.m_Num1 &lt;&lt; \" + \" &lt;&lt; c.m_Num2 &lt;&lt; \" = \" &lt;&lt; c.getResult(\"+\") &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; \" - \" &lt;&lt; c.m_Num2 &lt;&lt; \" = \" &lt;&lt; c.getResult(\"-\") &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; \" * \" &lt;&lt; c.m_Num2 &lt;&lt; \" = \" &lt;&lt; c.getResult(\"*\") &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; \" / \" &lt;&lt; c.m_Num2 &lt;&lt; \" = \" &lt;&lt; c.getResult(\"/\") &lt;&lt; endl; } //利用多态来实现计算器 //实现计算器抽象类 class AbstractCalculator { public: //要想实现继承,父类中需要有一个虚函数,通过子类去继承重写 virtual int getResult() { return 0; } int m_Num1; int m_Num2; }; //设计一个加法的计算器类,继承上面的抽象类 class AddCalculator : public AbstractCalculator { public: int getResult() { return m_Num1 + m_Num2; } }; //减法计算器类 class SubCalculator : public AbstractCalculator { public: int getResult() { return m_Num1 - m_Num2; } }; //乘法计算器类 class MulCalculator : public AbstractCalculator { public: int getResult() { return m_Num1 * m_Num2; } }; //除法计算器类 class ChuCalculator : public AbstractCalculator { public: int getResult() { return (m_Num1 * 1.0) / (m_Num2 * 1.0); } }; void test02() { //多态使用条件 //父类指针或者引用指向子类对象 //加法运算,可以理解为new(创建了)一个加法的对象,用父类的指针去指向这个对象 AbstractCalculator *abc = new AddCalculator; abc-&gt;m_Num1 = 100; abc-&gt;m_Num2 = 100; //由于创建的是加法运算器,所以调用的肯定是加法对象里的函数,不需要传任何参数 cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; \" + \" &lt;&lt; abc-&gt;m_Num2 &lt;&lt; \" = \" &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; //用完后记得销毁 delete abc; //创建一个减法运算对象 //由于销毁的是指针指向的内存空间,但是指针本身并没有被销毁,而指针本身就是一个父类的对象指针 //所以可以直接指向下一个new(创建)出来的对象,不需要重新定义 abc = new SubCalculator; abc-&gt;m_Num1 = 100; abc-&gt;m_Num2 = 100; //由于创建的是减法运算器,所以调用的肯定是减法对象里的函数,不需要传任何参数 cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; \" - \" &lt;&lt; abc-&gt;m_Num2 &lt;&lt; \" = \" &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; //乘法运算 abc = new MulCalculator; abc-&gt;m_Num1 = 100; abc-&gt;m_Num2 = 100; //由于创建的是乘法运算器,所以调用的肯定是乘法对象里的函数,不需要传任何参数 cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; \" * \" &lt;&lt; abc-&gt;m_Num2 &lt;&lt; \" = \" &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; //除法运算 abc = new ChuCalculator; abc-&gt;m_Num1 = 100; abc-&gt;m_Num2 = 100; //由于创建的是除法运算器,所以调用的肯定是乘法对象里的函数,不需要传任何参数 cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; \" / \" &lt;&lt; abc-&gt;m_Num2 &lt;&lt; \" = \" &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; } int main() { // test01(); test02(); return 0; }纯虚函数 //纯虚函数 //写纯虚函数的目的就是让子类必须重写父类的虚函数,否则就不允许创建对象 #include &lt;iostream&gt; using namespace std; //这个抽象类的意义，类似于开发接口，每个人写的子类都必须遵从父类纯虚函数的定义进行实现 class Base { public: //纯虚函数 //只要有一个纯虚函数,这个类就称为抽象类 //特点:无法实例化对象 //抽象类中的子类,必须要重写父类中的纯虚函数,否则也属于抽象类 virtual void func() = 0; }; class Son : public Base { public: //重写虚函数 virtual void func() { cout &lt;&lt; \"func\" &lt;&lt; endl; }; }; void test01() { //这里会报错,因为抽象类是无法实例化对象的 // Base b; // new Base; //这里也会报错,因为子类如果不重写抽象类的纯虚函数则也无法创建实例化对象 // Son s; Son s2; //拥有纯虚函数的类只能是父类（无法被实例化），且子类必须实现这个函数，否则还是抽象类 //创建一个父类的指针指向子类的对象 Base *base = new Son; //调用子类的函数 base-&gt;func(); //使用多态后想要调用不同对象的函数就new一个再调用 } int main() { test01(); return 0; }多态案例-制作饮品 //多态案例-制作饮品 #include &lt;iostream&gt; using namespace std; //制作类 //父类主要用来存放虚函数模板,让子类去重写这些虚函数 class AbstractDrinking { public: //煮水 //当一个函数不需要写具体实现时可以让其等于0 virtual void Boil() = 0; //冲泡 virtual void Brew() = 0; //倒入杯中 virtual void PourInCup() = 0; //加入辅料 virtual void PutSomething() = 0; //制作函数 void makeDrink() { //先调用煮水 Boil(); //再调用冲泡 Brew(); //然后调用倒入杯中 PourInCup(); //最后调用加入辅料 PutSomething(); } }; //制作咖啡类 class Coffee : public AbstractDrinking { public: //重写父类的虚函数 //煮水 virtual void Boil() { cout &lt;&lt; \"Boil water\" &lt;&lt; endl; } //冲泡 virtual void Brew() { cout &lt;&lt; \"Brew coffee\" &lt;&lt; endl; } //倒入杯中 virtual void PourInCup() { cout &lt;&lt; \"PourInCup\" &lt;&lt; endl; } //加入辅料 virtual void PutSomething() { cout &lt;&lt; \"with sugin and with milk\" &lt;&lt; endl; } }; //制作茶叶类 class Tea : public AbstractDrinking { public: //重写父类的虚函数 //煮水 virtual void Boil() { cout &lt;&lt; \"Boil hot water\" &lt;&lt; endl; } //冲泡 virtual void Brew() { cout &lt;&lt; \"Brew tea\" &lt;&lt; endl; } //倒入杯中 virtual void PourInCup() { cout &lt;&lt; \"PourInCup\" &lt;&lt; endl; } //加入辅料 virtual void PutSomething() { cout &lt;&lt; \"with sugin\" &lt;&lt; endl; } }; //制作函数,传入的参数是父类的指针 void doWork(AbstractDrinking *abs) { //通过父类的指针去调用里面的接口(自己写的函数) ///当父类通过指针去调用里面的接口时,会根据函数名去子类里找对应的函数(因为子类重写了父类的函数) //又因为传入的是子类的实参,所以会根据不同的子类的参数去调用不同的子类的函数 abs-&gt;makeDrink(); //因为子类是从堆区开辟的实参传入,所以在用完了要手动释放掉 //因为是在函数里调用,形参是不同的,所以不管传入的子类是什么都能根据指针释放 delete abs; } void test01() { //制作咖啡 //这里传入的参数是子类的实参,而接受的参数是父类的形参 //等价于:AbstractDrinking *abs = new Coffee //用父类的指针来指向子类的对象 doWork(new Coffee); cout &lt;&lt; \"-----------------\" &lt;&lt; endl; //制作茶叶 //这就是多态的好处,一个函数可以接受不同的对象,不同的对象操作也是不同的 doWork(new Tea); } int main() { test01(); return 0; }虚析构和纯虚析构 //虚析构和纯虚析构 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //动物类 父类,用来存放纯虚函数模板 class Animal { public: //当子类创建对象时会先调用父类构造函数 Animal() { cout &lt;&lt; \"Animal open\" &lt;&lt; endl; } virtual void speak() = 0; //当子类对象销毁前会先调用子类的析构函数,后再调用父类的析构函数 //在前面加上virtual就变成了虚析构函数 //父类虚析构函数就可以解决释放父类指针时只调用父类的析构函数的问题 // virtual ~Animal() // { // cout &lt;&lt; \"~Animal end\" &lt;&lt; endl; // } //纯虚析构,也能解决释放父类指针带来的子类对象释放不干净问题 //注意:如果子类中没有堆区的数据,可以不写虚析构或纯虚析构 virtual ~Animal() = 0; }; //注意,如果父类里写了纯虚析构函数,那么类外就必须要声明,也可以写具体实现 //只要有纯虚析构函数那么这个类就是抽象类 Animal::~Animal() { cout &lt;&lt; \"~Animal end\" &lt;&lt; endl; } //继承父类的纯虚函数 class Cat : public Animal { public: //猫的构造函数 Cat(string name) { cout &lt;&lt; \"Cat open\" &lt;&lt; endl; //从堆区创建一块内存用来存放传入的名字 m_Name = new string(name); } //当继承了父类之后,父类中的纯虚函数必须要重写 virtual void speak() { //从通过指针从堆区拿到存放名字的那块内存 cout &lt;&lt; *m_Name &lt;&lt; \" Cat at speak\" &lt;&lt; endl; } //猫的虚析构函数 //也就是重写了父类的虚析构函数,这样的话在释放父类指针时就会先调用子类的虚析构函数 virtual ~Cat() { //因为每次创建对象都从堆区拿了一块内存去存放名字,所以在析构函数里要释放掉那块内存 if (m_Name != NULL) { cout &lt;&lt; \"~Cat end\" &lt;&lt; endl; delete m_Name; //并且指针也要置为空 m_Name = NULL; } } //创建一个字符串指针用来指向存放“名字”的堆区的那块内存 string *m_Name; }; void test01() { //用父类的指针指向子类对象 //如果类里有构造函数可以在创建的时候就传入构造函数所需要的数据 Animal *animal = new Cat(\"Tom\"); //父类调用自己的纯虚函数,其实也是在调用子类重写后的同名虚函数 animal-&gt;speak(); //注意:释放父类指针时父类指针在析构的时候,不会调用子类中析构函数 //导致子类无法释放堆区的内存,如果有堆区的数据或堆区的属性会出现内存泄漏 delete animal; } int main() { test01(); return 0; }多态案例-电脑组装 //多态案例-电脑组装 #include &lt;iostream&gt; using namespace std; // CPU类，抽象类 class CPU { public: //一个抽象的计算函数,也是纯虚函数 virtual void calculate() = 0; }; // 显卡类,抽象类 class VideoCard { public: //一个抽象的显示函数,也是纯虚函数 virtual void display() = 0; }; // 内存条类,抽象类 class Memory { public: //一个抽象的存储函数,也是纯虚函数 virtual void storage() = 0; }; //电脑类,实类 class Computer { public: //通过一个函数对传入的值用指针接收 Computer(CPU *cpu, VideoCard *vc, Memory *mem) { m_cpu = cpu; m_vc = vc; m_mem = mem; } //提供工作的函数 void work() { //用cpu做计算的操作,其实也就是调用自己原本对象里内置的函数 //因为m_cpu是通过其他类创建出来的,所以可以调用不属于电脑类的函数 m_cpu-&gt;calculate(); //用m_vc做显示操作 m_vc-&gt;display(); //用m_mem做存储操作 m_mem-&gt;storage(); } // delete对象会自动调用类的析构函数 //提供析构函数,释放3个电脑零件 ~Computer() { //释放cpu零件 if (m_cpu != NULL) { delete m_cpu; m_cpu = NULL; } //释放显卡零件 if (m_vc != NULL) { delete m_vc; m_vc = NULL; } //释放内存条零件 if (m_mem != NULL) { delete m_mem; m_mem = NULL; } } private: // CPU的零件指针 CPU *m_cpu; //显卡的零件指针 VideoCard *m_vc; //内存条的零件指针 Memory *m_mem; }; //具体厂商 // Intel类,继承CPU类 class IntelCPU : public CPU { public: //重写父类中的纯虚函数 virtual void calculate() { cout &lt;&lt; \"this is Intel CPU\" &lt;&lt; endl; } }; // Intel类,继承VideCard(显卡)类 class IntelVideCard : public VideoCard { public: //重写父类中的纯虚函数 virtual void display() { cout &lt;&lt; \"this is Intel VideCard display\" &lt;&lt; endl; } }; // Intel类,继承Memory(内存条)类 class IntelMemory : public Memory { public: //重写父类中的纯虚函数 virtual void storage() { cout &lt;&lt; \"this is Intel storage\" &lt;&lt; endl; } }; // Lenovo(联想)厂商 //继承CPU class LenovoCPU : public CPU { public: //重写父类中的纯虚函数 virtual void calculate() { cout &lt;&lt; \"this is Lenovo CPU\" &lt;&lt; endl; } }; // 继承VideCard(显卡)类 class LenovoVideCard : public VideoCard { public: //重写父类中的纯虚函数 virtual void display() { cout &lt;&lt; \"this is Lenovo VideCard display\" &lt;&lt; endl; } }; // 继承Memory(内存条)类 class LenovoMemory : public Memory { public: //重写父类中的纯虚函数 virtual void storage() { cout &lt;&lt; \"this is Lenovo storage\" &lt;&lt; endl; } }; void test01() { //第一台电脑零件,父类指针(CPU)指向子类对象(IntelCPU) CPU *intelCpu = new IntelCPU; VideoCard *intelCard = new IntelVideCard; Memory *intelMem = new IntelMemory; cout &lt;&lt; \"one Computer open\" &lt;&lt; endl; //创建第一台电脑,传入三个零件(三个指针) Computer *Computerl = new Computer(intelCpu, intelCard, intelMem); //调用电脑类下的工作函数,其实也是通过这个函数去调用其他类下的函数 Computerl-&gt;work(); //工作完后释放电脑的指针指向的那块内存 delete Computerl; //因为零件是纯虚函数不能直接创建对象 必须用指针创建 而它们又放在电脑类的构造中 //所以要在电脑类中析构内存释放堆区数据 cout &lt;&lt; \"--------------------\" &lt;&lt; endl; cout &lt;&lt; \"two Computer open\" &lt;&lt; endl; //第二台电脑的组装,直接new新的零件出来传入参数,不使用原来创建的零件 Computer *Computer2 = new Computer(new LenovoCPU, new LenovoVideCard, new LenovoMemory); //调用电脑类下的工作函数,其实也是通过这个函数去调用其他类下的函数 Computer2-&gt;work(); //工作完后释放电脑的指针指向的那块内存 delete Computer2; cout &lt;&lt; \"--------------------\" &lt;&lt; endl; cout &lt;&lt; \"three Computer open\" &lt;&lt; endl; //第三台电脑的组装,直接new新的零件出来传入参数,不使用原来创建的零件,使用不同的零件组合 //用联想的CUP配Inter的显卡 Computer *Computer3 = new Computer(new LenovoCPU, new IntelVideCard, new LenovoMemory); //调用电脑类下的工作函数,其实也是通过这个函数去调用其他类下的函数 Computer3-&gt;work(); //工作完后释放电脑的指针指向的那块内存 delete Computer3; //注意:因为IntelCPU是子类,子类中没有开辟堆区数据,所以不需要写虚析构函数 } int main() { test01(); return 0; } 文件操作 写文件读文件二进制写文件二进制读文件C++文件操作-写文件 // C++文件操作-写文件 #include &lt;iostream&gt; // C++操作文件需要包含的头文件 #include &lt;fstream&gt; using namespace std; void test01() { //操作文件有三种方式 // 1.ofstream 写文件 // 2.ifstream 读文件 // 3.fstream 读写文件 //创建写文件的流对象(ofstream) ofstream ofs; //打开文件,第一个参数是文件的路径,第二个参数是打开的方式 //如果不指定路径那么就会创建在与C++文件同级的文件下 // ios::out是写文件,用写文件的方式打开文件 //有的时候在路径前面要加反斜杠 ofs.open(\"class_02/txt/test.txt\", ios::out); //往文件中写内容,endl在文件当中也可以代表换行 // ofs&lt;&lt;后面跟着的就是要写的内容 ofs &lt;&lt; \"name:zs\" &lt;&lt; endl; ofs &lt;&lt; \"sex:man\" &lt;&lt; endl; ofs &lt;&lt; \"age:18\" &lt;&lt; endl; //写入完成后要关闭文件 ofs.close(); } int main() { //文件类型分为文本文件和二进制文件两种 test01(); return 0; }C++文件操作-读文件 // C++文件操作-读文件 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; using namespace std; void test01() { //创建读文件的流对象 ifstream ifs; //读文件,第一个参数是路径,第二个参数是打开方式 // ios::in 是进行读 ifs.open(\"test.txt\", ios::in); // is_open会判断文件是否打开成功,返回的是一个布尔值 //将它取反后判断 if (!ifs.is_open()) { //文件打开失败 //有时候文件名写错或者路径写错都有可能打开失败 cout &lt;&lt; \"No\" &lt;&lt; endl; return; } //读数据 //第一种方式:将文件的数据全部放入一个字符数组中 // char buf[1024] = {0}; //通过循环将文件中的数据全部都放入数组中,当文件读到头了会返回一个空值终止循环 // while (ifs &gt;&gt; buf) // { // //输出看看是否读入到了数据 // // ifs是按行读取,所以每次循环都会输出一行 // cout &lt;&lt; buf &lt;&lt; endl; // } //第二种方式: // char buf[1024] = {0}; // //在ifs里有一个函数叫getline,是获取行的意思 // //第一个参数是要读入文件的数组名,第二个参数是数组的大小 // while (ifs.getline(buf, sizeof(buf))) // { // cout &lt;&lt; buf &lt;&lt; endl; // } //第三种方式,将文件的数据放入string类型的字符串中 // string buf; // // getline是一个全局函数,用来读取文件到string中 // //第一个参数是基础的输入流,也就是通过读文件的流对象(ifstream)创建出来的对象ifs // //第二个参数是string类型的字符串名 // while (getline(ifs, buf)) // { // //也是通过读取一行到数组中 // cout &lt;&lt; buf &lt;&lt; endl; // } //第四种方式:通过char类型的字符一个一个的读 char c; // ifs里面有一个叫做get的函数,每次只读一个字符,通过!=EOF判断是否读到了文件尾结束循环 while ((c = ifs.get()) != EOF) { //注意:第四种读取方式不能在cout后面加上endl cout &lt;&lt; c; } //读取完成后要关闭文件 ifs.close(); } int main() { test01(); return 0; }C++二进制读文件操作-写文件 // C++二进制读文件操作-写文件 #include &lt;iostream&gt; #include &lt;fstream&gt; using namespace std; // C++二进制的文件操作可以操作像class这样的类对象自定义数据类型到文件中 class Person { public: //姓名 char m_Name[64]; //年龄 int m_Age; }; void test01() { //创建写文件的流对象 // ofstream ofs; //打开文件,ios::out是写文件操作方式,ios::binary是通过二进制的方式写文件 //中间还要加一个|操作符把他们关联起来 // ofs.open(\"person.txt\", ios::out | ios::binary); //可以将上面两步并做一步,在创建对象时就指定好写入的方式,因为ofs这个对象里有一个构造函数 ofstream ofs(\"class_02/txt/person.txt\", ios::out | ios::binary); //写文件 //这是初始化列表的方式，只有公有属性才可以用 Person p = {\"zs\", 18}; // write就是写文件的函数,第一个参数是对象数组的地址,第二个参数是要写入数据的长度 //但是因为直接对对象数组取地址返回的是*Person类型 //而write函数要求的是char类型,所以要强转成char*类型 ofs.write((const char *)&amp;p, sizeof(Person)); //其实是write函数要求的const char * _Str //那个Str是传入文件的首指针，也就是这里为什么要取地址的原因，因为返回的是Person的首指针 //关闭文件 ofs.close(); } int main() { test01(); return 0; }C++二进制读文件操作-读文件 // C++二进制读文件操作-读文件 #include &lt;iostream&gt; #include &lt;fstream&gt; using namespace std; class Person { public: //姓名 char m_Name[64]; //年龄 int m_age; }; void test01() { //创建读文件的流对象 ifstream ifs; // open就是打开的操作,第一个参数是文件路径,第二个参数是读文件的操作 //要加上|符号来使读取的是二进制文件 ifs.open(\"person.txt\", ios::in | ios::binary); //通过is_open函数来判断是否打开成功 if (!ifs.is_open()) { cout &lt;&lt; \"No\" &lt;&lt; endl; return; } //将打开的文件的数据放入到Person对象中 Person p; // read函数就是读取文件的操作,也就是将文件的数据放入到对象中 //第一个参数是要放入数据的对象,返回类型是char*,所以要强转 //第二个参数是要读取的长度,也就是占用的空间 ifs.read((char *)&amp;p, sizeof(Person)); //输出读取到的数据 cout &lt;&lt; \"name:\" &lt;&lt; p.m_Name &lt;&lt; \"\\nage\" &lt;&lt; p.m_age &lt;&lt; endl; //关闭读文件 ifs.close(); } int main() { test01(); return 0; }","categories":[{"name":"C++","slug":"C","permalink":"https://yswm-m.github.io/categories/C/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"学习","slug":"学习","permalink":"https://yswm-m.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"笔记","slug":"笔记","permalink":"https://yswm-m.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"英语","slug":"06-英语","date":"2022-09-15T01:58:00.000Z","updated":"2022-09-27T02:35:37.799Z","comments":true,"path":"posts/6.html","link":"","permalink":"https://yswm-m.github.io/posts/6.html","excerpt":"","text":"文章内容: teacher 老师 i 我 you 你 he 他 she 她 dog 狗 cat 猫 hat 帽子 sandwich 三明治 salad 沙拉 a 一个 am 是 配合i使用 is 是 配合he/she使用 在he/she前面表示疑问 在he/she后面表示是 are 是 配合you使用 在you的前面表示疑问 在you的后面表示是 my 我的 your 你的 their 他们的 they 他们 we 我们 math 数学 chinese 中文 china 中国 yes 是/对 english 英文 good 好 doctor 医生 Oh 噢 friend 朋友 student 学生 taxi 出租车 driver 司机 my friend is a doctor 我的朋友是一个医生 is your friend a taxi driver? 你的朋友是一个出租车司机吗? morning 早上 welcome 欢迎光临 need 需要 new 新 shirt 衬衫 like 喜欢 this 这 bag 包 coat 外套 afternoon 下午 watch 手表 wallet 钱包 jacket 夹克 expensive 贵 nice 不错 black 黑色 green 绿色 yellow 黄色 res 红色 blue 蓝色 this jacket is expensive 这件夹克很贵 one 一 two 二 three 三 four 四 five 五 six 六 seven 七 eight 八 nine 九 ten 十 eleven 十一 twelve 十二 even 偶数 odd number 奇数 dollar 美元 当前面是复数时要加s excuse me 打扰了 how much 多少钱? 在开头表示疑问 how much is this coat 这件外套多少钱? or 还是 this black shirt is ten dollars 这件黑色的衬衫是十美元 and 和 not 不 American 美国人 father 父亲 Is your father a doctor? 你的父亲是一个医生吗? mother 母亲 Her mother is a math teacher 她的母亲是一个数学老师 Is her mother Chinese 她的母亲是中国人吗? sister 姐姐 girlfriend 女朋友 brother 哥哥 boyfriend 男朋友 Her 她的 tall 高 smart 聪明 wife 妻子 husband 丈夫 rich 有钱 his 他的 son 儿子 speak 说 short 短 long 长 and 和 new york 纽约 a little 一点点 How old is your son 你儿子几岁 four years old 四岁 five years old 五岁 daughter 女儿 What is your name 你的名字是什么？ goodbye 再见 school 学校 book 书 pencil 铅笔 ruler 尺子 have 有 school bag 书包 show 看 me 我 stand up 起立 please 请 sit down 坐下 What is missing 什么不见了? close your eyes 闭上你的眼睛 open your eyes 睁开你的眼睛 beautiful 美丽的 too 也 face 脸 eye 眼睛 ear 耳朵 nose 鼻子 mouth 嘴巴 touch your 摸摸你的 look at my eye 看我的眼睛 look at my ear 看我的耳朵 look at my nose 看我的鼻子 look at my mouth 看我的嘴巴 my little face 我的小的脸 this 这是 this is my fase 这是我的脸 tail 尾巴 I have no tail 我没有尾巴 zoo 动物园 tiger 老虎 monkey 猴子 dog 小狗 cat 猫 bird 小鸟 act like a monkey 像一个猴子 it 它 it is a cat 它是一只猫 animals 动物 zero 零 what is this? 这是什么? it is a book 这是一本书 it is a mouth 这是一个嘴巴 what do you see? 你看到什么? I see a dog 我看到一只狗 looking at me 正在看着我 water 水 juice 果汁 drink 喝 less 更少 more 更多 cold 冷 spring 春天 summer 夏天 coffee 咖啡 winter 冬天 fall 秋天 chicken 鸡肉 salad 沙拉 house 房子 black 黑色 hot 热 would you like 您想要 excuse me 打扰了 sandwich 三明治 cheese 芝士 have a nice day 祝您度过愉快的一天 thanks 谢谢 check 账单 menu 菜单 a table for one 一张单人桌 a big table 一张大桌子 small 小 big 大 welcome 欢迎 to 来到 restaurant 餐厅 station 车站 gets 进入 driving 驾驶 job 工作 want 想要 to go 去 where 哪里 do not know 不知道 starts 开始 here 到了 university 大学 hospital 医院 again 再次 apartment 公寓 to drive a taxi 开出租车 difficult 很难的 gets out of 从...里出来 good night 晚安 know 知道 a cup of coffee 一杯咖啡 milk 牛奶 I would like a pizza 我想要一个披萨 with milk 加牛奶 sugar 糖 cheers 干杯 beers 啤酒 exams 考试 today 今天 I have an exam today 我今天有一场考试 easy 容易 difficult 很难 exam 考试 class 课 that is 那是 school 学校 lesson 课(英文) many 很多 questions 问题 important 重要 perfect 完美 vacation 假期 ready 准备 dress 连衣裙 clothes 衣服 英语的语法：人物是主语要放在前面，时间和地点是宾语要放在最后面 an 一场 park 公园 eating 吃东西 want 想要 every day 每天 to walk 散步 toys 玩具 food 食物 can 可以 eat 吃 burger 汉堡包 where 在哪里 fries 薯条 sees 看到 under 在下面 why 为什么 key 钥匙 cell phone 手机 thank you very much 非常感谢 you're welcome 不客气 chicken 鸡肉 pants 裤子 shoe 鞋子 one hundred dollars 一百美元 these 这些 less 更少 camera 照相 car 车 really 真的 too 太 too short 太短 winter 冬天 beers 啤酒 shirt 衬衫 computer 电脑 small 小 dress 连衣裙 orange 橙色 beautiful 漂亮的 favorite 最喜欢的 color 颜色 old 旧 i like these shoes very much 我非常喜欢这些鞋子 doctor 医生 happy 开心 family 家庭 friends 朋友们 best 最好的 husband 丈夫 here 这里 person 人 young 年轻 dad 爸爸 mom 妈妈 japanese 日语 french 法语 korean 韩语 bad 不好 New York 纽约 less 更少 winter 冬天 drink 喝 japan 日本 france 法国 country 国家 Do you live in London? 你们住在伦敦吗? juice 果汁 spanish 西班牙语 London 伦敦 language 语言 but 但是 speak 说 America 美国 summer 夏天 sorry 抱歉 no problem 没关系 know 知道 I don it know 我不知道 Do you no his phone number? 你知道他的电话号码吗? address 地址 Do you know his address? 你知道他的地址吗? I don it have her phone number 我没有她的电话号码 email 电子邮件 pet 宠物 our 我们的 understand 明白 hospital 医院 work 工作 job 工作 together 一起 fall 秋天 office 办公室 bank 银行 meetings 会议 a lot of 许多 university 大学 teach 教 at work 在工作 cold 冷 tonight 今天晚上 tuesday 周二 monday 周一 sunday 周日 are you busy on sunday 你周日很忙吗? who is that young man? 那个年轻男人是谁? sports 运动 How are you doing? 你好吗? wednesday 周三 can 可以/能 can you see the clock on the wall？你能看到在墙上的时钟吗? clock 时钟 wall 墙 see 看到 hey 嘿 I need to buy new winter boots 我需要买新的冬天的靴子 shorter 更矮 shortest 最矮 tallest 最高 is Ben the tallest boy in the room? 本是房间里最高的男孩吗? favorite 最喜欢的 subject 科目 where 哪里 desk 书桌 second 第二份 internet 网络 city 城市 use 用 on 在(日期) in 在(城市) at 在(地点) rice 米饭 apple 苹果 breakfast 早饭 eat 吃 every day 每天 orange 橙子 bread 面包 noodles 面条 some 一些 want 想要 likes 喜欢(在她/他时) egg 鸡蛋 never 从来不 drinks 喝(在他/她时) salad 沙拉 soup 汤 vegetables 蔬菜 fruit 水果 语法：在he/she后面会给动词加上s，drink会变成drinks，work会变成works，如果动词以o结尾的话就加上es，如：go变成goes，如果复数动词以s，x，ch，sh，o结尾的话同样要加上es，如：dress由单数变成复数dresses，watch由单数变成复数watches，box由单数变成复数boxes，tomato由单数变成复数tomatoes 当提到的名词是复数或者是某类事物的统称时(如牛奶品牌)就不需要在名词前面加上a/an了，如：he likes tomatoes，she needs some milk，Duo likes apple juice check 检查 jeans 牛仔裤 fawn 淡黄色的 this bag is too small 这个包太小 Is this book ten dollars? 这本书是十美元吗? thank you very much 非常感谢 we do not speak korean 我们不说韩语 they do not speak French 我们不说法语 I do not live in Korea 我不住在韩国 little 一点 country 国家 bad 不好 pets 宠物 help 帮助 math 数学 apartment 公寓 goes to 去 what 什么 tomorrow 明天 well 嗯 video game 电子游戏 study 学习 can 可以 backpack 背包 Great 很好 it is at 它是在 how can i help you 怎么样可以帮助你? get 把...拿来 get my book 把我的书拿来 play 玩 at 在 in 在 bird 小鸟 monkey 猴子 tiger 老虎 dolphin 海鲀 Nice to meet you 很高兴认识你! what do you do,Ben? 你是做什么工作的,本? I work at a hospital 我在一家医院工作 Do you work together 你们在一起工作吗?","categories":[{"name":"学习","slug":"学习","permalink":"https://yswm-m.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"英语","slug":"英语","permalink":"https://yswm-m.github.io/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"小学数学4~6年级","slug":"05-小学数学4~6年级","date":"2022-09-15T01:08:00.000Z","updated":"2022-10-17T01:23:01.402Z","comments":true,"path":"posts/5.html","link":"","permalink":"https://yswm-m.github.io/posts/5.html","excerpt":"","text":"文章内容: 10个1是10 10个10是100 10个100是1000 10个1000是10000 10个10000是10万 10个10万是100万 10个100万是1千万 10个1千万是1亿 10个1亿是1兆 个级数位包括个位,十位,百位,千位,万位 从个位开始数起第九位是亿位 个位,十位,百位,千位,万位...都是数位,不是计数单位,去掉了他们后面的'位'字才是计数单位 两个相邻的计数单位之间的间隔是10 6407000读作6百四十万7千 技巧：从右边数起,在第四位和第五位之间画个分割线,分割线左边的就是万以上的,右边的就是万以下的,末位的零是不读的 四十万零四十写作400040：这里十万位和十位之间隔了千位和百位,没有数所以要用零来补上,因为是两个位所以要补两个零 九千零二十万零三写作90200003 某个位数上没有数要用零来补位 自然数有无数个，0是最小自然数，没有最大的自然数 相邻的两个自然数相差1 每两个相邻的计数单位之间的进率是十 数表示10以上的数,10以下的数,0~9是数字不是数 一个数省略万位后尾数是10万，那么这个数最大是104999,最小是95000 线段：有两个端点,是直的 射线：有一个端点,长度是无限的 过一点可以画无数条射线 直线：没有端点,可以向两端无限延伸 过一点也可以画出无数条直线 过两点只能画一条直线 由一个点引出两条射线所组成的图形叫做角 五个端点可以组成10条线段 一个端点和五条射线可以组成10个角 4+3+2+1=10 角的大小跟边的长短没有关系,跟角叉开的角度有关 当两条边在同一条直线上时那么就是平角，平角是180度 平角与直线的区别就是平角的中间是有一个顶点的 平角不等于直线,直线也不等于平角 当平角的两条边转一圈完全重合在一起时那么就是周角，周角=360度 周角不等于射线，射线也不等于周角 小于90度时叫做锐角，等于90度叫做直角，大于90度并且小于180度的叫做钝角 1个周角=2个平角=4个直角 问：在一个直线上有两个角,角1=145度,角2=？ 答:180度-145度=35度 两个直线相交，相对的角相等 一个时钟的角度是一个周角是360度，求其中的一个时间的角度是30度，因为360/12=30 1颗树16元,买3颗送1颗，问一次买3颗，每颗便宜多少钱？ 答：16/4=4（元）一次买3颗，送的一颗可以看作是赚的，也就是赚了一颗的16元钱，把赚的16块钱分给4棵，也就是4块钱每颗，每颗便宜了4块钱 路程=速度*时间 速度=路程/时间 时间=路程/速度 平均速度=总路程/总时间 在同一平面内，不相交的两条直线叫做平行线 两条直线相交成直角则叫做垂直 一组对边平行，另一组对边不平行叫做平行四边形 ?96/82 要求商是一位数 三位数/两位数的商是一位数，那么三位数的前两位数不能大于除数 也就是说第一个位置最多只能填7，79&lt;82 ?76/27 要求商是两位数 三位数/两位数要求商是两位数，那么三位数的前两位数就必须大于等于除数 也就是说第一个位置可以填2~9之间任意一个数字 0乘以或除以任何数都等于0，0不能做除数 0.009米 = 9毫米 0.09米 = 90毫米 0.9米 = 90毫米 三角形的特性：任意两边的和大于第三边，注意是大于不是大于等于 在一个三角形里最多有3个锐角，最少有2个锐角 在一个三角形最多有一个直角，最多有一个钝角 只有两条边相等就是等腰三角形，三条边都相等就是等边三角形 三条边都不相等叫做其他三角形 三角形的内角和是180度 求三角形任意一个角的度数：先把两个角的度数加起来，再用内角和减去这两个角的度数，就可以求出第三个角的度数 a*b-a*c=a*（b-c）如：47*102-94=47*102-47*2=47*(102-2) a*b+a*c=a*（b+c）如：13*25+27*25=25*(13+27) 0.25*4.78*4=(0.25*4)*4.78 0.65*201=0.65*(200+1)=0.65*200+0.65*1=130+0.65=130.65 0.034*0.5*0.6=0.034*(0.5*0.6)=0.034*0.3=0.0102 22.4/4=224/4/10=56/10=5.6 S(面积) = a*a=a^2 C(周长) =a*4 = 4a 2a=a+a a^2=a*a a*x=ax x*x=x^2 4*b*5=(4*5)*b=20b 6x+5x=(6+5)x=11x 7y-3y-y=(7-3-1)y=3y a*a*a=a^3 长方形的周长=2a+2b=2(a+b) 等式不一定是方程，但是方程一定是等式 a+b=4b，那么a+b-b=4b-b，同质同量 等式两边同时加或减同一个数，等式不变 等式两边同时乘或除以同一个数(0除外)，等式不变 x+3=9 = x+3-3=9-3，x=6 3x/3=18 = 18/3，x=6 3.7-x = 1.7 解：x = 3.7-1.7 x = 2 1.8/1.2 = 1.5 1428-5x = 3 解：5x = 1428-3 5x = 1425 x = 285 (x+2.8)*2 = 10.4 解：(x+2.8) = 10.4/2 x+2.8 = 5.2 x = 2.4 x+2.4x = 5.1 解：将x看成1x：1x+2.4x = 5.1 那么可用乘法分配律得出：(1+2.4)x = 5.1 3.4x = 5.1 3.4x/3.4 = 5.1/3.4 x = 1.5 8x-3x = 105 解：(8-3)x = 105 5x = 105 x = 21 鸡兔同笼： 鸡有2条腿，兔有4条腿，应为不知道他们有多少只就设为x只，2x+4x=48 解：6x = 48 x = 8 每一个平行四边形都可以通过割补得到一个长方形，所以平行四边形的面积 = 割补后的长方形面积 割补后长方形的宽就等于原来平行四边形的高，长方形的长就等于原来平行四边形的底 那么平行四边形的面积就等于底*高 将一个正方形拉长变成平行四边形，底不变，那么平行四边形面积等于正方形的面积 将一个长方形拉长变成平行四边形，底不变，高变矮了，那么平行四边形的面积也会相应的变小 求一个大的平行四边形里的小平行四边形，将小的平行四边形的左边的三角形移到右边三角形的右边变成另一个平行四边形，那么会发现和小的平行四边形相等，那么小的平行四边形的面积就等于大的平行四边形的面积/2 平行四边形/2 = 两个三角形，平行四边形的面积/2 = 三角形的面积，平行四边形的面积 = 底*高，三角形的面积 = 底*高/2，用三角形的底*高得到的是平行四边形的面积 已知三角形的面积176m^2，底为22m，求三角形的高为多少米？ 答：一个三角形的面积等于一个平行四边形的面积/2，那么三角形的高就等于平行四边形的高，那么三角形的高就等于：176*2/22 = 352/22 = 16m 1米=10分米，1平方米等于100平方分米 两个完全一样的梯形可拼成一个平行四边形，那么一个平行四边形的面积/2 = 梯形的面积，平行四边形的底 = 梯形的(上底+下底)，平行四边形的面积 = 底*高，梯形的面积 = (上底+下底)*高/2，(上底+下底)*高得到的是平行四边形的面积 求组合图形的面积可以用三种方法：分割、割补、变形 分割： 将两个组合图形分割成一个，再将最后求出的面积乘以2 割补： 将一个大的组合图形看成一个完整的图形，求出完整的图形面积后，再将空的部分的面积求出，用完整的图形面积减去空的部分的面积，最后得到的就是原来大的组合图形的面积 变形： 将组合图形中除了完整的图形之外，多余的部分看成另一个完整的图形，比如说一个大三角形由两个小三角形组成，而两个小三角形又可以拼成一个平行四边形，那么求出这个平行四边形的面积再求出组合图形剩余的图形面积，加起来得到的就是整个大的组合图形的面积。 概率： 抛一个硬币，正面和反面的概率是一样的，都是1/2，抛一个骰子，得到1~6每个数字的概率是一样的，都是1/6，算上所有的可能性，如果每个人获胜的概率是一样的，那么游戏就是公平的，否则就是不公平的。 中位数： 当出现极大或极小的数据，平均数不能代表一般水平，因为可能某一个人的水平特别高，但是其他人并不都是那么高，就会被那个水平高的人拉高平均数，这种情况下要用中位数来代表一般水平。 求中位数之前要先排序，当最后剩下的数是两个数时可以把两个数加起来除以2求出它们的平均数。 平均数：采集所有数据的信息，某一个数据发送变化它也会跟着变化，容易受到极端数据的影响。 中位数：不易受到极端数据的影响，采集的数据信息不全面，需要排序。 当平均数大于中位数时，代表数据中出现了极大的数据，当平均数小于中位数时，代表数据中出现了极小的数据。 身份证号： 身份证号一共18位，前6位代表地域，第7~14位代表出生年月日，第15~17位代表顺序码，如果是单数则是男生，双数则是女生，最后一位18位是校验码，如果是X则是罗马数字的十。 从省缩小到市再缩小到区，再通过年月日进一步缩小范围，最后通过性别和校验码确定具体的人。 往往给一个学校的学生学号进行编码，在年级那里最好填入学的年份，这样每次年级变更就不用换新的学号。 等比数列-最短时间： 已知一个班上有15个人，老师要把一个消息通知这15个人，每通知一个人就要消耗1分钟，那么怎样通知最快，所花费的时间最少？ 第1种方法：一个一个的通知，需要15分钟 第2种方法：将15个人分成3组，每组5个人，由老师通知其中一个人，再由那个人去通知其他4个人，老师通知3组需要3分钟，三组中的其中一个人通知其他4个人需要4分钟，那么一共需要7分钟。 第3种方法：老师先通知1人，再由那个人和老师两个人一起去通知另外两个人，另外通知的两个人再和原来的两个人一起四个人去通知另外4个人，这样成倍的增长下去，只需要4分钟就能通知完15个人。 而如果一直这样增长下去就可以发现： 第几分钟： 1 2 3 4 5 6... n 每分钟新通知的人数：1 2 4 8 16 32... 每分钟通知的总人数：2 4 8 16 32 64... 2^n 每分钟实际通知人数：1 3 7 15 31 63... 2^n-1 每分钟通知的总人数是上一个通知的总人数的2次方。 每分钟实际通知的人数除去老师是通知的总人数减一，也就是2的次方减一。 每分钟新通知的人数是上一个通知的总人数。 那么假设有n人，第n分钟通知的总人数就是2^n次方，每分钟实际通知的人数就是2^n-1。这就是化繁为简的过程。 因数： 一个数的因数的个数是有限的，最小的因数是1，最大的因数是它的本身。 除开1和它本身，如果有数能够通过乘法得到那个数，那么乘法中相乘的两个数就是那个数的因数，例如：2*3 = 6，那么2和3就是6的因数。反过来想也就是：能把最大的数字整除的叫做因数。 质数： 因数当中除了1和它本身之外无法被其它任何数整除的数就叫质数。1既不是质数也不是合数。 合数： 因数当中除了1和它本身之外还含有其它因数的数叫做合数。 倍数: 一个数的倍数的个数是无限的，最小的倍数是它本身，没有最大的倍数 0不参与倍数、因数的计算 长方体： 长方体有6个面，每个面都是长方形（特殊情况下可能有两个面是正方形）相对的面面积相等（前面和后面相等，上面和下面相等，左面和右面相等）。 棱：长方体有12条棱，相对的棱长度相等，其中长的棱有4条，宽的棱有4条，高的棱有4条。 顶点：长方体有8个顶点。 从同一顶点出发引出的三条棱叫做长方体的长宽高。 求一个长方体的周长，可以将长方体的三条棱（长宽高）加起来乘以4。 正方体： 正方体有6个面，6个面都是正方体，而且6个面都相等 棱：正方体有12条棱，12条棱的长度都相等。 顶点：正方体有8个顶点。 正方体可以看成是长，宽高都相等的特殊长方体。 正方体的长宽高都是相等的，都是同样长度的棱。 一个棱长为1厘米的小正方体如果要摆成一个稍大一些的正方体，至少需要8个一模一样的小正方体。 正方体的表面积：棱长*棱长*6，因为正方体有6个面，每个面都是相等的。 长方体的表面积：(长*宽+长*高+宽*高)*2，因为需要单独求出上下、前后、左右，6个面的面积。 体积单位：立方米，立方分米，立方厘米 长方体的体积 = 长*宽*高 正方体的体积 = 棱长*棱长*棱长 长方体或正方体的体积也可以用：底面积*高来计算 体积之间的进率是1000，1立方米 = 1000立方分米，1立方分米 = 1000立方厘米 面积之间的进率是100，1平方米 = 100平方分米 容积： 一个物体能装下多少体积的物品，那么那个物体就有多大的容积。 容积的单位是升(L)和毫升(ml) 1L = 1立法分米(dm^3) 1ml = 1立法厘米(cm^3) 分数： 把一个物体或一些物体，平均分成若干份，表示这样的一份或几份的数叫做分数 将12个物体看成一个整体，1/4占12个物体里的3个，因为12/3 = 4，所以1/4就代表3个物体。 一个分数的分数单位就是那个分数的几分之一，比如3/4的分数单位是1/4。 一个蛋糕平均分给3个人，每人分得：1/3(个) 3个蛋糕平均分给4个人，每人分得：3/4(个) 有7只鸡和10只鸭，鸡的只数是鸭的几分之几？ 化简也就是：7只是10只的几分之几？ 答：7/10 9cm = 9/10 dm 30cm = 30/100 m 53ml = 53/1000 L 1的3/4 = 3的1/4 因为1的3/4表示将1平均分成4份，取其中的3份就是0.75 而3的1/4表示将3平均分成4份，取其中的1份也是0.75 也可以将其转化为乘法：1的4分之3代表1乘4分之3 = 3/4，分子相乘，分母不变。 3的4分之1代表3乘4分之1 = 3/4，分子相乘，分母不变。 3千克的1/5 = 1千克的3/5 因为3千克的5分之1表示把3千克平均分成5份，取其中的1份就是600克 而1千克的5分之3表示把1千克平均分成5份，每份200克，取其中的3份也是600克。 1米的5/8 = 5米的1/8 凡是分子小于分母的分数就叫做真分数，真分数&lt;1 凡是分子 = 分母或者分子&gt;分母的数就叫做假分数 关于假分数的定义，如果把2个蛋糕平均分成4份，用4做单位，取完第一个蛋糕后就已经是4/4了，再取第二个蛋糕其中的3份，和起来并不是7/8，而是7/4，因为是4做单位，那么7/4就大于单位1的4/4，这就是假分数了。 带分数： 将两个苹果分成一个半，也就是一个苹果不分，另一个苹果分成1/2，那么一个苹果和那1/2个苹果和起来就是：1又2分之1，其中的1是整个苹果，2分之1是半个苹果。 假分数可以简写成带分数的形式，比如：7/3 = 2又1/3，其中2代表两个3/3和起来，也就是6/3，1/3代表7/3 - 6/3后余下的部分。 商不变的性质： 被除数和除数同时乘或除相同的数(0除外)，商不变，比如：45/15 = 3，那么45000/15000 = 3，4.5/1.5 = 3，0.45/0.15 = 3 应用到分数上：1/2 = 2/4 = 4/8，其中1/2到2/4之间分子和分母都乘了2，分子和分母同时乘或除相同的数，大小不变，这样推下去,50/100与1/2也是相等的，10/24与5/12也是相等，因为它们都同时除了2 3/4 = 6/8 = 9/12，因为3/4到9/12之间分子和分母同时乘了3 可以利用这个方法来比大小：2/8 = 1/4，分子和分母之间同时除2，而1/4&gt;1/5，所以2/8&gt;1/5，同样3/12也可以化简成1/4，分子和分母同时除3，所以3/12&gt;1/5 最大公因数： 两个数的公因数中最大的那个数就是最大公因数，因数是除了1和它本身之外能够整除它的数，而公因数是能够同时整除两个数的因数。 比如：12和16的公因数有：1，3，4。而4就是它们的最大公因数。 可以利用分解质因数求最大公因数，比如： 18 = 2*3*3 27 = 3*3*3 18和27的最大公因数就应该包含18和27里面的相同质因数的乘积，所以找其中相同质因数的部分，也就是3*3，那么9就是它们的最大公因数 用短除法的方法： 同时用公因数中最小的质因数开始除18和27，得到的数再用公因数中最小的质因数去除，最后除得两个数是质数就不再除了，然后将所有的公因数乘起来得到的就是最大公因数。比如： 18和27同时除最小的质因数3，得到6和9，然后6和9再同时除它们之间的最小质因数3，得到2和3，因为2和3是互质数，所以不再除，那么在这过程中得到的两个最小质因数（3，3）乘起来就是18和27的最大公因数9。 如果两个数之间有倍数关系，那么小的那个数就是两个数的最大公因数，比如：4和8的最大公因数就是4。 两个数如果都是质数，那么它们的最大公因数都为1，比如：1和7的最大公因数是1，因为1和7互为质数，也可以称它们为互质数（注意互质数也不一定是两个数都为质数才是互质数，比如：5和8为互质数，但是8并不是质数，之所以它们是互质数是因为5和8的最小公因数为1）。 如果两个数是相邻的自然数，那么它们的最大公因数也都为1，比如：15和16的最大公因数是1，因为它们是两个相邻的自然数。 75%和3/4比大小，可以将75%变成75/100，将75/100的分子和分母同时除25得到3/4，所以75% = 3/4 如果分数之间的分子和分母的最大公因数是1，那么它们就是最简分数，比如：4/5是最简分数，因为4和5是两个相邻的自然数，所以它们的最大公因数为1 利用辗转相除法将不是最简分数的分数变成最简分数： 将24/30取得它们的最大公因数为 6，分子、分母同时除以 6 即可得到最简分数4/5，那么24/30就 与4/5相等，这个过程叫做约分。 如果分数的分子和分母是相邻的或者互为质数，那么这个分数就是最简分数，比如15/16是最简分数，因为15和16相邻。 如果分子和分母是倍数关系，那么就可以直接用分母除分子进行约分，比如：11/44 = 1/4 12/16和9/12进行比较，可以将12/16同时除最大公因数4化简成3/4，再将9/12同时除最大公因数3化简成3/4，所以12/16 = 9/12 最小公倍数： 所谓公倍数就是两个数都有的倍数，比如： 3的倍数有：3 6 9 12 15 18 21 14... 2的倍数有：2 4 6 8 10 12 14 16 18... 其中2和3的公倍数是：6 12 18 因为公倍数是无限的，所以没有最大公倍数，但是有最小公倍数，所以上面2和3的最小公倍数是6 可以利用分解质因数的方法： 两个数相乘除以两个数的最大公因数等于两个数的最小公倍数。 如果两个数之间是倍数的关系那么较大的那个数就是两个数的最小公倍数，如：3和6的最小公倍数是6，因为3和6是倍数关系 如果两个数互为质数，那么它们的最小公倍数就是它们两个的乘积，比如：5和8的最小公倍数是40，因为5和8互为质数（两个数的最大公因数为1） 通分： 分子相同看分母 分母大的反而小，分母相同，分子大的大。分子相同，分母大的小。比如：3/8&lt;3/11，因为3/8的分母小于3/11的分母 如果两个分数的分子和分母都不相同，那么可以用通分来比大小，如： 2/5和1/4，求出它们两个分数的分母的最小公倍数，将它们两个的分母都变成最小公倍数，在这过程中分子也跟着变化，最后得到的就是相同分母的两个分数，5和4的最小公倍数是20，那么5和4都变为20，5在变为20的过程中乘了4，那么2/5的分子2也要跟着乘4，变为8/20，而4在变为20的过程中乘了5，所以1/4的分子1也要乘5，变成5/20，那么8/20&gt;5/20 通分子： 分子和分母同时乘相同的数，分子相同，分母变化，就可以利用分子来比大小，而在两个通分子之间的数就是通分子数，如：1/6和1/5，分子和分母同时乘2，变成2/12和2/10，而在它们之间有一个2/11 小数转分数： 0.3 = 3/10，0.03 = 3/100 分数转小数： 9/10 = 0.9 0.3和3/4比较，将0.3转成3/10，同分子比较，3/4大 25分种和1/4小时进行比较，将1/4小时看成60平均分成4份，取其中的1份，也就是60/4 = 15，而25&gt;15，所以25分钟&gt;1/4小时 3/7-3/7 = 0 1/4+3/10 = 5/20+6/20 = 11/20，将1/4和3/10通分，求出4和10的最小公倍数20，将1/4分别乘5转化5/20，将3/10分别乘2转化成6/20，相加得到11/20 如果两个分数之间为互质数或相邻的两个数，它们进行运算的时候可以直接通过相乘来通分，如：1/2+1/3 = 5/6，直接用2*3得出同分母6，再将通分后的分子加起来，变成3/6+2/6 = 5/6 多项分数相加减： 1/2+1/6+1/12+1/20+1/30+1/42+1/56+1/72+1/90 运用乘法交换律可得： (1-1/2)+(1/2-1/3)+(1/3-1/4)+(1/4-1/5)+(1/5-1/6)+(1/6-1/7)+(1/9-1/10) 将括号打开得到： 1-1/2+1/2-1/3+1/3-1/4+1/4-1/5+1/5-1/6+1/6-1/7+1/9-1/10 通过相同分数两两抵消得到： 1-1/10 = 9/10 众数： 在一组数据中出现次数最多的数就叫做众数，众数可能出现多个。 中位数可以通过二分直接求，比如有21个数，那么这21个数里面的中位数就是第11个数，因为21/2 = 10.5，四舍五入就是第11个数 如果是偶数则中位数是二分之后的中间两个数的中位数，如：40个数，求中位数则是第20和第21个数，因为40/2 = 20，又因为是偶数，所以是第20和第21个数的平均数。 砝码称重： 假设有9个砝码，其中1个砝码是次品，怎样用最少的次数找到那9个砝码中的次品，已知次品较轻？ 答：将9个砝码平均分成3份（3,3,3），先称其中的两份(3,3)，如果相等则剩下的3个里面有次品，再将有次品的3个平均分成3份（1,1,1），先称其中的两份(1,1)，如果相等则剩下的那个就是次品，如果不相等则轻的那个就是次品，如果先称的两份不相等(3,3)，则继续用后面的方法称轻的那3份，这样最坏只需要称2次就能得到次品。 像这样两个两个称重最好是能将物品分成3份，就能得到最少次数，如： 12个物品找其中一个次品，可以将12分成3份(4,4,4)，先称其中的两份(4,4)，如果相等则剩下的4个里面有次品，再将剩下的4个物品分成3份(1,1,2)，先称前面相等的部分(1,1)，如果相等则表示次品在剩下的2个里面，再将剩下的2个物品分成两份(1,1)，较轻的那个就是次品，如果前面(4,4)的比较有轻的，则继续用后面的方法称轻的那4个，这样最坏只需要称3次就能得到次品。 像这样把物品平均分成3份找，可以用规律计算： 在2~3个物品之间找，需要1次 在4~9个物品之间找，需要2次 在10~27个物品之间找，需要3次 在28~81个物品之间找，需要4次 其中的规律就是3的次方，在2~3个物品之间找是3的1次方，在4~9个物品之间找是3的2次方，在10~27物品之间找是3的3次方，在28~81个物品之间找是3的4次方，其中3的多少次方就是最少需要找多少次，而找的物品范围就是3的上一个次方+1到下一个次方之间的数，不会超过3的次方。 位置： 先写列数再写行数，比如2行3列就可以用(3,2)表示，前面的数相同表示在同一列，后面的数相同表示在同一行。 分数乘整数： 多个分数的加法都是分母不变，分子相加，那么乘法也可以写成分母不变，分子相乘，比如： 3个3/10用加法写成：3/10+3/10+3/10 = 9/10 如果用乘法可以写成：3/10*3 = 9/10 约分可以写的更加简便： 当分数和整数相乘的时候可以在乘之前就对分数的分母和整数进行约分，约完之后再乘得到的就是约分后的数，如： 3/8*6，8和6先约分，得到4和3，然后再乘得到9/4 分数乘分数： 分母乘分母，分子乘分子 交叉约分： 分数乘分数可以进行交叉约分，在乘之前用其中一个分数的分子和另一个分数的分母进行约分，另一个分数的分子也和前一个分数的分母进行约分，最后将约分完的数乘起来得到的就是乘之后约分的数，如： 3/10*2/3 = 将3和3进行约分得到1和1，将10和2进行约分得到5和1，最后得到的就是1/5*1/1 = 1/5，规则就是分子和分母约 整数也可以这样约分，将整数变成分数，5变成5/1，用3/10*5/1，10和5约分变成2和1，3和1变成3，乘起来得到：3/2 分数的简便运算： 乘法交换律：a*b = b*a 乘法结合律：(a*b)*c = a*(b*c) 乘法分配律：(a+b)*c = a*c+b*c 比如：87*3/86可以用数学思维化成：(86+1)*3/86，利用乘法分配律得到：86*3/86+1*3/86 = 3又3/86 解决问题： 求一个数的几分之几是多少用乘法，如： 求2500的2/5是多少，列算式得：2500*2/5 = 1000 解决问题的核心就是找准单位一： 1、小红的课外书比小明多1/3。 这里是把小明看作单位一，也就是说将小明的课外书平均分成3份，小红的比小明的还多一份，那么小红的课外书就是4/3份 2、甲的3/4相当于乙。 这里是把甲看作单位一，也就是说将甲平均分成4份，其中的3份相当于乙 分数既可以表示分率又可以表示一个具体的数量，如果分数的后面带了单位那么就是一个具体的数量，就不能直接取分率，如： 一根100米长的绳子，用去3/4米后，还剩多少米？ 100-3/4 = 99又1/4米，因为3/4后面带了单位米字，所以不能直接取分率，而是把它当成一个具体的数量去运算。 倒数： 乘积为1的两个数互为倒数，比如：2/3*3/2 = 1，因为它们可以互相约分 整数也有倒数，比如：3化成分数就是3/1，那么3的倒数是1/3 小数也有倒数，比如：0.25化成分数是1/4，它的倒数是4/1，那么0.25的倒数就是4，用0.25*4就等于1 1也有倒数，1的倒数就是它本身 0没有倒数，因为0不能做分母 除以一个数等于乘以这个除数的倒数 可以利用这个规律快速的求某个数乘多少等于1，比如18乘1/18 = 1 一个真分数与它的倒数的和是5.2，这个真分数是多少？ 将5.2转成分数 = 5又1/5，那么这个真分数就是1/5，因为真分数&lt;1，而1/5的倒数正好是5 注意：真分数的倒数一定比真分数要大，因为真分数&lt;1，而真分数的倒数一定大于1。 分数除法： 已知：1/10*3 = 3/10，那么3/10除3 = 1/10，分子相除，分母不变 如果是分数除分数那么：3/10除1/10 = 3，分子和分母都要除 把一张纸的4/5平均分成2份，每份是这张纸的几分之几？ 4/5除2 = 2/5，把一张纸看成单位1，一张纸的4/5就是将纸分成5份，取其中的4份，而这4份再平均分成2份每份就是2份，而这两份占整张纸的2/5 也可以简化算式为：4/5除2 = 4/5*1/2 = 2/5，除一个数就等于乘它的倒数 小明2/3小时走了2千米，小红5/12小时走了5/6千米，谁走的快些? 答：速度 = 路线/时间，除一个数等于乘它的倒数 列算式：2除2/3 = 2乘3/2，约分得3 5/6除5/12 = 5/6乘12/5，约分得2，所以是小红走的快些 一个数除以分数，就等于乘以这个数的倒数 1不变2变，前面的数不变，后面的数和符号变 为了计算简便，在一个算式加了括号之后，如果括号前面是乘号那么就不影响计算结果，如：5/7除1/8除8改为：5/7乘8除8 = 5/7乘(8除8) = 5/7 7/12乘5/7+5/12除7/5 = 7/12乘5/7+5/12乘5/7，利用乘法交换律得到：(7/12+5/12)乘5/7 = 5/7 阅读理解： 20米的2/5是56米的几分之几？ 20乘2/5得8，求8米是56米的几分之几，用8除56 = 8乘1/56，约分得1/7 几吨的3/4比8吨还多1吨？ (8+1)除3/4 = 12，一个因数等于积除另一个因数 计算：3/8乘1/2除3/8乘1/2 = 3/8除3/8乘1/2乘1/2 = 1乘1/2乘1/2 = 1/4，注意这里不能用乘法分配律，因为两个乘法之间是除号不是加号或减号 解方程： 小明体内的水分是28kg，已知成人体内的水分约占成人体重的4/5，而小明的体重是爸爸的7/15，问：爸爸的体重是多少kg? 设：小明的体重为x kg 列方程为：4/5x = 28 x = 28除4/5 x = 35(kg) 再设：爸爸的体重为x kg 列方程为：7/15x = 35 x = 35除7/15 x = 75(kg) 当单位一没有告诉，则用未知数x列方程的方式来做，当单位一告诉了则用正常的加减乘除来做。 美术组有25人，美术组比数学组多1/4，数学组有多少人？ 设：数学组有x人 列方程为： x+1/4x = 25 将单独的x设为1: (1+1/4)x = 25 5/4x = 25 x = 20(人) 注意：方程的X前面本来就有一个1，只是这个1省略了。 国产轿车比原价降低了1/8，现价是原价的几分之几? 设：原价为x 列方程为：x-1/8x = 现价 (1-1/8)x = 现价 7/8x = 现价 10克盐溶入100克水中，盐占盐水的1/11，因为盐水里面既有盐又有水，所以盐水是110克。 比的基本性质： 已知一个长方形长为15，宽为10，长是宽的几倍？ 15除10 = 15/10 = 3/2，这里的3/2可以说成长和宽的比 长:宽，3:2 宽是长的几分之几？ 10除15 = 10/15 = 2/3，说成比就是宽和长的比是 2:3 比可以直接换算成分数，也可以看作除法的另一种写法，所得的商叫做比值，比的前一个数叫做前项(相当于被除数等于分子)，比的后一个数叫做后项(相当于除数等于分母) 那么比也同样可以运用分数的基本性质：比的前项和后项同时乘或除一个相同的数(0除外)，比值不变。 最简整数比： 分数之间也有比，有时候需要将分数比化简成整数比： 1/6:2/9，求出分母6和9的最小公倍数，然后将它们的分数同时乘以最小公倍数18，约分后就可以化简成整数比：(1/6*18):(2/9*18) = 3:4，3和4是互质数，所以不需要再约分 小数也有比： 0.75:2，将小数化成整数，因为比的前项和后项同时乘或除一个相同的数，比值不变，所以0.75:2可以同时乘100变成：75:200，然后求出75和200的最大公因数25，进行化简：(75除25):(200除25) = 3:8，3和8是互质数 比的应用： 1、已知30g的洗涤剂要兑5kg水，那么洗涤剂和水的比是：30:5000，也等于3:500，反过来水和洗涤剂的比就是：500:3，那么洗涤剂就占总量的3/503，水就占总量的500/503 2、小明按1:4的比例配了一瓶500ml的液体，问其中浓缩液和水的体积分别是多少？ 将500平均分成5份，求出其中1份的体积，再按比例求出剩下4份的体积 500除(1+4) = 500除5 = 100(ml)，水：100*4 = 400(ml)，因为比例是1:4，所以可以直接1+4求出所有的份数，再通过除法求出其中1份的体积。 3、学校把栽70课树的任务，按照6年级3个班的人数分配给各班，1班有46人，2班有44人，3班有50人，3个班各应栽多少颗树？ 将每个班的人数加起来作为总人数，然后按照70乘（每个班的人数/总人数）的比例分配： 1班：70*(46/(46+44+50)) = 70*46/140，约分得到：23(颗) 2班：70*(44/(46+44+50)) = 70*44/140，约分得到：22(颗) 3班：70*(50/(46+44+50)) = 70*50/140，约分得到：25(颗) 4、用一个120厘米的铁丝做一个长方体，要求长方体的长宽高的比是3:2:1，那么长方体的长宽高分别是多少？ 将长宽高的比加起来得到总比，用120除以4再乘长方体各比除总比，因为一个长方体有4个长和4条宽和4条高，所有要除4再按比例分配： 长：120/4*(3/(3+2+1)) = 30*3/6，约分得：15厘米 宽：120/4*(2/(3+2+1)) = 30*2/6，约分得：10厘米 高：120/4*(1/(3+2+1)) = 30*1/6，约分得：5厘米 注意：如果是长方形的周长也不能直接按比分配，因为长方形有两个长和两个宽，要先除2再按比分配。 圆的周长： 穿过圆心往外射出的一条直线叫做圆的直径，通过圆心往外射出的半条直线叫做圆的半径，半径乘2 = 直径 圆周律：是一个无限不循环小数，为：3.14159265357.... 一般取后面的两位为：3.14 圆的周长 = 圆周律乘圆的直径 直径和周长的比值关系： 1:3.14 2:6.28 可以记一下圆周长的乘法口诀表： 3.14*1 = 3.14 3.14*2 = 6.28 3.14*3 = 9.42 3.14*4 = 12.56 3.14*5 = 15.7 3.14*6 = 18.84 3.14*7 = 21.98 3.14*8 = 25.12 3.14*9 = 28.26 问： 1、已知一个花坛的半径为10m，自行车车轮的半径为25cm，骑自行车绕花坛一圈，车轮要转动多少周？ 10*2*3.14 = 62.8米 25*2*3.14 = 157厘米 62.8米 = 6280米 6280/157 = 40周 2、已知一个圆的周长是12.56，求圆的半径 12.56/3.14 = 4 4/2 = 2 圆的面积： S = 3.14*(半径*半径) 可以背半径的平方的公式： 2^2 = 4 3^2 = 9 4^2 = 16 5^2 = 25 6^2 = 36 7^2 = 49 8^2 = 64 9^2 = 91 0.9^2 = 0.81 问： 已知圆的面积是314，求圆的直径 314/3.14 = 100 100/10 = 10 10*2 = 20 环形的面积： 一个光盘的银色部分是一个圆环，内圆半径是2cm，外圆半径是6cm，光盘的面积是多少？ S环 = S外圆 - S内圆 = 3.14*(6*6) - 3.14*(2*2) = 3.14*36 - 3.14*4 = 113.04 - 12.56 = 100.48(cm^2) 百分数： 通过通分使一些分数的分母变成100，这些分数就可以变成百分数 百分数就是百分率，百分比 百分数可以有小数，比如：3.14% 百分数并不是代表一百里面所占的比例，这里的百是代表全部，如：出勤率是100%，意思是出勤的人数占公司全部人数的百分百 百分数不可以表示一个具体的数量，只能表示两个数之间的关系，所以百分数和分数是有区别的，分数既可以表示一个具体的数量，也可以表示两个数之间的关系，如：一个苹果是80%克，这种说法是错误的。 今年小麦总产量比去年增产8%，今年小麦总产量是去年总产量的108% 百分数和小数的转换： 17/100 = 0.17 = 17% 250/100 = 2.5 = 250% 0.24 = 24/100 = 24% 1.4 = 14/10 = 140/100 = 140% 0.123 = 123/1000 = 12.3/100 = 12.3% 小数转百分数的规律就是小数点向右移动两位 百分数转小数的规律就是小数点向左移动两位 20% = 20/100 = 1/5 80% = 80/100 = 4/5 如果遇到除不尽的分数可以保留3位小数： 1/14 = 0.071 = 7.1/100 = 7.1% 六年级人数有160人，其中及格的人数是120人，问及格率是多少？ 120/160 = 0.75 = 75% 种子的发芽率是105%的说法是错误的，因为不可能种下100颗种子，发芽105颗 20g糖融入100g水中，糖水的含糖率是20%的说法是错误的，因为糖水是120g，20/120 = 16.7% 百分数的应用： 5是4的百分之几? 5/4 4是5的百分之几? 4/5 甲是60，已是30，甲比乙多百分之几? (60-30)/30 = 100% 1、原计划植树12颗，实际植树14颗，实际植树比原计划增加百分之几？ (14-12)/12 = 2/12 = 0.167 = 16.7%，这里的单位一是原计划 原计划比实际植树少百分之几? (14-12)/14 = 2/14 = 0.143 = 14.3%，这里的单位一是实际植树 注意：要找准单位一 2、一个班有56人，女生有24人，男生有32人： 男生人数比女生人数多百分之几？ (32-24)/24 = 33.3%，这里的单位一是女生人数 女生人数比男生人数少百分之几？ (32-24)/32 = 25%，这里的单位一是男生人数 3、一辆自行车现价是312元，比原价降低了168元，问降低了百分之几？ 168/(312+168) = 168/480 = 35%，这里的单位一是原价 4、一批种子的发芽率是90%，有20粒种子没有发芽，这批种子有多少粒发芽？ 20/(1-90%) = 20/10% = 20/0.1 = 200，这里是把一批种子看作单位一 200*90% = 200*0.9 = 180，发芽的是90%，那么没有发芽的就是10% 打折： 原价1000元，现价700元，那么就是打了7折，七折就是70%也就是0.7 原价100元，现价70元，也是7折，用70/100得到70% 原价10元，现价7元，也是7折 原价1元，现价0.7元，也是7折 6折就是60% 7.5折就是十分之7.5，也就是75% 8.5折就是85% 现价 = 原价乘折扣 折扣 = 现价除原价 原价 = 现价除折扣 负数： 一个正数的相反数叫做负数 比如1的负数是-1 0既不是负数也不是正数 一条直线规定了原点、方向、正负数的就叫做数轴 原点右边的数叫做正数，左边叫做负数 正数比0要大，负数比0要小 零下9度比零下10度要高1度，因为零下9是-9，而零下10是-10 -a一定是负数的说法是错误的，因为0既不是正数也不是负数 没有最小的正数 圆柱： 圆柱的上面和下面都是相同的圆叫做圆柱的两个底面 圆柱的两个底面之间的距离叫做圆柱的高 圆柱的侧面是一个曲面 圆柱的侧面展开之后是一个长方形 圆柱展开后的长方形的长就是圆柱底面的周长，宽就是圆柱的高 圆柱的粗细是由底面的大小决定 圆柱的高矮是由圆柱的高决定 如果一个圆柱的侧面展开是一个正方形，那么这个圆柱的高就是圆柱的底面周长 一个长方形的纸可以围成两个不同底面的圆柱，一个是长做低面，另一个是宽做底面，长做底面那么圆柱的底面周长就大一些，高矮一些，宽做底面那么圆柱的底面周长就小一些，高长一些。 注意：圆柱只有沿着高线剪开才是一个长方形，如果沿着不规则的线剪开就是一个不规则图形，可能剪成平行四边形，也可能剪成梯形。","categories":[{"name":"学习","slug":"学习","permalink":"https://yswm-m.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"数学","slug":"数学","permalink":"https://yswm-m.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"小学数学1~3年级","slug":"04-小学数学1~3年级","date":"2022-09-15T01:00:00.000Z","updated":"2022-10-17T01:24:07.934Z","comments":true,"path":"posts/4.html","link":"","permalink":"https://yswm-m.github.io/posts/4.html","excerpt":"","text":"文章内容: 1，2，3，4，5，6，7，8，9，10 +加 -减 *乘 /除 正方体的六个面都是一样的 长方体也有六个面 圆柱是上面和下面是一个平面,中间是固体 球是圆圆的 三角形有三条边，三个角 圆形是圆的 长方形有四条边四个角 正方形有四条边四个角,其中四条边相等 两个三角形可以拼凑成一个长方形，也可以拼凑成一个正方形 两个正方形可以拼凑成一个长方形 两个长方形可以拼凑成一个正方形 1角等于10分 1元等于10角 1元等于100分 锐角：比直角小 钝角：比直角大 1千克等于1000克 500克等于1斤 1厘米=10毫米 1分米=10厘米 1米=10分米 1米=100厘米 1千米=1000米 1公里=1千米 一圈是400米，两圈半就是1千米 1千克=1000克 1吨=1000千克 四边形有四条直的边,有四个角 长方形和正方形是特殊的四边形 长方形是对边相等,正方形是每条边都相等 平行四边形的对边是相等的 平行四边形不具有稳定性，三角形具有稳定性 首尾相联的图形是封闭图形，封闭图形一周的长度叫做周长 把五角星的每一个角的边求出来再相加就是它的周长 长方形的周长=(长+宽)乘以2 正方形的周长=边长乘以4 余数:5%2==1;余数&lt;除数 组合排列:29/3=9(组).....2(只) 一小时=3600秒 5分之一大于8分之一,在分子相同的情况下,分母小的反而大 2个4之一就是4分之二,4分之三里面有三个4分之1 4分之4等于1 5分之3大于5分之2,分母相同的时候,分子大分数就大 6分之6大于6分之5 同分母分数相加,分母不变,分子相加 1减4分之1等于4分之3,将1看成4分之4 同分母分数相减,分母不变,分子相减 概率论:一个盒子里某种东西数量多抽出的概率就大,数量小抽出的概率就小 排列数字:739可以排列出6个不同的三位数,2*3=6 508可以排列出4个不同的数,因为0不能做开头 4个数字可以排列出24种不同的排列组合，4*6=24 排列组合的要点：只需要知道某一个为主可以摆出几个位置，再乘以人数就可以了。 注意:俩俩组合的时候只需要算一场就可以了,如:握手问题,踢球问题,每两个人握一次手,一共可以握3次,之所以不是六次是因为两个人之间不管是我和你握手还是你和我握手本质都是一样的 三个排列组合就是2+1,四个排列组合就是3+2+1,五个排列组合就是4+3+2+1，因为要跟其他人握手首先就是要减去自己的再去握其他人 上北下南左西右东 西北,西南,东北,东南 0/3=0，0除任何不是0的数都得0 0不能作为除数 大月：（1，3，5，7，8，10，12）月 小月：（4，6，9，11）月 特殊月：2月,平年28天,闰年29天 闰年366天,平年365天 要同时满足除以四和四百没有余数的才是闰年。 24小时计时法，时钟走两圈是24小时，从晚上0点开始计时走完两圈刚好是一天，下午1点可以计为12+1=13点 问：列车从下午2时40分出发到17时45分共花了多少时间? 答：将2时+12变成14时40分，再用17时45分减去14时40分=3时05分 平方厘米，平方分米，平方米 边长是1厘米的正方形面积是1平方厘米 边长是1分米的正方形面积是1平方分米 边长是1米的正方形面积是1平方米 长方形的面积=长乘宽 正方形的面积=边长乘边长 一个边长是1分米的正方形里面可以放100个边长是1厘米的小正方形 1分米=10厘米 1平方分米=100平方厘米 一个边长是1米的正方形里面可以放100个边长是1分米的小正方形 1米=10分米 1平方米=100平方分米 8平方米=800平方分米 8平方分米=800平方厘米 已知面积是6300平方分米,宽是7米,长是多少米? 答：把6300平方分米转换成平方米,6300平方分米=63平方米,再用63/7=9米 问：一个大纸条的长是6分米,宽是2分米,问可以裁多少张长3厘米,宽2厘米的纸条? 答:用6*2得12平方分米,将12平方分米转换成1200平方厘米,再用3*2得6平方厘米,用1200/6=200平方厘米 边长是100米的正方形面积是1公顷 也就是说1公顷=10000平方米=1万平方米 边长是1千米的正方形面积是1平方千米 1000*1000=1000000平方米=100万平方米=1平方千米=100公顷 问：一个边长为600米的正方形场地,每公顷收8块钱,这个场地一共可以收多少钱? 答:600*600=360000平方米=36公顷，36*8=288（元） 5.98表示两位小数表示5元9角8分 0.85表示8角5分 1分米=10分之1米=0.1米 1厘米=100分之1米=0.01米 1米30厘米=1.30米 1.2米=1米2分米 0.9米=9分米=90厘米，0.88米=88厘米，所以0.9&gt;0.88 3.36元=3元3角6分 1.28米=1米2分米8厘米 25.8+6.8=32.6元 1.2-0.9=0.3 9角+1.2元=0.9+1.2=2.1元 集合： 重叠问题,比如说有人既在一个集合里又在另一个集合里那么就可以把两个集合的人数加起来再减去重复的人数就是总人数 问：一个班有36人,做对第一道题的有21人,做对第二道题的有18人,两道都做对的有几人？ 答：21+18-36=3人，用做对第一道题的人数加做对第二道题的人数减去全班的人数就可以得到两道都做对的人数 等量代换： 一个西瓜的重量=4个砝码,4个苹果=1个砝码，那么一个西瓜就等于16个苹果 两只鸭=1只鹅,两只鹅&gt;4只鸡,那么两只鹅就=4只鸭,两只鹅&gt;4只鸡那么4只鸭就&gt;4只鸡,那么1只鸭就&gt;1只鸡","categories":[{"name":"学习","slug":"学习","permalink":"https://yswm-m.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"数学","slug":"数学","permalink":"https://yswm-m.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Markdown语法","slug":"03-Markdown语法","date":"2022-09-14T01:35:00.000Z","updated":"2022-09-27T02:19:50.565Z","comments":true,"path":"posts/3.html","link":"","permalink":"https://yswm-m.github.io/posts/3.html","excerpt":"","text":"文章内容: # Markdown入门 # *#后面一定要打空格多个#号代表多级标题* # #后面一定要打空格 ## vscode编写Markdown需要用到的扩展： ### Markdown Preview Enhanced *实时看到编写的内容* ### Markdown All in One *编写语法* ### Paste Image *插入图片* ### LimfxCodeEx *快速发表,没啥用* ### Code Spell Checker *拼写检查* 直接写就是正文 *旧版里空两行才代表换行或者空两格* &lt;!--这个才是注释--&gt; *两个星号代表斜体,快捷键Ctrl+i* **四个星号代表加粗,快捷键Ctrl+b** ***斜体加粗六个星号*** (2) 列表 &lt;h4 style=\"margin-left:200px\"&gt;也可以使用html语法&lt;/h4&gt; &lt;h4 style=\"background-color:red\"&gt;改变文字颜色&lt;/h4&gt; 1. 有序列表 2. 1.后面必须要加空格 1. 支持用tab键缩进成二级标题 1. 三级标题 2. 三级标题的第二个段落 3. 第三个一级标题 4. 如果要从1开始只需要在列表中间加段落就行了，或者可以在下一行什么都不写 空了一行又从1级标题重新开始了 - 无序列表&lt;!--无序列表+和*都可以--&gt; - 在-后面必须要有空格 - 也支持tab二级标题 - 三级标题 ==高亮== 我是^上标^ 我是~下标~ ~~删除线~~&lt;!--用四个波浪线--&gt; --- 分割线 插入图片 ![](QQ图片20210808153543.jpg) 本地图片 网络地址图片 ![image](https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2022%2F0121%2F42937ad6j00r6224r000mc000hs00e4g.jpg&amp;thumbnail=650x2147483647&amp;quality=80&amp;type=jpg) *快捷键是Ctrl+Alt+v* 写公式 $$ \\lim_{x \\to \\infin}\\frac{sin(t)}{x}=1 $$ 也可以在一段文字中插入 $\\lim_{x \\to \\infin}$ 公式，快捷键是Ctrl+m,按两个m可以生成4个$ ### 表格 | 小明 | 大明 | 姚明 | | ---- | :---: | ---- | | 1.5 | 1.7 | 1.9 | | 2 | 2 | 2 | 一个冒号左对齐，两个冒号右对齐 表格在其他编译器里直接Ctrl+T就可以插入 ### 引用 &gt;一二三 &gt;&gt;三四五 &gt;&gt;&gt;六七八 ### 链接 这是一个[链接](https://www.douban.com/) https://www.douban.com/ 直接把链接复制黏贴添加到文字上 代码块 ```cpp #include &lt;iostream&gt; using namespace std; int main() { //在三个`后面指定语言 printf(\"Hello,World\"); cout&lt;&lt;\"Hello,World\"&lt;&lt;endl; return 0; } 结束标记：``` 可以在右边视图里右键Chrome(Puppeteer)导出成ptf或jpg Ctrl+k+Z 可以进入全屏模式，只要按两下ESC就可以退出 代码块 ```cpp #include &lt;iostream&gt; using namespace std; int main() { cout&lt;&lt;\"Hello,World\"&lt;&lt;endl; return 0; } 结束标记：``` - 无序列表 1. 有序 2. 列表 3. 三级列表 ==高亮== 小明|大明|姚明 --|--|-- 22|33|44 列表","categories":[{"name":"学习","slug":"学习","permalink":"https://yswm-m.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"人生感悟","slug":"02-人生感悟","date":"2022-09-14T01:33:00.000Z","updated":"2022-09-27T02:19:24.218Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://yswm-m.github.io/posts/2.html","excerpt":"","text":"文章内容: 混一天和努力一天，一天看不出任何差别，三天看不到任何变化，七天也看不到任何距离…… 但是一个月后会看到话题不同，三个月后会看到气场不同，半年后会看到距离不同，一年后会看到人生道路截然不同。 请坚信你所喜爱的事物！ 世界上有10种人，一种是懂二进制的，另一种是不懂二进制的~ 自卑和傲慢是一回事，你潜意识里瞧不起无能的人，才会觉得别人也可能瞧不起无能的你。 走过弯路，回头才有可能看清直路。人的一生，痛苦和骄傲都应拥有 有很多事，不是你放不下，就一定要勉强举着，这样只会一点点消磨你对它的热爱。——《棋魂》 我深怕自己本非美玉，故而不敢加以刻苦琢磨，却又半信自己是块美玉，故又不肯庸庸碌碌，与瓦砾为伍。于是我渐渐地脱离凡尘，疏远世人，结果便是一任愤懑与羞恨日益助长内心那怯弱的自尊心。 对未来的真正慷慨，是把一切献给现在。——加缪 说花美就会有人说“也有不美的花”。 预想到会有这种抱怨于是写“既有美丽的花也有不美的花”。这已经是废话了。 让所有人都认同的文字称不上表达。表达需要勇气。——铃木光司 真正的力量，永远不会属于天生就强壮过人，敏捷过人，聪明过人的家伙，绝不，它只会属于...愿意不惜一切达成目地的人。——希尔科 这是一生雾梦的个人博客 以后会更新很多的内容 欢迎你收藏本网址 有问题请跳转到：百度","categories":[{"name":"生活","slug":"生活","permalink":"https://yswm-m.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://yswm-m.github.io/tags/%E6%83%B3%E6%B3%95/"},{"name":"人生","slug":"人生","permalink":"https://yswm-m.github.io/tags/%E4%BA%BA%E7%94%9F/"}]},{"title":"hexo博客搭建教程","slug":"01-hexo博客搭建教程","date":"2022-09-14T01:14:00.000Z","updated":"2023-05-12T11:12:08.805Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://yswm-m.github.io/posts/1.html","excerpt":"","text":"文章内容: 推荐观看视频教程 准备工具: node.js: node -v Git: git --version Hexo: npm install hexo-cli -g hexo -v 在github上建一个仓库,仓库名叫:注册名.github.io,也就是yswm-m.github.io 然后将下面的Add a README file选项给勾上 然后在任意一个盘新建文件夹,在文件夹里打开Git Bach Here,输入ssh查看密钥是否安装,然后输入:ssh-keygen -t rsa -C \"3269661045@qq.com\",然后按4次回车 这时在电脑的C盘下的用户文件夹里已经生成了一个.ssh文件夹,将里面的id_rsa.pub文件打开,复制里面的密钥,回到github,在个人中心里点击Setting,然后在侧边栏点击SSH and GPG keys,然后点击New SSH key按钮 将密钥复制进Key里,Title可以随便填,点击Add SSH Key保存, 回到Git Bach Here输入:ssh -T git@github.com 再输入yes,检查密钥是否添加成功,然后退出Git 在任意一个盘新建文件夹用来存放博客文章,在文件夹里面重新打开Git Bach Here,输入hexo init初始化博客文件 输入hexo s运行本地服务 ctrl+c终止本地服务 打开文件夹里的_config.yml文件,修改里面的deploy字段为: deploy: type: git repository: 项目在github上的地址 branch: main 重新打开Git Bach Here输入:npm install hexo-deployer-git --save 然后输入:hexo g拉取资源生成页面 输入:hexo d上传文件到仓库,第一次输入需要密码,上传成功后访问https://yswm-m.github.io/ 就可以查看博客了 如果hexo d上传不成功的解决办法: 首先第一步进入你的/Blog文件夹找到并删除.deploy_git文件夹; 然后在Git bash里依次输入: git config --global core.autocrlf false hexo clean hexo g hexo d 如果还不行的话，可能是账户认证出现了问题，需要你输入： git config --global user.email \"邮箱\" git config --global user.name \"用户名\" 最后再试试上传，看见INFO Deploy done： git就代表成功啦","categories":[{"name":"学习","slug":"学习","permalink":"https://yswm-m.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"}]}],"categories":[{"name":"C++","slug":"C","permalink":"https://yswm-m.github.io/categories/C/"},{"name":"刷题","slug":"刷题","permalink":"https://yswm-m.github.io/categories/%E5%88%B7%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://yswm-m.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://yswm-m.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://yswm-m.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"数据库","slug":"数据库","permalink":"https://yswm-m.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"linux","slug":"linux","permalink":"https://yswm-m.github.io/categories/linux/"},{"name":"学习","slug":"学习","permalink":"https://yswm-m.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"生活","slug":"生活","permalink":"https://yswm-m.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://yswm-m.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"学习","slug":"学习","permalink":"https://yswm-m.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"笔记","slug":"笔记","permalink":"https://yswm-m.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"练习","slug":"练习","permalink":"https://yswm-m.github.io/tags/%E7%BB%83%E4%B9%A0/"},{"name":"比赛","slug":"比赛","permalink":"https://yswm-m.github.io/tags/%E6%AF%94%E8%B5%9B/"},{"name":"排序","slug":"排序","permalink":"https://yswm-m.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"高精度","slug":"高精度","permalink":"https://yswm-m.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"再战","slug":"再战","permalink":"https://yswm-m.github.io/tags/%E5%86%8D%E6%88%98/"},{"name":"每日一题","slug":"每日一题","permalink":"https://yswm-m.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"动态规划","slug":"动态规划","permalink":"https://yswm-m.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"案例","slug":"案例","permalink":"https://yswm-m.github.io/tags/%E6%A1%88%E4%BE%8B/"},{"name":"英语","slug":"英语","permalink":"https://yswm-m.github.io/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"数学","slug":"数学","permalink":"https://yswm-m.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"想法","slug":"想法","permalink":"https://yswm-m.github.io/tags/%E6%83%B3%E6%B3%95/"},{"name":"人生","slug":"人生","permalink":"https://yswm-m.github.io/tags/%E4%BA%BA%E7%94%9F/"}]}